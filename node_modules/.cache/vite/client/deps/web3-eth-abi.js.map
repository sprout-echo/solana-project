{
  "version": 3,
  "sources": ["../../../../web3-eth-abi/src/utils.ts", "../../../../web3-eth-abi/src/api/errors_api.ts", "../../../../web3-eth-abi/src/api/events_api.ts", "../../../../abitype/dist/chunk-WP7KDV47.mjs", "../../../../abitype/dist/chunk-NHABU752.mjs", "../../../../abitype/dist/index.mjs", "../../../../web3-eth-abi/src/coders/utils.ts", "../../../../web3-eth-abi/src/coders/base/address.ts", "../../../../web3-eth-abi/src/coders/base/numbersLimits.ts", "../../../../web3-eth-abi/src/coders/base/number.ts", "../../../../web3-eth-abi/src/coders/base/bool.ts", "../../../../web3-eth-abi/src/coders/base/bytes.ts", "../../../../web3-eth-abi/src/coders/base/string.ts", "../../../../web3-eth-abi/src/coders/base/utils.ts", "../../../../web3-eth-abi/src/coders/base/array.ts", "../../../../web3-eth-abi/src/coders/base/index.ts", "../../../../web3-eth-abi/src/coders/base/tuple.ts", "../../../../web3-eth-abi/src/coders/decode.ts", "../../../../web3-eth-abi/src/coders/encode.ts", "../../../../web3-eth-abi/src/api/parameters_api.ts", "../../../../web3-eth-abi/src/api/functions_api.ts", "../../../../web3-eth-abi/src/api/logs_api.ts", "../../../../web3-eth-abi/src/decode_contract_error_data.ts", "../../../../web3-eth-abi/src/eip_712.ts"],
  "sourcesContent": ["\uFEFF/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiError } from 'web3-errors';\nimport { isNullish, isUint8Array, leftPad, rightPad, toHex } from 'web3-utils';\nimport {\n\tAbiInput,\n\tAbiCoderStruct,\n\tAbiFragment,\n\tAbiParameter,\n\tAbiStruct,\n\tAbiEventFragment,\n\tAbiFunctionFragment,\n\tAbiConstructorFragment,\n} from 'web3-types';\n\nexport const isAbiFragment = (item: unknown): item is AbiFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t['function', 'event', 'constructor', 'error'].includes((item as { type: string }).type);\n\nexport const isAbiErrorFragment = (item: unknown): item is AbiEventFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'error';\n\nexport const isAbiEventFragment = (item: unknown): item is AbiEventFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'event';\n\nexport const isAbiFunctionFragment = (item: unknown): item is AbiFunctionFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'function';\n\nexport const isAbiConstructorFragment = (item: unknown): item is AbiConstructorFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'constructor';\n\n/**\n * Check if type is simplified struct format\n */\nexport const isSimplifiedStructFormat = (\n\ttype: string | Partial<AbiParameter> | Partial<AbiInput>,\n): type is Omit<AbiParameter, 'components' | 'name'> =>\n\ttypeof type === 'object' &&\n\ttypeof (type as { components: unknown }).components === 'undefined' &&\n\ttypeof (type as { name: unknown }).name === 'undefined';\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n */\nexport const mapStructNameAndType = (structName: string): AbiStruct =>\n\tstructName.includes('[]')\n\t\t? { type: 'tuple[]', name: structName.slice(0, -2) }\n\t\t: { type: 'tuple', name: structName };\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n */\nexport const mapStructToCoderFormat = (struct: AbiStruct): Array<AbiCoderStruct> => {\n\tconst components: Array<AbiCoderStruct> = [];\n\n\tfor (const key of Object.keys(struct)) {\n\t\tconst item = struct[key];\n\n\t\tif (typeof item === 'object') {\n\t\t\tcomponents.push({\n\t\t\t\t...mapStructNameAndType(key),\n\t\t\t\tcomponents: mapStructToCoderFormat(item as unknown as AbiStruct),\n\t\t\t});\n\t\t} else {\n\t\t\tcomponents.push({\n\t\t\t\tname: key,\n\t\t\t\ttype: struct[key] as string,\n\t\t\t});\n\t\t}\n\t}\n\treturn components;\n};\n\n/**\n * Map types if simplified format is used\n */\nexport const mapTypes = (\n\ttypes: AbiInput[],\n): Array<string | AbiParameter | Record<string, unknown>> => {\n\tconst mappedTypes: Array<string | AbiParameter | Record<string, unknown>> = [];\n\n\tfor (const type of types) {\n\t\tlet modifiedType = type;\n\n\t\t// Clone object\n\t\tif (typeof type === 'object') {\n\t\t\tmodifiedType = { ...type };\n\t\t}\n\n\t\t// Remap `function` type params to bytes24 since Ethers does not\n\t\t// recognize former type. Solidity docs say `Function` is a bytes24\n\t\t// encoding the contract address followed by the function selector hash.\n\t\tif (typeof type === 'object' && type.type === 'function') {\n\t\t\tmodifiedType = { ...type, type: 'bytes24' };\n\t\t}\n\n\t\tif (isSimplifiedStructFormat(modifiedType)) {\n\t\t\tconst structName = Object.keys(modifiedType)[0] as unknown as keyof typeof modifiedType;\n\n\t\t\tmappedTypes.push({\n\t\t\t\t...mapStructNameAndType(structName),\n\t\t\t\tcomponents: mapStructToCoderFormat(\n\t\t\t\t\tmodifiedType[structName] as unknown as AbiStruct,\n\t\t\t\t) as unknown as AbiParameter[],\n\t\t\t});\n\t\t} else {\n\t\t\tmappedTypes.push(modifiedType);\n\t\t}\n\t}\n\n\treturn mappedTypes;\n};\n\n/**\n * returns true if input is a hexstring and is odd-lengthed\n */\nexport const isOddHexstring = (param: unknown): boolean =>\n\ttypeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\n\n/**\n * format odd-length bytes to even-length\n */\nexport const formatOddHexstrings = (param: string): string =>\n\tisOddHexstring(param) ? `0x0${param.substring(2)}` : param;\n\nconst paramTypeBytes = /^bytes([0-9]*)$/;\nconst paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\nconst paramTypeNumber = /^(u?int)([0-9]*)$/;\nconst paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/;\n/**\n * Handle some formatting of params for backwards compatibility with Ethers V4\n */\nexport const formatParam = (type: string, _param: unknown): unknown => {\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\t// clone if _param is an object\n\tconst param = typeof _param === 'object' && !Array.isArray(_param) ? { ..._param } : _param;\n\n\t// Format BN to string\n\tif (param instanceof BigInt || typeof param === 'bigint') {\n\t\treturn param.toString(10);\n\t}\n\n\tif (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\tconst paramClone = [...(param as Array<unknown>)];\n\t\treturn paramClone.map(p => formatParam(type.replace('[]', ''), p));\n\t}\n\n\t// Format correct width for u?int[0-9]*\n\tlet match = paramTypeNumber.exec(type);\n\tif (match) {\n\t\tconst size = parseInt(match[2] ? match[2] : '256', 10);\n\t\tif (size / 8 < (param as { length: number }).length) {\n\t\t\t// pad to correct bit width\n\t\t\treturn leftPad(param as string, size);\n\t\t}\n\t}\n\n\t// Format correct length for bytes[0-9]+\n\tmatch = paramTypeBytes.exec(type);\n\tif (match) {\n\t\tconst hexParam = isUint8Array(param) ? toHex(param) : param;\n\n\t\t// format to correct length\n\t\tconst size = parseInt(match[1], 10);\n\t\tif (size) {\n\t\t\tlet maxSize = size * 2;\n\n\t\t\tif ((param as string).startsWith('0x')) {\n\t\t\t\tmaxSize += 2;\n\t\t\t}\n\t\t\t// pad to correct length\n\t\t\tconst paddedParam =\n\t\t\t\t(hexParam as string).length < maxSize\n\t\t\t\t\t? rightPad(param as string, size * 2)\n\t\t\t\t\t: hexParam;\n\t\t\treturn formatOddHexstrings(paddedParam as string);\n\t\t}\n\n\t\treturn formatOddHexstrings(hexParam as string);\n\t}\n\treturn param;\n};\n\n/**\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\n */\n\nexport const flattenTypes = (\n\tincludeTuple: boolean,\n\tputs: ReadonlyArray<AbiParameter>,\n): string[] => {\n\tconst types: string[] = [];\n\n\tputs.forEach(param => {\n\t\tif (typeof param.components === 'object') {\n\t\t\tif (!param.type.startsWith('tuple')) {\n\t\t\t\tthrow new AbiError(\n\t\t\t\t\t`Invalid value given \"${param.type}\". Error: components found but type is not tuple.`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst arrayBracket = param.type.indexOf('[');\n\t\t\tconst suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\n\t\t\tconst result = flattenTypes(includeTuple, param.components);\n\n\t\t\tif (Array.isArray(result) && includeTuple) {\n\t\t\t\ttypes.push(`tuple(${result.join(',')})${suffix}`);\n\t\t\t} else if (!includeTuple) {\n\t\t\t\ttypes.push(`(${result.join(',')})${suffix}`);\n\t\t\t} else {\n\t\t\t\ttypes.push(`(${result.join()})`);\n\t\t\t}\n\t\t} else {\n\t\t\ttypes.push(param.type);\n\t\t}\n\t});\n\n\treturn types;\n};\n\n/**\n * Should be used to create full function/event name from json abi\n * returns a string\n */\nexport const jsonInterfaceMethodToString = (json: AbiFragment): string => {\n\tif (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {\n\t\tif (json.name?.includes('(')) {\n\t\t\treturn json.name;\n\t\t}\n\n\t\treturn `${json.name ?? ''}(${flattenTypes(false, json.inputs ?? []).join(',')})`;\n\t}\n\n\t// Constructor fragment\n\treturn `(${flattenTypes(false, json.inputs ?? []).join(',')})`;\n};\n", "\uFEFF/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n *\n *  @module ABI\n */\n\nimport { sha3Raw } from 'web3-utils';\nimport { AbiError } from 'web3-errors';\nimport { AbiErrorFragment } from 'web3-types';\nimport { jsonInterfaceMethodToString, isAbiErrorFragment } from '../utils.js';\n\n/**\n * Encodes the error name to its ABI signature, which are the sha3 hash of the error name including input types.\n */\nexport const encodeErrorSignature = (functionName: string | AbiErrorFragment): string => {\n\tif (typeof functionName !== 'string' && !isAbiErrorFragment(functionName)) {\n\t\tthrow new AbiError('Invalid parameter value in encodeErrorSignature');\n\t}\n\n\tlet name: string;\n\n\tif (functionName && (typeof functionName === 'function' || typeof functionName === 'object')) {\n\t\tname = jsonInterfaceMethodToString(functionName);\n\t} else {\n\t\tname = functionName;\n\t}\n\n\treturn sha3Raw(name);\n};\n", "\uFEFF/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n *\n *  @module ABI\n */\n\nimport { sha3Raw } from 'web3-utils';\nimport { AbiError } from 'web3-errors';\nimport { AbiEventFragment } from 'web3-types';\nimport { jsonInterfaceMethodToString, isAbiEventFragment } from '../utils.js';\n\n/**\n * Encodes the event name to its ABI signature, which are the sha3 hash of the event name including input types.\n * @param functionName - The event name to encode, or the {@link AbiEventFragment} object of the event. If string, it has to be in the form of `eventName(param1Type,param2Type,...)`. eg: myEvent(uint256,bytes32).\n * @returns - The ABI signature of the event.\n *\n * @example\n * ```ts\n * const event = web3.eth.abi.encodeEventSignature({\n *   name: \"myEvent\",\n *   type: \"event\",\n *   inputs: [\n *     {\n *       type: \"uint256\",\n *       name: \"myNumber\",\n *     },\n *     {\n *       type: \"bytes32\",\n *       name: \"myBytes\",\n *     },\n *   ],\n * });\n * console.log(event);\n * > 0xf2eeb729e636a8cb783be044acf6b7b1e2c5863735b60d6daae84c366ee87d97\n *\n *  const event = web3.eth.abi.encodeEventSignature({\n *   inputs: [\n *     {\n *       indexed: true,\n *       name: \"from\",\n *       type: \"address\",\n *     },\n *     {\n *       indexed: true,\n *       name: \"to\",\n *       type: \"address\",\n *     },\n *     {\n *       indexed: false,\n *       name: \"value\",\n *       type: \"uint256\",\n *     },\n *   ],\n *   name: \"Transfer\",\n *   type: \"event\",\n * });\n * console.log(event);\n * > 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n * ```\n */\nexport const encodeEventSignature = (functionName: string | AbiEventFragment): string => {\n\tif (typeof functionName !== 'string' && !isAbiEventFragment(functionName)) {\n\t\tthrow new AbiError('Invalid parameter value in encodeEventSignature');\n\t}\n\n\tlet name: string;\n\n\tif (functionName && (typeof functionName === 'function' || typeof functionName === 'object')) {\n\t\tname = jsonInterfaceMethodToString(functionName);\n\t} else {\n\t\tname = functionName;\n\t}\n\n\treturn sha3Raw(name);\n};\n", "// src/regex.ts\nfunction execTyped(regex, string) {\n  const match = regex.exec(string);\n  return match?.groups;\n}\nvar bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\nvar integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nvar isTupleRegex = /^\\(.+?\\).*?$/;\n\nexport {\n  execTyped,\n  bytesRegex,\n  integerRegex,\n  isTupleRegex\n};\n", "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\nexport {\n  __publicField\n};\n", "import {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex\n} from \"./chunk-WP7KDV47.mjs\";\nimport {\n  __publicField\n} from \"./chunk-NHABU752.mjs\";\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n\n// src/errors.ts\nvar BaseError = class extends Error {\n  constructor(shortMessage, args = {}) {\n    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\n    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    const message = [\n      shortMessage || \"An error occurred.\",\n      \"\",\n      ...args.metaMessages ? [...args.metaMessages, \"\"] : [],\n      ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],\n      ...details ? [`Details: ${details}`] : [],\n      `Version: ${name}@${version}`\n    ].join(\"\\n\");\n    super(message);\n    __publicField(this, \"details\");\n    __publicField(this, \"docsPath\");\n    __publicField(this, \"metaMessages\");\n    __publicField(this, \"shortMessage\");\n    __publicField(this, \"name\", \"AbiTypeError\");\n    if (args.cause)\n      this.cause = args.cause;\n    this.details = details;\n    this.docsPath = docsPath;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n};\n\n// src/narrow.ts\nfunction narrow(value) {\n  return value;\n}\n\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n  return execTyped(\n    errorSignatureRegex,\n    signature\n  );\n}\nvar eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n  return execTyped(\n    eventSignatureRegex,\n    signature\n  );\n}\nvar functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n  return execTyped(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n  return execTyped(\n    structSignatureRegex,\n    signature\n  );\n}\nvar constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n  return execTyped(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */ new Set([\n  \"memory\",\n  \"indexed\",\n  \"storage\",\n  \"calldata\"\n]);\nvar eventModifiers = /* @__PURE__ */ new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */ new Set([\n  \"calldata\",\n  \"memory\",\n  \"storage\"\n]);\n\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n  if (type)\n    return `${type}:${param}`;\n  return param;\n}\nvar parameterCache = /* @__PURE__ */ new Map([\n  // Unnamed\n  [\"address\", { type: \"address\" }],\n  [\"bool\", { type: \"bool\" }],\n  [\"bytes\", { type: \"bytes\" }],\n  [\"bytes32\", { type: \"bytes32\" }],\n  [\"int\", { type: \"int256\" }],\n  [\"int256\", { type: \"int256\" }],\n  [\"string\", { type: \"string\" }],\n  [\"uint\", { type: \"uint256\" }],\n  [\"uint8\", { type: \"uint8\" }],\n  [\"uint16\", { type: \"uint16\" }],\n  [\"uint24\", { type: \"uint24\" }],\n  [\"uint32\", { type: \"uint32\" }],\n  [\"uint64\", { type: \"uint64\" }],\n  [\"uint96\", { type: \"uint96\" }],\n  [\"uint112\", { type: \"uint112\" }],\n  [\"uint160\", { type: \"uint160\" }],\n  [\"uint192\", { type: \"uint192\" }],\n  [\"uint256\", { type: \"uint256\" }],\n  // Named\n  [\"address owner\", { type: \"address\", name: \"owner\" }],\n  [\"address to\", { type: \"address\", name: \"to\" }],\n  [\"bool approved\", { type: \"bool\", name: \"approved\" }],\n  [\"bytes _data\", { type: \"bytes\", name: \"_data\" }],\n  [\"bytes data\", { type: \"bytes\", name: \"data\" }],\n  [\"bytes signature\", { type: \"bytes\", name: \"signature\" }],\n  [\"bytes32 hash\", { type: \"bytes32\", name: \"hash\" }],\n  [\"bytes32 r\", { type: \"bytes32\", name: \"r\" }],\n  [\"bytes32 root\", { type: \"bytes32\", name: \"root\" }],\n  [\"bytes32 s\", { type: \"bytes32\", name: \"s\" }],\n  [\"string name\", { type: \"string\", name: \"name\" }],\n  [\"string symbol\", { type: \"string\", name: \"symbol\" }],\n  [\"string tokenURI\", { type: \"string\", name: \"tokenURI\" }],\n  [\"uint tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint8 v\", { type: \"uint8\", name: \"v\" }],\n  [\"uint256 balance\", { type: \"uint256\", name: \"balance\" }],\n  [\"uint256 tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint256 value\", { type: \"uint256\", name: \"value\" }],\n  // Indexed\n  [\n    \"event:address indexed from\",\n    { type: \"address\", name: \"from\", indexed: true }\n  ],\n  [\"event:address indexed to\", { type: \"address\", name: \"to\", indexed: true }],\n  [\n    \"event:uint indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ],\n  [\n    \"event:uint256 indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ]\n]);\n\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature, structs = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid function signature.\", {\n        details: signature\n      });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i], {\n          modifiers: functionModifiers,\n          structs,\n          type: \"function\"\n        })\n      );\n    }\n    const outputs = [];\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i], {\n            modifiers: functionModifiers,\n            structs,\n            type: \"function\"\n          })\n        );\n      }\n    }\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs,\n      outputs\n    };\n  }\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid event signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], {\n          modifiers: eventModifiers,\n          structs,\n          type: \"event\"\n        })\n      );\n    }\n    return { name: match.name, type: \"event\", inputs: abiParameters };\n  }\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid error signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"error\" })\n      );\n    }\n    return { name: match.name, type: \"error\", inputs: abiParameters };\n  }\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid constructor signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"constructor\" })\n      );\n    }\n    return {\n      type: \"constructor\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs: abiParameters\n    };\n  }\n  if (isFallbackSignature(signature))\n    return { type: \"fallback\" };\n  if (isReceiveSignature(signature))\n    return {\n      type: \"receive\",\n      stateMutability: \"payable\"\n    };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\nvar abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = getParameterCacheKey(param, options?.type);\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param\n  );\n  if (!match)\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param\n    });\n  if (match.name && isSolidityKeyword(match.name))\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\n        `\"${match.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`\n      ]\n    });\n  const name2 = match.name ? { name: match.name } : {};\n  const indexed = match.modifier === \"indexed\" ? { indexed: true } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = \"tuple\";\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], { structs }));\n    }\n    components = { components: components_ };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = { components: structs[match.type] };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === \"struct\") && !isSolidityType(type))\n      throw new BaseError(\"Unknown type.\", {\n        metaMessages: [`Type \"${type}\" is not a valid ABI type.`]\n      });\n  }\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`\n        ]\n      });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`,\n          `Data location can only be specified for array, struct, or mapping types, but \"${match.modifier}\" was given.`\n        ]\n      });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? \"\"}`,\n    ...name2,\n    ...indexed,\n    ...components\n  };\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params, result = [], current = \"\", depth = 0) {\n  if (params === \"\") {\n    if (current === \"\")\n      return result;\n    if (depth !== 0)\n      throw new BaseError(\"Unbalanced parentheses.\", {\n        metaMessages: [\n          `\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`\n        ],\n        details: `Depth \"${depth}\"`\n      });\n    return [...result, current.trim()];\n  }\n  const length = params.length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case \"(\":\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case \")\":\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  return [];\n}\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature))\n      continue;\n    const match = execStructSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature\n      });\n    const properties = match.properties.split(\";\");\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed)\n        continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature,\n        metaMessages: [\"No properties exist.\"]\n      });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name2, parameters] = entries[i];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple)\n      components.push(abiParameter);\n    else {\n      const match = execTyped(\n        typeWithoutTupleRegex,\n        abiParameter.type\n      );\n      if (!match?.type)\n        throw new BaseError(\"Invalid ABI parameter.\", {\n          details: JSON.stringify(abiParameter, null, 2),\n          metaMessages: [\"ABI parameter type is invalid.\"]\n        });\n      const { array, type } = match;\n      if (type in structs) {\n        if (ancestors.has(type))\n          throw new BaseError(\"Circular reference detected.\", {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`]\n          });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? \"\"}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            /* @__PURE__ */ new Set([...ancestors, type])\n          )\n        });\n      } else {\n        if (isSolidityType(type))\n          components.push(abiParameter);\n        else\n          throw new BaseError(\"Unknown type.\", {\n            metaMessages: [\n              `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`\n            ]\n          });\n      }\n    }\n  }\n  return components;\n}\n\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n  const structs = parseStructs(signatures);\n  const abi = [];\n  const length = signatures.length;\n  for (let i = 0; i < length; i++) {\n    const signature = signatures[i];\n    if (isStructSignature(signature))\n      continue;\n    abi.push(parseSignature(signature, structs));\n  }\n  return abi;\n}\n\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === \"string\")\n    abiItem = parseSignature(signature);\n  else {\n    const structs = parseStructs(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if (isStructSignature(signature_))\n        continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem)\n    throw new BaseError(\"Failed to parse ABI item.\", {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiitem-1\"\n    });\n  return abiItem;\n}\n\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n  let abiParameter;\n  if (typeof param === \"string\")\n    abiParameter = parseAbiParameter(param, {\n      modifiers\n    });\n  else {\n    const structs = parseStructs(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature))\n        continue;\n      abiParameter = parseAbiParameter(signature, { modifiers, structs });\n      break;\n    }\n  }\n  if (!abiParameter)\n    throw new BaseError(\"Failed to parse ABI parameter.\", {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameter-1\"\n    });\n  return abiParameter;\n}\n\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === \"string\") {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature))\n        continue;\n      const parameters = splitParameters(signature);\n      const length2 = parameters.length;\n      for (let k = 0; k < length2; k++) {\n        abiParameters.push(\n          parseAbiParameter(parameters[k], { modifiers, structs })\n        );\n      }\n    }\n  }\n  if (abiParameters.length === 0)\n    throw new BaseError(\"Failed to parse ABI parameters.\", {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameters-1\"\n    });\n  return abiParameters;\n}\nexport {\n  BaseError,\n  narrow,\n  parseAbi,\n  parseAbiItem,\n  parseAbiParameter2 as parseAbiParameter,\n  parseAbiParameters\n};\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiParameter as ExternalAbiParameter, parseAbiParameter } from 'abitype';\nimport { AbiError } from 'web3-errors';\nimport { AbiInput, AbiParameter, AbiStruct } from 'web3-types';\nimport { isNullish } from 'web3-utils';\nimport {\n\tisSimplifiedStructFormat,\n\tmapStructNameAndType,\n\tmapStructToCoderFormat,\n} from '../utils.js';\n\nexport const WORD_SIZE = 32;\n\nexport function alloc(size = 0): Uint8Array {\n\tif (globalThis.Buffer?.alloc !== undefined) {\n\t\tconst buf = globalThis.Buffer.alloc(size);\n\t\treturn new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\t}\n\n\treturn new Uint8Array(size);\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0): Uint8Array {\n\tif (globalThis.Buffer?.allocUnsafe !== undefined) {\n\t\tconst buf = globalThis.Buffer.allocUnsafe(size);\n\t\treturn new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\t}\n\n\treturn new Uint8Array(size);\n}\n\nexport function convertExternalAbiParameter(abiParam: ExternalAbiParameter): AbiParameter {\n\treturn {\n\t\t...abiParam,\n\t\tname: abiParam.name ?? '',\n\t\tcomponents: (abiParam as { components: readonly AbiParameter[] }).components?.map(c =>\n\t\t\tconvertExternalAbiParameter(c),\n\t\t),\n\t};\n}\n\nexport function isAbiParameter(param: unknown): param is AbiParameter {\n\treturn (\n\t\t!isNullish(param) &&\n\t\ttypeof param === 'object' &&\n\t\t!isNullish((param as { type: unknown }).type) &&\n\t\ttypeof (param as { type: unknown }).type === 'string'\n\t);\n}\n\nexport function toAbiParams(abi: ReadonlyArray<AbiInput>): ReadonlyArray<AbiParameter> {\n\treturn abi.map(input => {\n\t\tif (isAbiParameter(input)) {\n\t\t\treturn input;\n\t\t}\n\t\tif (typeof input === 'string') {\n\t\t\treturn convertExternalAbiParameter(parseAbiParameter(input.replace(/tuple/, '')));\n\t\t}\n\n\t\tif (isSimplifiedStructFormat(input)) {\n\t\t\tconst structName = Object.keys(input)[0];\n\t\t\tconst structInfo = mapStructNameAndType(structName);\n\t\t\tstructInfo.name = structInfo.name ?? '';\n\t\t\treturn {\n\t\t\t\t...structInfo,\n\t\t\t\tcomponents: mapStructToCoderFormat(\n\t\t\t\t\tinput[structName as keyof typeof input] as unknown as AbiStruct,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\t\tthrow new AbiError('Invalid abi');\n\t});\n}\n\nexport function extractArrayType(param: AbiParameter): { size: number; param: AbiParameter } {\n\tconst arrayParenthesisStart = param.type.lastIndexOf('[');\n\tconst arrayParamType = param.type.substring(0, arrayParenthesisStart);\n\tconst sizeString = param.type.substring(arrayParenthesisStart);\n\tlet size = -1;\n\tif (sizeString !== '[]') {\n\t\tsize = Number(sizeString.slice(1, -1));\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tif (isNaN(size)) {\n\t\t\tthrow new AbiError('Invalid fixed array size', { size: sizeString });\n\t\t}\n\t}\n\treturn {\n\t\tparam: { type: arrayParamType, name: '', components: param.components },\n\t\tsize,\n\t};\n}\n\n/**\n * Param is dynamic if it's dynamic base type or if some of his children (components, array items)\n * is of dynamic type\n * @param param\n */\nexport function isDynamic(param: AbiParameter): boolean {\n\tif (param.type === 'string' || param.type === 'bytes' || param.type.endsWith('[]')) return true;\n\tif (param.type === 'tuple') {\n\t\treturn param.components?.some(isDynamic) ?? false;\n\t}\n\tif (param.type.endsWith(']')) {\n\t\treturn isDynamic(extractArrayType(param).param);\n\t}\n\treturn false;\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter } from 'web3-types';\nimport { toChecksumAddress } from 'web3-utils';\nimport { isAddress, utils } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { alloc, WORD_SIZE } from '../utils.js';\n\nconst ADDRESS_BYTES_COUNT = 20;\nconst ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;\n\nexport function encodeAddress(param: AbiParameter, input: unknown): EncoderResult {\n\tif (typeof input !== 'string') {\n\t\tthrow new AbiError('address type expects string as input type', {\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\ttype: param.type,\n\t\t});\n\t}\n\tlet address = input.toLowerCase();\n\tif (!address.startsWith('0x')) {\n\t\taddress = `0x${address}`;\n\t}\n\tif (!isAddress(address)) {\n\t\tthrow new AbiError('provided input is not valid address', {\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\ttype: param.type,\n\t\t});\n\t}\n\t// for better performance, we could convert hex to destination bytes directly (encoded var)\n\tconst addressBytes = utils.hexToUint8Array(address);\n\t// expand address to WORD_SIZE\n\tconst encoded = alloc(WORD_SIZE);\n\tencoded.set(addressBytes, ADDRESS_OFFSET);\n\treturn {\n\t\tdynamic: false,\n\t\tencoded,\n\t};\n}\n\nexport function decodeAddress(_param: AbiParameter, bytes: Uint8Array): DecoderResult<string> {\n\tconst addressBytes = bytes.subarray(ADDRESS_OFFSET, WORD_SIZE);\n\tif (addressBytes.length !== ADDRESS_BYTES_COUNT) {\n\t\tthrow new AbiError('Invalid decoding input, not enough bytes to decode address', { bytes });\n\t}\n\tconst result = utils.uint8ArrayToHexString(addressBytes);\n\n\t// should we check is decoded value is valid address?\n\t// if(!isAddress(result)) {\n\t//     throw new AbiError(\"encoded data is not valid address\", {\n\t//         address: result,\n\t//     });\n\t// }\n\treturn {\n\t\tresult: toChecksumAddress(result),\n\t\tencoded: bytes.subarray(WORD_SIZE),\n\t\tconsumed: WORD_SIZE,\n\t};\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n * this variable contains the precalculated limits for all the numbers for uint and int types\n */\nexport const numberLimits = new Map<string, { min: bigint; max: bigint }>();\n\nlet base = BigInt(256); // 2 ^ 8 = 256\nfor (let i = 8; i <= 256; i += 8) {\n\tnumberLimits.set(`uint${i}`, {\n\t\tmin: BigInt(0),\n\t\tmax: base - BigInt(1),\n\t});\n\tnumberLimits.set(`int${i}`, {\n\t\tmin: -base / BigInt(2),\n\t\tmax: base / BigInt(2) - BigInt(1),\n\t});\n\tbase *= BigInt(256);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\nnumberLimits.set(`int`, numberLimits.get('int256')!);\n// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\nnumberLimits.set(`uint`, numberLimits.get('uint256')!);\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiError } from 'web3-errors';\nimport type { AbiParameter } from 'web3-types';\nimport { padLeft, toBigInt } from 'web3-utils';\nimport { utils } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { WORD_SIZE } from '../utils.js';\nimport { numberLimits } from './numbersLimits.js';\n\n// eslint-disable-next-line no-bitwise\nconst mask = BigInt(1) << BigInt(256);\n\nfunction bigIntToUint8Array(value: bigint, byteLength = WORD_SIZE): Uint8Array {\n\tlet hexValue;\n\tif (value < 0) {\n\t\thexValue = (mask + value).toString(16);\n\t} else {\n\t\thexValue = value.toString(16);\n\t}\n\thexValue = padLeft(hexValue, byteLength * 2);\n\treturn utils.hexToUint8Array(hexValue);\n}\n\nfunction uint8ArrayToBigInt(value: Uint8Array, max: bigint): bigint {\n\tconst hexValue = utils.uint8ArrayToHexString(value);\n\tconst result = BigInt(hexValue);\n\tif (result <= max) return result;\n\treturn result - mask;\n}\n\nexport function encodeNumber(param: AbiParameter, input: unknown): EncoderResult {\n\tlet value;\n\ttry {\n\t\tvalue = toBigInt(input);\n\t} catch (e) {\n\t\tthrow new AbiError('provided input is not number value', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t});\n\t}\n\tconst limit = numberLimits.get(param.type);\n\tif (!limit) {\n\t\tthrow new AbiError('provided abi contains invalid number datatype', { type: param.type });\n\t}\n\tif (value < limit.min) {\n\t\tthrow new AbiError('provided input is less then minimum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\tminimum: limit.min.toString(),\n\t\t});\n\t}\n\tif (value > limit.max) {\n\t\tthrow new AbiError('provided input is greater then maximum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t\tmaximum: limit.max.toString(),\n\t\t});\n\t}\n\treturn {\n\t\tdynamic: false,\n\t\tencoded: bigIntToUint8Array(value),\n\t};\n}\n\nexport function decodeNumber(param: AbiParameter, bytes: Uint8Array): DecoderResult<bigint> {\n\tif (bytes.length < WORD_SIZE) {\n\t\tthrow new AbiError('Not enough bytes left to decode', { param, bytesLeft: bytes.length });\n\t}\n\tconst boolBytes = bytes.subarray(0, WORD_SIZE);\n\tconst limit = numberLimits.get(param.type);\n\tif (!limit) {\n\t\tthrow new AbiError('provided abi contains invalid number datatype', { type: param.type });\n\t}\n\tconst numberResult = uint8ArrayToBigInt(boolBytes, limit.max);\n\n\tif (numberResult < limit.min) {\n\t\tthrow new AbiError('decoded value is less then minimum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: numberResult,\n\t\t\tname: param.name,\n\t\t\tminimum: limit.min.toString(),\n\t\t});\n\t}\n\tif (numberResult > limit.max) {\n\t\tthrow new AbiError('decoded value is greater then maximum for given type', {\n\t\t\ttype: param.type,\n\t\t\tvalue: numberResult,\n\t\t\tname: param.name,\n\t\t\tmaximum: limit.max.toString(),\n\t\t});\n\t}\n\treturn {\n\t\tresult: numberResult,\n\t\tencoded: bytes.subarray(WORD_SIZE),\n\t\tconsumed: WORD_SIZE,\n\t};\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError, InvalidBooleanError } from 'web3-errors';\nimport { AbiParameter } from 'web3-types';\nimport { toBool } from 'web3-utils';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { WORD_SIZE } from '../utils.js';\nimport { decodeNumber, encodeNumber } from './number.js';\n\nexport function encodeBoolean(param: AbiParameter, input: unknown): EncoderResult {\n\tlet value;\n\ttry {\n\t\tvalue = toBool(input);\n\t} catch (e) {\n\t\tif (e instanceof InvalidBooleanError) {\n\t\t\tthrow new AbiError('provided input is not valid boolean value', {\n\t\t\t\ttype: param.type,\n\t\t\t\tvalue: input,\n\t\t\t\tname: param.name,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn encodeNumber({ type: 'uint8', name: '' }, Number(value));\n}\n\nexport function decodeBool(_param: AbiParameter, bytes: Uint8Array): DecoderResult<boolean> {\n\tconst numberResult = decodeNumber({ type: 'uint8', name: '' }, bytes);\n\tif (numberResult.result > 1 || numberResult.result < 0) {\n\t\tthrow new AbiError('Invalid boolean value encoded', {\n\t\t\tboolBytes: bytes.subarray(0, WORD_SIZE),\n\t\t\tnumberResult,\n\t\t});\n\t}\n\treturn {\n\t\tresult: numberResult.result === BigInt(1),\n\t\tencoded: numberResult.encoded,\n\t\tconsumed: WORD_SIZE,\n\t};\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter, Bytes } from 'web3-types';\nimport { bytesToHex, bytesToUint8Array } from 'web3-utils';\nimport { isBytes, ValidInputTypes } from 'web3-validator';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { alloc, WORD_SIZE } from '../utils.js';\nimport { decodeNumber, encodeNumber } from './number.js';\n\nconst MAX_STATIC_BYTES_COUNT = 32;\n\nexport function encodeBytes(param: AbiParameter, input: unknown): EncoderResult {\n\t// hack for odd length hex strings\n\tif (typeof input === 'string' && input.length % 2 !== 0) {\n\t\t// eslint-disable-next-line no-param-reassign\n\t\tinput += '0';\n\t}\n\tif (!isBytes(input as ValidInputTypes)) {\n\t\tthrow new AbiError('provided input is not valid bytes value', {\n\t\t\ttype: param.type,\n\t\t\tvalue: input,\n\t\t\tname: param.name,\n\t\t});\n\t}\n\tconst bytes = bytesToUint8Array(input as Bytes);\n\tconst [, size] = param.type.split('bytes');\n\t// fixed size\n\tif (size) {\n\t\tif (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {\n\t\t\tthrow new AbiError(\n\t\t\t\t'invalid bytes type. Static byte type can have between 1 and 32 bytes',\n\t\t\t\t{\n\t\t\t\t\ttype: param.type,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\t\tif (Number(size) < bytes.length) {\n\t\t\tthrow new AbiError('provided input size is different than type size', {\n\t\t\t\ttype: param.type,\n\t\t\t\tvalue: input,\n\t\t\t\tname: param.name,\n\t\t\t});\n\t\t}\n\t\tconst encoded = alloc(WORD_SIZE);\n\t\tencoded.set(bytes);\n\t\treturn {\n\t\t\tdynamic: false,\n\t\t\tencoded,\n\t\t};\n\t}\n\n\tconst partsLength = Math.ceil(bytes.length / WORD_SIZE);\n\t// one word for length of data + WORD for each part of actual data\n\tconst encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);\n\n\tencoded.set(encodeNumber({ type: 'uint32', name: '' }, bytes.length).encoded);\n\tencoded.set(bytes, WORD_SIZE);\n\treturn {\n\t\tdynamic: true,\n\t\tencoded,\n\t};\n}\n\nexport function decodeBytes(param: AbiParameter, bytes: Uint8Array): DecoderResult<string> {\n\tconst [, sizeString] = param.type.split('bytes');\n\tlet size = Number(sizeString);\n\tlet remainingBytes = bytes;\n\tlet partsCount = 1;\n\tlet consumed = 0;\n\tif (!size) {\n\t\t// dynamic bytes\n\t\tconst result = decodeNumber({ type: 'uint32', name: '' }, remainingBytes);\n\t\tsize = Number(result.result);\n\t\tconsumed += result.consumed;\n\t\tremainingBytes = result.encoded;\n\t\tpartsCount = Math.ceil(size / WORD_SIZE);\n\t}\n\tif (size > bytes.length) {\n\t\tthrow new AbiError('there is not enough data to decode', {\n\t\t\ttype: param.type,\n\t\t\tencoded: bytes,\n\t\t\tsize,\n\t\t});\n\t}\n\n\treturn {\n\t\tresult: bytesToHex(remainingBytes.subarray(0, size)),\n\t\tencoded: remainingBytes.subarray(partsCount * WORD_SIZE),\n\t\tconsumed: consumed + partsCount * WORD_SIZE,\n\t};\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter } from 'web3-types';\nimport { hexToUtf8, utf8ToBytes } from 'web3-utils';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { decodeBytes, encodeBytes } from './bytes.js';\n\nexport function encodeString(_param: AbiParameter, input: unknown): EncoderResult {\n\tif (typeof input !== 'string') {\n\t\tthrow new AbiError('invalid input, should be string', { input });\n\t}\n\tconst bytes = utf8ToBytes(input);\n\treturn encodeBytes({ type: 'bytes', name: '' }, bytes);\n}\n\nexport function decodeString(_param: AbiParameter, bytes: Uint8Array): DecoderResult<string> {\n\tconst r = decodeBytes({ type: 'bytes', name: '' }, bytes);\n\treturn {\n\t\tresult: hexToUtf8(r.result),\n\t\tencoded: r.encoded,\n\t\tconsumed: r.consumed,\n\t};\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { uint8ArrayConcat } from 'web3-utils';\nimport { EncoderResult } from '../types.js';\nimport { WORD_SIZE } from '../utils.js';\nimport { encodeNumber } from './number.js';\n\nexport function encodeDynamicParams(encodedParams: ReadonlyArray<EncoderResult>): Uint8Array {\n\tlet staticSize = 0;\n\tlet dynamicSize = 0;\n\tconst staticParams: EncoderResult[] = [];\n\tconst dynamicParams: EncoderResult[] = [];\n\t// figure out static size\n\tfor (const encodedParam of encodedParams) {\n\t\tif (encodedParam.dynamic) {\n\t\t\tstaticSize += WORD_SIZE;\n\t\t} else {\n\t\t\tstaticSize += encodedParam.encoded.length;\n\t\t}\n\t}\n\n\tfor (const encodedParam of encodedParams) {\n\t\tif (encodedParam.dynamic) {\n\t\t\tstaticParams.push(\n\t\t\t\tencodeNumber({ type: 'uint256', name: '' }, staticSize + dynamicSize),\n\t\t\t);\n\t\t\tdynamicParams.push(encodedParam);\n\t\t\tdynamicSize += encodedParam.encoded.length;\n\t\t} else {\n\t\t\tstaticParams.push(encodedParam);\n\t\t}\n\t}\n\treturn uint8ArrayConcat(\n\t\t...staticParams.map(p => p.encoded),\n\t\t...dynamicParams.map(p => p.encoded),\n\t);\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter } from 'web3-types';\nimport { uint8ArrayConcat } from 'web3-utils';\n// eslint-disable-next-line import/no-cycle\nimport { decodeParamFromAbiParameter, encodeNumber, encodeParamFromAbiParameter } from './index.js';\nimport { DecoderResult, EncoderResult } from '../types.js';\nimport { extractArrayType, isDynamic, WORD_SIZE } from '../utils.js';\nimport { decodeNumber } from './number.js';\nimport { encodeDynamicParams } from './utils.js';\n\nexport function encodeArray(param: AbiParameter, values: unknown): EncoderResult {\n\tif (!Array.isArray(values)) {\n\t\tthrow new AbiError('Expected value to be array', { abi: param, values });\n\t}\n\tconst { size, param: arrayItemParam } = extractArrayType(param);\n\tconst encodedParams = values.map(v => encodeParamFromAbiParameter(arrayItemParam, v));\n\tconst dynamic = size === -1;\n\tconst dynamicItems = encodedParams.length > 0 && encodedParams[0].dynamic;\n\tif (!dynamic && values.length !== size) {\n\t\tthrow new AbiError(\"Given arguments count doesn't match array length\", {\n\t\t\tarrayLength: size,\n\t\t\targumentsLength: values.length,\n\t\t});\n\t}\n\tif (dynamic || dynamicItems) {\n\t\tconst encodingResult = encodeDynamicParams(encodedParams);\n\t\tif (dynamic) {\n\t\t\tconst encodedLength = encodeNumber(\n\t\t\t\t{ type: 'uint256', name: '' },\n\t\t\t\tencodedParams.length,\n\t\t\t).encoded;\n\t\t\treturn {\n\t\t\t\tdynamic: true,\n\t\t\t\tencoded:\n\t\t\t\t\tencodedParams.length > 0\n\t\t\t\t\t\t? uint8ArrayConcat(encodedLength, encodingResult)\n\t\t\t\t\t\t: encodedLength,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tdynamic: true,\n\t\t\tencoded: encodingResult,\n\t\t};\n\t}\n\n\treturn {\n\t\tdynamic: false,\n\t\tencoded: uint8ArrayConcat(...encodedParams.map(p => p.encoded)),\n\t};\n}\n\nexport function decodeArray(param: AbiParameter, bytes: Uint8Array): DecoderResult<unknown[]> {\n\t// eslint-disable-next-line prefer-const\n\tlet { size, param: arrayItemParam } = extractArrayType(param);\n\tconst dynamic = size === -1;\n\n\tlet consumed = 0;\n\tconst result: unknown[] = [];\n\tlet remaining = bytes;\n\t// dynamic array, we need to decode length\n\tif (dynamic) {\n\t\tconst lengthResult = decodeNumber({ type: 'uint32', name: '' }, bytes);\n\t\tsize = Number(lengthResult.result);\n\t\tconsumed = lengthResult.consumed;\n\t\tremaining = lengthResult.encoded;\n\t}\n\tconst hasDynamicChild = isDynamic(arrayItemParam);\n\tif (hasDynamicChild) {\n\t\t// known length but dynamic child, each child is actually head element with encoded offset\n\t\tfor (let i = 0; i < size; i += 1) {\n\t\t\tconst offsetResult = decodeNumber(\n\t\t\t\t{ type: 'uint32', name: '' },\n\t\t\t\tremaining.subarray(i * WORD_SIZE),\n\t\t\t);\n\t\t\tconsumed += offsetResult.consumed;\n\t\t\tconst decodedChildResult = decodeParamFromAbiParameter(\n\t\t\t\tarrayItemParam,\n\t\t\t\tremaining.subarray(Number(offsetResult.result)),\n\t\t\t);\n\t\t\tconsumed += decodedChildResult.consumed;\n\t\t\tresult.push(decodedChildResult.result);\n\t\t}\n\t\treturn {\n\t\t\tresult,\n\t\t\tencoded: remaining.subarray(consumed),\n\t\t\tconsumed,\n\t\t};\n\t}\n\n\tfor (let i = 0; i < size; i += 1) {\n\t\t// decode static params\n\t\tconst decodedChildResult = decodeParamFromAbiParameter(\n\t\t\tarrayItemParam,\n\t\t\tbytes.subarray(consumed),\n\t\t);\n\t\tconsumed += decodedChildResult.consumed;\n\t\tresult.push(decodedChildResult.result);\n\t}\n\treturn {\n\t\tresult,\n\t\tencoded: bytes.subarray(consumed),\n\t\tconsumed,\n\t};\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiParameter } from 'web3-types';\nimport { AbiError } from 'web3-errors';\nimport { EncoderResult, DecoderResult } from '../types.js';\nimport { decodeAddress, encodeAddress } from './address.js';\nimport { decodeBool, encodeBoolean } from './bool.js';\nimport { decodeBytes, encodeBytes } from './bytes.js';\nimport { decodeNumber, encodeNumber } from './number.js';\nimport { decodeString, encodeString } from './string.js';\n// eslint-disable-next-line import/no-cycle\nimport { decodeTuple, encodeTuple } from './tuple.js';\n// eslint-disable-next-line import/no-cycle\nimport { decodeArray, encodeArray } from './array.js';\n\nexport { encodeAddress, decodeAddress } from './address.js';\nexport { encodeBoolean, decodeBool } from './bool.js';\nexport { encodeBytes, decodeBytes } from './bytes.js';\nexport { encodeNumber, decodeNumber } from './number.js';\nexport { encodeString, decodeString } from './string.js';\n// eslint-disable-next-line import/no-cycle\nexport { encodeTuple, decodeTuple } from './tuple.js';\n// eslint-disable-next-line import/no-cycle\nexport { encodeArray, decodeArray } from './array.js';\n\nexport function encodeParamFromAbiParameter(param: AbiParameter, value: unknown): EncoderResult {\n\tif (param.type === 'string') {\n\t\treturn encodeString(param, value);\n\t}\n\tif (param.type === 'bool') {\n\t\treturn encodeBoolean(param, value);\n\t}\n\tif (param.type === 'address') {\n\t\treturn encodeAddress(param, value);\n\t}\n\tif (param.type === 'tuple') {\n\t\treturn encodeTuple(param, value);\n\t}\n\tif (param.type.endsWith(']')) {\n\t\treturn encodeArray(param, value);\n\t}\n\tif (param.type.startsWith('bytes')) {\n\t\treturn encodeBytes(param, value);\n\t}\n\tif (param.type.startsWith('uint') || param.type.startsWith('int')) {\n\t\treturn encodeNumber(param, value);\n\t}\n\tthrow new AbiError('Unsupported', {\n\t\tparam,\n\t\tvalue,\n\t});\n}\n\nexport function decodeParamFromAbiParameter(param: AbiParameter, bytes: Uint8Array): DecoderResult {\n\tif (param.type === 'string') {\n\t\treturn decodeString(param, bytes);\n\t}\n\tif (param.type === 'bool') {\n\t\treturn decodeBool(param, bytes);\n\t}\n\tif (param.type === 'address') {\n\t\treturn decodeAddress(param, bytes);\n\t}\n\tif (param.type === 'tuple') {\n\t\treturn decodeTuple(param, bytes);\n\t}\n\tif (param.type.endsWith(']')) {\n\t\treturn decodeArray(param, bytes);\n\t}\n\tif (param.type.startsWith('bytes')) {\n\t\treturn decodeBytes(param, bytes);\n\t}\n\tif (param.type.startsWith('uint') || param.type.startsWith('int')) {\n\t\treturn decodeNumber(param, bytes);\n\t}\n\tthrow new AbiError('Unsupported', {\n\t\tparam,\n\t\tbytes,\n\t});\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiParameter } from 'web3-types';\nimport { uint8ArrayConcat } from 'web3-utils';\nimport { DecoderResult, EncoderResult } from '../types.js';\n// eslint-disable-next-line import/no-cycle\nimport { decodeParamFromAbiParameter, encodeParamFromAbiParameter } from './index.js';\nimport { encodeDynamicParams } from './utils.js';\nimport { isDynamic } from '../utils.js';\nimport { decodeNumber } from './number.js';\n\nexport function encodeTuple(param: AbiParameter, input: unknown): EncoderResult {\n\tlet dynamic = false;\n\tif (!Array.isArray(input) && typeof input !== 'object') {\n\t\tthrow new AbiError('param must be either Array or Object', {\n\t\t\tparam,\n\t\t\tinput,\n\t\t});\n\t}\n\tconst narrowedInput = input as Array<unknown> | Record<string, unknown>;\n\tconst encoded: Array<EncoderResult> = [];\n\tfor (let i = 0; i < (param.components?.length ?? 0); i += 1) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\tconst paramComponent = param.components![i];\n\t\tlet result: EncoderResult;\n\t\tif (Array.isArray(narrowedInput)) {\n\t\t\tif (i >= narrowedInput.length) {\n\t\t\t\tthrow new AbiError('input param length missmatch', {\n\t\t\t\t\tparam,\n\t\t\t\t\tinput,\n\t\t\t\t});\n\t\t\t}\n\t\t\tresult = encodeParamFromAbiParameter(paramComponent, narrowedInput[i]);\n\t\t} else {\n\t\t\tconst paramInput = narrowedInput[paramComponent.name ?? ''];\n\t\t\t// eslint-disable-next-line no-null/no-null\n\t\t\tif (paramInput === undefined || paramInput === null) {\n\t\t\t\tthrow new AbiError('missing input defined in abi', {\n\t\t\t\t\tparam,\n\t\t\t\t\tinput,\n\t\t\t\t\tparamName: paramComponent.name,\n\t\t\t\t});\n\t\t\t}\n\t\t\tresult = encodeParamFromAbiParameter(paramComponent, paramInput);\n\t\t}\n\t\tif (result.dynamic) {\n\t\t\tdynamic = true;\n\t\t}\n\t\tencoded.push(result);\n\t}\n\n\tif (dynamic) {\n\t\treturn {\n\t\t\tdynamic: true,\n\t\t\tencoded: encodeDynamicParams(encoded),\n\t\t};\n\t}\n\treturn {\n\t\tdynamic: false,\n\t\tencoded: uint8ArrayConcat(...encoded.map(e => e.encoded)),\n\t};\n}\n\nexport function decodeTuple(\n\tparam: AbiParameter,\n\tbytes: Uint8Array,\n): DecoderResult<{ [key: string]: unknown; __length__: number }> {\n\tconst result: { [key: string]: unknown; __length__: number } = {\n\t\t__length__: 0,\n\t};\n\n\t// tracks how much static params consumed bytes\n\tlet consumed = 0;\n\n\tif (!param.components) {\n\t\treturn {\n\t\t\tresult,\n\t\t\tencoded: bytes,\n\t\t\tconsumed,\n\t\t};\n\t}\n\t// track how much dynamic params consumed bytes\n\tlet dynamicConsumed = 0;\n\tfor (const [index, childParam] of param.components.entries()) {\n\t\tlet decodedResult: DecoderResult;\n\t\tif (isDynamic(childParam)) {\n\t\t\t// if dynamic, we will have offset encoded\n\t\t\tconst offsetResult = decodeNumber(\n\t\t\t\t{ type: 'uint32', name: '' },\n\t\t\t\tbytes.subarray(consumed),\n\t\t\t);\n\t\t\t// offset counts from start of original byte sequence\n\t\t\tdecodedResult = decodeParamFromAbiParameter(\n\t\t\t\tchildParam,\n\t\t\t\tbytes.subarray(Number(offsetResult.result)),\n\t\t\t);\n\t\t\tconsumed += offsetResult.consumed;\n\t\t\tdynamicConsumed += decodedResult.consumed;\n\t\t} else {\n\t\t\t// static param, just decode\n\t\t\tdecodedResult = decodeParamFromAbiParameter(childParam, bytes.subarray(consumed));\n\t\t\tconsumed += decodedResult.consumed;\n\t\t}\n\t\tresult.__length__ += 1;\n\t\tresult[index] = decodedResult.result;\n\t\tif (childParam.name && childParam.name !== '') {\n\t\t\tresult[childParam.name] = decodedResult.result;\n\t\t}\n\t}\n\treturn {\n\t\tencoded: bytes.subarray(consumed + dynamicConsumed),\n\t\tresult,\n\t\tconsumed: consumed + dynamicConsumed,\n\t};\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiInput, HexString } from 'web3-types';\nimport { utils } from 'web3-validator';\nimport { decodeTuple } from './base/tuple.js';\nimport { toAbiParams } from './utils.js';\n\nexport function decodeParameters(\n\tabis: AbiInput[],\n\tbytes: HexString,\n\t_loose: boolean,\n): { [key: string]: unknown; __length__: number } {\n\tconst abiParams = toAbiParams(abis);\n\tconst bytesArray = utils.hexToUint8Array(bytes);\n\n\treturn decodeTuple({ type: 'tuple', name: '', components: abiParams }, bytesArray).result;\n}\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { AbiError } from 'web3-errors';\nimport { AbiInput, AbiParameter } from 'web3-types';\nimport { toHex } from 'web3-utils';\nimport { utils } from 'web3-validator';\nimport { encodeTuple } from './base/index.js';\nimport { toAbiParams } from './utils.js';\n\n/**\n * @param params - The params to infer the ABI from\n * @returns The inferred ABI\n * @example\n * ```\n * inferParamsAbi([1, -1, 'hello', '0x1234', ])\n * ```\n * > [{ type: 'int256' }, { type: 'uint256' }, { type: 'string' }, { type: 'bytes' }]\n * ```\n */\nfunction inferParamsAbi(params: unknown[]): ReadonlyArray<AbiParameter> {\n\tconst abi: AbiParameter[] = [];\n\tparams.forEach(param => {\n\t\tif (Array.isArray(param)) {\n\t\t\tconst inferredParams = inferParamsAbi(param);\n\t\t\tabi.push({\n\t\t\t\ttype: 'tuple',\n\t\t\t\tcomponents: inferredParams,\n\t\t\t\tname: '',\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t} as AbiParameter);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\tabi.push({ type: toHex(param as any, true) } as AbiParameter);\n\t\t}\n\t});\n\treturn abi;\n}\n\n/**\n * Encodes a parameter based on its type to its ABI representation.\n * @param abi - An array of {@link AbiInput}. See [Solidity's documentation](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html#json) for more details.\n * @param params - The actual parameters to encode.\n * @returns - The ABI encoded parameters\n * @example\n * ```ts\n * const res = web3.eth.abi.encodeParameters(\n *    [\"uint256\", \"string\"],\n *    [\"2345675643\", \"Hello!%\"]\n *  );\n *\n *  console.log(res);\n *  > 0x000000000000000000000000000000000000000000000000000000008bd02b7b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000748656c6c6f212500000000000000000000000000000000000000000000000000\n * ```\n */\nexport function encodeParameters(abi: ReadonlyArray<AbiInput>, params: unknown[]): string {\n\tif (abi?.length !== params.length) {\n\t\tthrow new AbiError('Invalid number of values received for given ABI', {\n\t\t\texpected: abi?.length,\n\t\t\treceived: params.length,\n\t\t});\n\t}\n\n\tconst abiParams = toAbiParams(abi);\n\treturn utils.uint8ArrayToHexString(\n\t\tencodeTuple({ type: 'tuple', name: '', components: abiParams }, params).encoded,\n\t);\n}\n\n/**\n * Infer a smart contract method parameter type and then encode this parameter.\n * @param params - The parameters to encode.\n * @returns - The ABI encoded parameters\n *\n * @remarks\n * This method is useful when you don't know the type of the parameters you want to encode. It will infer the type of the parameters and then encode them.\n * However, it is not recommended to use this method when you know the type of the parameters you want to encode. In this case, use the {@link encodeParameters} method instead.\n * The type inference is not perfect and can lead to unexpected results. Especially when you want to encode an array, uint that is not uint256 or bytes....\n * @example\n * ```ts\n * const res = web3.eth.abi.encodeParameters(\n *    [\"2345675643\", \"Hello!%\"]\n *  );\n *\n *  console.log(res);\n *  > 0x000000000000000000000000000000000000000000000000000000008bd02b7b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000748656c6c6f212500000000000000000000000000000000000000000000000000\n * ```\n */\nexport function inferTypesAndEncodeParameters(params: unknown[]): string {\n\ttry {\n\t\tconst abiParams = inferParamsAbi(params);\n\t\treturn utils.uint8ArrayToHexString(\n\t\t\tencodeTuple({ type: 'tuple', name: '', components: abiParams }, params).encoded,\n\t\t);\n\t} catch (e) {\n\t\t// throws If the inferred params type caused an error\n\t\tthrow new AbiError('Could not infer types from given params', {\n\t\t\tparams,\n\t\t});\n\t}\n}\n", "\uFEFF/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n *\n *  @module ABI\n */\n\nimport { AbiError } from 'web3-errors';\nimport { AbiInput, HexString } from 'web3-types';\nimport { decodeParameters as decodeParametersInternal } from '../coders/decode.js';\nimport { encodeParameters } from '../coders/encode.js';\n\nexport { encodeParameters, inferTypesAndEncodeParameters } from '../coders/encode.js';\n\n/**\n * Encodes a parameter based on its type to its ABI representation.\n * @param abi -  The type of the parameter. See the [Solidity documentation](https://docs.soliditylang.org/en/develop/types.html) for a list of types.\n * @param param - The actual parameter to encode.\n * @returns -  The ABI encoded parameter\n * @example\n * ```ts\n *  const res = web3.eth.abi.encodeParameter(\"uint256\", \"2345675643\");\n *  console.log(res);\n *  0x000000000000000000000000000000000000000000000000000000008bd02b7b\n *\n *  const res = web3.eth.abi.encodeParameter(\"uint\", \"2345675643\");\n *\n *  console.log(res);\n *  >0x000000000000000000000000000000000000000000000000000000008bd02b7b\n *\n *    const res = web3.eth.abi.encodeParameter(\"bytes32\", \"0xdf3234\");\n *\n *  console.log(res);\n *  >0xdf32340000000000000000000000000000000000000000000000000000000000\n *\n *   const res = web3.eth.abi.encodeParameter(\"bytes\", \"0xdf3234\");\n *\n *  console.log(res);\n *  > 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003df32340000000000000000000000000000000000000000000000000000000000\n *\n *   const res = web3.eth.abi.encodeParameter(\"bytes32[]\", [\"0xdf3234\", \"0xfdfd\"]);\n *\n *  console.log(res);\n *  > 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002df32340000000000000000000000000000000000000000000000000000000000fdfd000000000000000000000000000000000000000000000000000000000000\n *\n *  const res = web3.eth.abi.encodeParameter(\n *    {\n *      ParentStruct: {\n *        propertyOne: \"uint256\",\n *        propertyTwo: \"uint256\",\n *        childStruct: {\n *          propertyOne: \"uint256\",\n *          propertyTwo: \"uint256\",\n *        },\n *      },\n *    },\n *    {\n *      propertyOne: 42,\n *      propertyTwo: 56,\n *      childStruct: {\n *        propertyOne: 45,\n *        propertyTwo: 78,\n *      },\n *    }\n *  );\n *\n *  console.log(res);\n *  > 0x000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000002d000000000000000000000000000000000000000000000000000000000000004e\n * ```\n */\nexport const encodeParameter = (abi: AbiInput, param: unknown): string =>\n\tencodeParameters([abi], [param]);\n/**\n * Should be used to decode list of params\n */\nexport const decodeParametersWith = (\n\tabis: AbiInput[],\n\tbytes: HexString,\n\tloose: boolean,\n): { [key: string]: unknown; __length__: number } => {\n\ttry {\n\t\tif (abis.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n\t\t\tthrow new AbiError(\n\t\t\t\t\"Returned values aren't valid, did it run Out of Gas? \" +\n\t\t\t\t\t'You might also see this error if you are not using the ' +\n\t\t\t\t\t'correct ABI for the contract you are retrieving data from, ' +\n\t\t\t\t\t'requesting data from a block number that does not exist, ' +\n\t\t\t\t\t'or querying a node which is not fully synced.',\n\t\t\t);\n\t\t}\n\t\treturn decodeParametersInternal(abis, `0x${bytes.replace(/0x/i, '')}`, loose);\n\t} catch (err) {\n\t\tthrow new AbiError(`Parameter decoding error: ${(err as Error).message}`, {\n\t\t\tinternalErr: err,\n\t\t});\n\t}\n};\n\n/**\n * Should be used to decode list of params\n */\n/**\n * Decodes ABI encoded parameters to its JavaScript types.\n * @param abi -  An array of {@link AbiInput}. See the [Solidity documentation](https://docs.soliditylang.org/en/develop/types.html) for a list of types.\n * @param bytes - The ABI byte code to decode\n * @returns - The result object containing the decoded parameters.\n * @example\n * ```ts\n * let res = web3.eth.abi.decodeParameters(\n *    [\"string\", \"uint256\"],\n *    \"0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000\"\n *  );\n *  console.log(res);\n *  > { '0': 'Hello!%!', '1': 234n, __length__: 2 }\n *\n * let res = web3.eth.abi.decodeParameters(\n *    [\n *      {\n *        type: \"string\",\n *        name: \"myString\",\n *      },\n *      {\n *        type: \"uint256\",\n *        name: \"myNumber\",\n *      },\n *    ],\n *    \"0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000\"\n *  );\n * console.log(res);\n *  > {\n *  '0': 'Hello!%!',\n *  '1': 234n,\n *  __length__: 2,\n *  myString: 'Hello!%!',\n *  myNumber: 234n\n * }\n *\n * const res = web3.eth.abi.decodeParameters(\n *    [\n *      \"uint8[]\",\n *      {\n *        ParentStruct: {\n *          propertyOne: \"uint256\",\n *          propertyTwo: \"uint256\",\n *          childStruct: {\n *            propertyOne: \"uint256\",\n *            propertyTwo: \"uint256\",\n *          },\n *        },\n *      },\n *    ],\n *    \"0x00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000002d000000000000000000000000000000000000000000000000000000000000004e0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000018\"\n *  );\n *  console.log(res);\n *  >\n *  '0': [ 42n, 24n ],\n *  '1': {\n *    '0': 42n,\n *    '1': 56n,\n *    '2': {\n *      '0': 45n,\n *      '1': 78n,\n *      __length__: 2,\n *      propertyOne: 45n,\n *      propertyTwo: 78n\n *    },\n *    __length__: 3,\n *    propertyOne: 42n,\n *    propertyTwo: 56n,\n *    childStruct: {\n *      '0': 45n,\n *      '1': 78n,\n *      __length__: 2,\n *      propertyOne: 45n,\n *      propertyTwo: 78n\n *    }\n *  },\n *  __length__: 2,\n *  ParentStruct: {\n *    '0': 42n,\n *    '1': 56n,\n *    '2': {\n *      '0': 45n,\n *      '1': 78n,\n *      __length__: 2,\n *      propertyOne: 45n,\n *      propertyTwo: 78n\n *    },\n *    __length__: 3,\n *    propertyOne: 42n,\n *    propertyTwo: 56n,\n *    childStruct: {\n *      '0': 45n,\n *      '1': 78n,\n *      __length__: 2,\n *      propertyOne: 45n,\n *      propertyTwo: 78n\n *    }\n *  }\n *}\n * ```\n */\nexport const decodeParameters = (\n\tabi: AbiInput[],\n\tbytes: HexString,\n): { [key: string]: unknown; __length__: number } => decodeParametersWith(abi, bytes, false);\n\n/**\n * Should be used to decode bytes to plain param\n */\n/**\n * Decodes an ABI encoded parameter to its JavaScript type.\n * @param abi -  The type of the parameter. See the [Solidity documentation](https://docs.soliditylang.org/en/develop/types.html) for a list of types.\n * @param bytes - The ABI byte code to decode\n * @returns - The decoded parameter\n * @example\n * ```ts\n *   const res = web3.eth.abi.decodeParameter(\n *    \"uint256\",\n *    \"0x0000000000000000000000000000000000000000000000000000000000000010\"\n *  );\n *  console.log(res);\n * > 16n\n *\n *  const res = web3.eth.abi.decodeParameter(\n *    \"string\",\n *    \"0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000\"\n *  );\n *\n *  console.log(res);\n *  > Hello!%!\n *\n *  const res = web3.eth.abi.decodeParameter(\n *    {\n *      ParentStruct: {\n *        propertyOne: \"uint256\",\n *        propertyTwo: \"uint256\",\n *        childStruct: {\n *          propertyOne: \"uint256\",\n *          propertyTwo: \"uint256\",\n *        },\n *      },\n *    },\n *    \"0x000000000000000000000000000000000000000000000000000000000000002a0000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000002d000000000000000000000000000000000000000000000000000000000000004e\"\n *  );\n *\n *  console.log(res);\n *   {\n *  '0': 42n,\n *  '1': 56n,\n *  '2': {\n *    '0': 45n,\n *    '1': 78n,\n *    __length__: 2,\n *    propertyOne: 45n,\n *    propertyTwo: 78n\n *  },\n *  __length__: 3,\n *  propertyOne: 42n,\n *  propertyTwo: 56n,\n *  childStruct: {\n *    '0': 45n,\n *    '1': 78n,\n *    __length__: 2,\n *    propertyOne: 45n,\n *    propertyTwo: 78n\n *  }\n *}\n * ```\n */\nexport const decodeParameter = (abi: AbiInput, bytes: HexString): unknown =>\n\tdecodeParameters([abi], bytes)['0'];\n", "\uFEFF/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n *\n *  @module ABI\n */\nimport { AbiError } from 'web3-errors';\nimport { sha3Raw } from 'web3-utils';\nimport { AbiFunctionFragment } from 'web3-types';\nimport { isAbiFunctionFragment, jsonInterfaceMethodToString } from '../utils.js';\nimport { encodeParameters } from './parameters_api.js';\n\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n * The JSON interface spec documentation https://docs.soliditylang.org/en/latest/abi-spec.html#json\n * @param functionName - The function name to encode or the `JSON interface` object of the function.\n * If the passed parameter is a string, it has to be in the form of `functionName(param1Type,param2Type,...)`. eg: myFunction(uint256,uint32[],bytes10,bytes)\n * @returns - The ABI signature of the function.\n * @example\n * ```ts\n * const signature = web3.eth.abi.encodeFunctionSignature({\n *   name: \"myMethod\",\n *   type: \"function\",\n *   inputs: [\n *     {\n *       type: \"uint256\",\n *       name: \"myNumber\",\n *     },\n *     {\n *       type: \"string\",\n *       name: \"myString\",\n *     },\n *   ],\n * });\n * console.log(signature);\n * > 0x24ee0097\n *\n * const signature = web3.eth.abi.encodeFunctionSignature('myMethod(uint256,string)')\n * console.log(signature);\n * > 0x24ee0097\n *\n * const signature = web3.eth.abi.encodeFunctionSignature('safeTransferFrom(address,address,uint256,bytes)');\n * console.log(signature);\n * > 0xb88d4fde\n * ```\n */\nexport const encodeFunctionSignature = (functionName: string | AbiFunctionFragment): string => {\n\tif (typeof functionName !== 'string' && !isAbiFunctionFragment(functionName)) {\n\t\tthrow new AbiError('Invalid parameter value in encodeFunctionSignature');\n\t}\n\n\tlet name: string;\n\n\tif (functionName && (typeof functionName === 'function' || typeof functionName === 'object')) {\n\t\tname = jsonInterfaceMethodToString(functionName);\n\t} else {\n\t\tname = functionName;\n\t}\n\n\treturn sha3Raw(name).slice(0, 10);\n};\n\n/**\n * Encodes a function call using its `JSON interface` object and given parameters.\n * The JSON interface spec documentation https://docs.soliditylang.org/en/latest/abi-spec.html#json\n * @param jsonInterface - The `JSON interface` object of the function.\n * @param params - The parameters to encode\n * @returns - The ABI encoded function call, which, means the function signature and the parameters passed.\n * @example\n * ```ts\n * const sig = web3.eth.abi.encodeFunctionCall(\n *   {\n *     name: \"myMethod\",\n *     type: \"function\",\n *     inputs: [\n *       {\n *         type: \"uint256\",\n *         name: \"myNumber\",\n *       },\n *       {\n *         type: \"string\",\n *         name: \"myString\",\n *       },\n *     ],\n *   },\n *   [\"2345675643\", \"Hello!%\"]\n * );\n * console.log(sig);\n * > 0x24ee0097000000000000000000000000000000000000000000000000000000008bd02b7b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000748656c6c6f212500000000000000000000000000000000000000000000000000\n *\n *\n *\n * const sig = web3.eth.abi.encodeFunctionCall(\n *   {\n *     inputs: [\n *       {\n *         name: \"account\",\n *         type: \"address\",\n *       },\n *     ],\n *     name: \"balanceOf\",\n *     outputs: [\n *       {\n *         name: \"\",\n *         type: \"uint256\",\n *       },\n *     ],\n *     stateMutability: \"view\",\n *     type: \"function\",\n *   },\n *   [\"0x1234567890123456789012345678901234567890\"]\n * );\n *\n * console.log(sig);\n * > 0x70a082310000000000000000000000001234567890123456789012345678901234567890\n * ```\n */\nexport const encodeFunctionCall = (\n\tjsonInterface: AbiFunctionFragment,\n\tparams: unknown[],\n): string => {\n\tif (!isAbiFunctionFragment(jsonInterface)) {\n\t\tthrow new AbiError('Invalid parameter value in encodeFunctionCall');\n\t}\n\n\treturn `${encodeFunctionSignature(jsonInterface)}${encodeParameters(\n\t\tjsonInterface.inputs ?? [],\n\t\tparams ?? [],\n\t).replace('0x', '')}`;\n};\n", "\uFEFF/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n *\n *  @module ABI\n */\n\nimport { HexString, AbiParameter, DecodedParams } from 'web3-types';\nimport { decodeParameter, decodeParametersWith } from './parameters_api.js';\n\nconst STATIC_TYPES = ['bool', 'string', 'int', 'uint', 'address', 'fixed', 'ufixed'];\n\nconst _decodeParameter = (inputType: string, clonedTopic: string) =>\n\tinputType === 'string' ? clonedTopic : decodeParameter(inputType, clonedTopic);\n\n/**\n * Decodes ABI-encoded log data and indexed topic data.\n * @param inputs - A {@link AbiParameter} input array. See the [Solidity documentation](https://docs.soliditylang.org/en/develop/types.html) for a list of types.\n * @param data - The ABI byte code in the `data` field of a log.\n * @param topics - An array with the index parameter topics of the log, without the topic[0] if its a non-anonymous event, otherwise with topic[0]\n * @returns - The result object containing the decoded parameters.\n *\n * @example\n * ```ts\n * let res = web3.eth.abi.decodeLog(\n *    [\n *      {\n *        type: \"string\",\n *        name: \"myString\",\n *      },\n *      {\n *        type: \"uint256\",\n *        name: \"myNumber\",\n *        indexed: true,\n *      },\n *      {\n *        type: \"uint8\",\n *        name: \"mySmallNumber\",\n *        indexed: true,\n *      },\n *    ],\n *    \"0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000748656c6c6f252100000000000000000000000000000000000000000000000000\",\n *    [\n *      \"0x000000000000000000000000000000000000000000000000000000000000f310\",\n *      \"0x0000000000000000000000000000000000000000000000000000000000000010\",\n *    ]\n *  );\n * > {\n *  '0': 'Hello%!',\n *  '1': 62224n,\n *  '2': 16n,\n *  __length__: 3,\n *  myString: 'Hello%!',\n *  myNumber: 62224n,\n *  mySmallNumber: 16n\n * }\n * ```\n */\nexport const decodeLog = <ReturnType extends DecodedParams>(\n\tinputs: Array<AbiParameter>,\n\tdata: HexString,\n\ttopics: string | string[],\n) => {\n\tconst clonedTopics = Array.isArray(topics) ? topics : [topics];\n\n\tconst indexedInputs: Record<number, AbiParameter> = {};\n\tconst nonIndexedInputs: Record<number, AbiParameter> = {};\n\n\tfor (const [i, input] of inputs.entries()) {\n\t\tif (input.indexed) {\n\t\t\tindexedInputs[i] = input;\n\t\t} else {\n\t\t\tnonIndexedInputs[i] = input;\n\t\t}\n\t}\n\n\tconst decodedNonIndexedInputs: DecodedParams = data\n\t\t? decodeParametersWith(Object.values(nonIndexedInputs), data, true)\n\t\t: { __length__: 0 };\n\n\t// If topics are more than indexed inputs, that means first topic is the event signature\n\tconst offset = clonedTopics.length - Object.keys(indexedInputs).length;\n\n\tconst decodedIndexedInputs = Object.values(indexedInputs).map((input, index) =>\n\t\tSTATIC_TYPES.some(s => input.type.startsWith(s))\n\t\t\t? _decodeParameter(input.type, clonedTopics[index + offset])\n\t\t\t: clonedTopics[index + offset],\n\t);\n\n\tconst returnValues: DecodedParams = { __length__: 0 };\n\n\tlet indexedCounter = 0;\n\tlet nonIndexedCounter = 0;\n\n\tfor (const [i, res] of inputs.entries()) {\n\t\treturnValues[i] = res.type === 'string' ? '' : undefined;\n\n\t\tif (indexedInputs[i]) {\n\t\t\treturnValues[i] = decodedIndexedInputs[indexedCounter];\n\t\t\tindexedCounter += 1;\n\t\t}\n\n\t\tif (nonIndexedInputs[i]) {\n\t\t\treturnValues[i] = decodedNonIndexedInputs[String(nonIndexedCounter)];\n\t\t\tnonIndexedCounter += 1;\n\t\t}\n\n\t\tif (res.name) {\n\t\t\treturnValues[res.name] = returnValues[i];\n\t\t}\n\n\t\treturnValues.__length__ += 1;\n\t}\n\n\treturn returnValues as ReturnType;\n};\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { Eip838ExecutionError } from 'web3-errors';\nimport { AbiErrorFragment } from 'web3-types';\n\nimport { encodeErrorSignature } from './api/errors_api.js';\nimport { decodeParameters } from './api/parameters_api.js';\nimport { jsonInterfaceMethodToString } from './utils.js';\n\nexport const decodeContractErrorData = (\n\terrorsAbi: AbiErrorFragment[],\n\terror: Eip838ExecutionError,\n) => {\n\tif (error?.data) {\n\t\tlet errorName: string | undefined;\n\t\tlet errorSignature: string | undefined;\n\t\tlet errorArgs: { [K in string]: unknown } | undefined;\n\t\ttry {\n\t\t\tconst errorSha = error.data.slice(0, 10);\n\t\t\tconst errorAbi = errorsAbi.find(abi => encodeErrorSignature(abi).startsWith(errorSha));\n\n\t\t\tif (errorAbi?.inputs) {\n\t\t\t\terrorName = errorAbi.name;\n\t\t\t\terrorSignature = jsonInterfaceMethodToString(errorAbi);\n\t\t\t\t// decode abi.inputs according to EIP-838\n\t\t\t\terrorArgs = decodeParameters([...errorAbi.inputs], error.data.substring(10));\n\t\t\t} else if (error.data.startsWith('0x08c379a0')) {\n\t\t\t\t// If ABI was not provided, check for the 2 famous errors: 'Error(string)' or 'Panic(uint256)'\n\n\t\t\t\terrorName = 'Error';\n\t\t\t\terrorSignature = 'Error(string)';\n\t\t\t\t// decode abi.inputs according to EIP-838\n\t\t\t\terrorArgs = decodeParameters(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'message',\n\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\terror.data.substring(10),\n\t\t\t\t);\n\t\t\t} else if (error.data.startsWith('0x4e487b71')) {\n\t\t\t\terrorName = 'Panic';\n\t\t\t\terrorSignature = 'Panic(uint256)';\n\t\t\t\t// decode abi.inputs according to EIP-838\n\t\t\t\terrorArgs = decodeParameters(\n\t\t\t\t\t[\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: 'code',\n\t\t\t\t\t\t\ttype: 'uint256',\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\terror.data.substring(10),\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconsole.error('No matching error abi found for error data', error.data);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t}\n\t\tif (errorName) {\n\t\t\terror.setDecodedProperties(errorName, errorSignature, errorArgs);\n\t\t}\n\t}\n};\n", "/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * The web3.eth.abi functions let you encode and decode parameters to ABI (Application Binary Interface) for function calls to the EVM (Ethereum Virtual Machine).\n *\n *  For using Web3 ABI functions, first install Web3 package using `npm i web3` or `yarn add web3`.\n * After that, Web3 ABI functions will be available.\n * ```ts\n * import { Web3 } from 'web3';\n *\n * const web3 = new Web3();\n * const encoded = web3.eth.abi.encodeFunctionSignature({\n *     name: 'myMethod',\n *     type: 'function',\n *     inputs: [{\n *         type: 'uint256',\n *         name: 'myNumber'\n *     },{\n *         type: 'string',\n *         name: 'myString'\n *     }]\n * });\n *\n * ```\n *\n * For using individual package install `web3-eth-abi` package using `npm i web3-eth-abi` or `yarn add web3-eth-abi` and only import required functions.\n * This is more efficient approach for building lightweight applications.\n * ```ts\n * import { encodeFunctionSignature } from 'web3-eth-abi';\n *\n * const encoded = encodeFunctionSignature({\n *     name: 'myMethod',\n *     type: 'function',\n *     inputs: [{\n *         type: 'uint256',\n *         name: 'myNumber'\n *     },{\n *         type: 'string',\n *         name: 'myString'\n *     }]\n * });\n *\n * ```\n *\n *  @module ABI\n */\n\n// This code was taken from: https://github.com/Mrtenz/eip-712/tree/master\n\nimport { Eip712TypedData } from 'web3-types';\nimport { isNullish, keccak256 } from 'web3-utils';\nimport { AbiError } from 'web3-errors';\nimport { encodeParameters } from './coders/encode.js';\n\nconst TYPE_REGEX = /^\\w+/;\nconst ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n */\nconst getDependencies = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdependencies: string[] = [],\n): string[] => {\n\tconst match = type.match(TYPE_REGEX)!;\n\tconst actualType = match[0];\n\tif (dependencies.includes(actualType)) {\n\t\treturn dependencies;\n\t}\n\n\tif (!typedData.types[actualType]) {\n\t\treturn dependencies;\n\t}\n\n\treturn [\n\t\tactualType,\n\t\t...typedData.types[actualType].reduce<string[]>(\n\t\t\t(previous, _type) => [\n\t\t\t\t...previous,\n\t\t\t\t...getDependencies(typedData, _type.type, previous).filter(\n\t\t\t\t\tdependency => !previous.includes(dependency),\n\t\t\t\t),\n\t\t\t],\n\t\t\t[],\n\t\t),\n\t];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Options} [options]\n * @return {string}\n */\nconst encodeType = (typedData: Eip712TypedData, type: string): string => {\n\tconst [primary, ...dependencies] = getDependencies(typedData, type);\n\t// eslint-disable-next-line @typescript-eslint/require-array-sort-compare\n\tconst types = [primary, ...dependencies.sort()];\n\n\treturn types\n\t\t.map(\n\t\t\tdependency =>\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n\t\t\t\t`${dependency}(${typedData.types[dependency].map(\n\t\t\t\t\t_type => `${_type.type} ${_type.name}`,\n\t\t\t\t)})`,\n\t\t)\n\t\t.join('');\n};\n\n/**\n * Get a type string as hash.\n */\nconst getTypeHash = (typedData: Eip712TypedData, type: string) =>\n\tkeccak256(encodeType(typedData, type));\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n */\nconst getStructHash = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n\t// eslint-disable-next-line  no-use-before-define\n): string => keccak256(encodeData(typedData, type, data));\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n */\nexport const getMessage = (typedData: Eip712TypedData, hash?: boolean): string => {\n\tconst EIP_191_PREFIX = '1901';\n\tconst message = `0x${EIP_191_PREFIX}${getStructHash(\n\t\ttypedData,\n\t\t'EIP712Domain',\n\t\ttypedData.domain as Record<string, unknown>,\n\t).substring(2)}${getStructHash(typedData, typedData.primaryType, typedData.message).substring(\n\t\t2,\n\t)}`;\n\n\tif (hash) {\n\t\treturn keccak256(message);\n\t}\n\n\treturn message;\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n */\nconst encodeValue = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: unknown,\n): [string, string | Uint8Array | number] => {\n\tconst match = type.match(ARRAY_REGEX);\n\n\t// Checks for array types\n\tif (match) {\n\t\tconst arrayType = match[1];\n\t\tconst length = Number(match[2]) || undefined;\n\n\t\tif (!Array.isArray(data)) {\n\t\t\tthrow new AbiError('Cannot encode data: value is not of array type', {\n\t\t\t\tdata,\n\t\t\t});\n\t\t}\n\n\t\tif (length && data.length !== length) {\n\t\t\tthrow new AbiError(\n\t\t\t\t`Cannot encode data: expected length of ${length}, but got ${data.length}`,\n\t\t\t\t{\n\t\t\t\t\tdata,\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tconst encodedData = data.map(item => encodeValue(typedData, arrayType, item));\n\t\tconst types = encodedData.map(item => item[0]);\n\t\tconst values = encodedData.map(item => item[1]);\n\n\t\treturn ['bytes32', keccak256(encodeParameters(types, values))];\n\t}\n\n\tif (typedData.types[type]) {\n\t\treturn ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>)];\n\t}\n\n\t// Strings and arbitrary byte arrays are hashed to bytes32\n\tif (type === 'string') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\tif (type === 'bytes') {\n\t\treturn ['bytes32', keccak256(data as string)];\n\t}\n\n\treturn [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n */\nconst encodeData = (\n\ttypedData: Eip712TypedData,\n\ttype: string,\n\tdata: Record<string, unknown>,\n): string => {\n\tconst [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n\t\t([_types, _values], field) => {\n\t\t\tif (isNullish(data[field.name]) || isNullish(field.type)) {\n\t\t\t\tthrow new AbiError(`Cannot encode data: missing data for '${field.name}'`, {\n\t\t\t\t\tdata,\n\t\t\t\t\tfield,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst value = data[field.name];\n\t\t\tconst [_type, encodedValue] = encodeValue(typedData, field.type, value);\n\n\t\t\treturn [\n\t\t\t\t[..._types, _type],\n\t\t\t\t[..._values, encodedValue],\n\t\t\t];\n\t\t},\n\t\t[['bytes32'], [getTypeHash(typedData, type)]],\n\t);\n\n\treturn encodeParameters(types, values);\n};\n"],
  "mappings": "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",
  "names": ["name", "name", "encoded", "decodeParameters", "name", "decodeParameters"]
}
