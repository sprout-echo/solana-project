import {
  AbiError,
  InvalidBooleanError,
  bytesToHex,
  bytesToUint8Array,
  hexToUtf8,
  isAddress,
  isBytes,
  isNullish,
  isUint8Array,
  keccak256Wrapper,
  leftPad,
  padLeft,
  rightPad,
  sha3Raw,
  toBigInt,
  toBool,
  toChecksumAddress,
  toHex,
  uint8ArrayConcat,
  utf8ToBytes,
  utils_exports
} from "./chunk-UBTYZQ5H.js";
import "./chunk-TRNC6ORP.js";
import "./chunk-LK32TJAX.js";

// node_modules/web3-eth-abi/lib/esm/utils.js
var isAbiFragment = (item) => !isNullish(item) && typeof item === "object" && !isNullish(item.type) && ["function", "event", "constructor", "error"].includes(item.type);
var isAbiErrorFragment = (item) => !isNullish(item) && typeof item === "object" && !isNullish(item.type) && item.type === "error";
var isAbiEventFragment = (item) => !isNullish(item) && typeof item === "object" && !isNullish(item.type) && item.type === "event";
var isAbiFunctionFragment = (item) => !isNullish(item) && typeof item === "object" && !isNullish(item.type) && item.type === "function";
var isAbiConstructorFragment = (item) => !isNullish(item) && typeof item === "object" && !isNullish(item.type) && item.type === "constructor";
var isSimplifiedStructFormat = (type) => typeof type === "object" && typeof type.components === "undefined" && typeof type.name === "undefined";
var mapStructNameAndType = (structName) => structName.includes("[]") ? { type: "tuple[]", name: structName.slice(0, -2) } : { type: "tuple", name: structName };
var mapStructToCoderFormat = (struct) => {
  const components = [];
  for (const key of Object.keys(struct)) {
    const item = struct[key];
    if (typeof item === "object") {
      components.push(Object.assign(Object.assign({}, mapStructNameAndType(key)), { components: mapStructToCoderFormat(item) }));
    } else {
      components.push({
        name: key,
        type: struct[key]
      });
    }
  }
  return components;
};
var mapTypes = (types) => {
  const mappedTypes = [];
  for (const type of types) {
    let modifiedType = type;
    if (typeof type === "object") {
      modifiedType = Object.assign({}, type);
    }
    if (typeof type === "object" && type.type === "function") {
      modifiedType = Object.assign(Object.assign({}, type), { type: "bytes24" });
    }
    if (isSimplifiedStructFormat(modifiedType)) {
      const structName = Object.keys(modifiedType)[0];
      mappedTypes.push(Object.assign(Object.assign({}, mapStructNameAndType(structName)), { components: mapStructToCoderFormat(modifiedType[structName]) }));
    } else {
      mappedTypes.push(modifiedType);
    }
  }
  return mappedTypes;
};
var isOddHexstring = (param) => typeof param === "string" && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;
var formatOddHexstrings = (param) => isOddHexstring(param) ? `0x0${param.substring(2)}` : param;
var paramTypeBytes = /^bytes([0-9]*)$/;
var paramTypeBytesArray = /^bytes([0-9]*)\[\]$/;
var paramTypeNumber = /^(u?int)([0-9]*)$/;
var paramTypeNumberArray = /^(u?int)([0-9]*)\[\]$/;
var formatParam = (type, _param) => {
  const param = typeof _param === "object" && !Array.isArray(_param) ? Object.assign({}, _param) : _param;
  if (param instanceof BigInt || typeof param === "bigint") {
    return param.toString(10);
  }
  if (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {
    const paramClone = [...param];
    return paramClone.map((p) => formatParam(type.replace("[]", ""), p));
  }
  let match = paramTypeNumber.exec(type);
  if (match) {
    const size = parseInt(match[2] ? match[2] : "256", 10);
    if (size / 8 < param.length) {
      return leftPad(param, size);
    }
  }
  match = paramTypeBytes.exec(type);
  if (match) {
    const hexParam = isUint8Array(param) ? toHex(param) : param;
    const size = parseInt(match[1], 10);
    if (size) {
      let maxSize = size * 2;
      if (param.startsWith("0x")) {
        maxSize += 2;
      }
      const paddedParam = hexParam.length < maxSize ? rightPad(param, size * 2) : hexParam;
      return formatOddHexstrings(paddedParam);
    }
    return formatOddHexstrings(hexParam);
  }
  return param;
};
var flattenTypes = (includeTuple, puts) => {
  const types = [];
  puts.forEach((param) => {
    if (typeof param.components === "object") {
      if (!param.type.startsWith("tuple")) {
        throw new AbiError(`Invalid value given "${param.type}". Error: components found but type is not tuple.`);
      }
      const arrayBracket = param.type.indexOf("[");
      const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : "";
      const result = flattenTypes(includeTuple, param.components);
      if (Array.isArray(result) && includeTuple) {
        types.push(`tuple(${result.join(",")})${suffix}`);
      } else if (!includeTuple) {
        types.push(`(${result.join(",")})${suffix}`);
      } else {
        types.push(`(${result.join()})`);
      }
    } else {
      types.push(param.type);
    }
  });
  return types;
};
var jsonInterfaceMethodToString = (json) => {
  var _a, _b, _c, _d;
  if (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {
    if ((_a = json.name) === null || _a === void 0 ? void 0 : _a.includes("(")) {
      return json.name;
    }
    return `${(_b = json.name) !== null && _b !== void 0 ? _b : ""}(${flattenTypes(false, (_c = json.inputs) !== null && _c !== void 0 ? _c : []).join(",")})`;
  }
  return `(${flattenTypes(false, (_d = json.inputs) !== null && _d !== void 0 ? _d : []).join(",")})`;
};

// node_modules/web3-eth-abi/lib/esm/api/errors_api.js
var encodeErrorSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiErrorFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeErrorSignature");
  }
  let name2;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name2 = jsonInterfaceMethodToString(functionName);
  } else {
    name2 = functionName;
  }
  return sha3Raw(name2);
};

// node_modules/web3-eth-abi/lib/esm/api/events_api.js
var encodeEventSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiEventFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeEventSignature");
  }
  let name2;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name2 = jsonInterfaceMethodToString(functionName);
  } else {
    name2 = functionName;
  }
  return sha3Raw(name2);
};

// node_modules/abitype/dist/chunk-WP7KDV47.mjs
function execTyped(regex, string) {
  const match = regex.exec(string);
  return match == null ? void 0 : match.groups;
}
var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var isTupleRegex = /^\(.+?\).*?$/;

// node_modules/abitype/dist/chunk-NHABU752.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/abitype/dist/index.mjs
var name = "abitype";
var version = "0.7.1";
var BaseError = class extends Error {
  constructor(shortMessage, args = {}) {
    var _a;
    const details = args.cause instanceof BaseError ? args.cause.details : ((_a = args.cause) == null ? void 0 : _a.message) ? args.cause.message : args.details;
    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    const message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${name}@${version}`
    ].join("\n");
    super(message);
    __publicField(this, "details");
    __publicField(this, "docsPath");
    __publicField(this, "metaMessages");
    __publicField(this, "shortMessage");
    __publicField(this, "name", "AbiTypeError");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
};
var structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
  return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
  return execTyped(
    structSignatureRegex,
    signature
  );
}
var modifiers = /* @__PURE__ */ new Set([
  "memory",
  "indexed",
  "storage",
  "calldata"
]);
var functionModifiers = /* @__PURE__ */ new Set([
  "calldata",
  "memory",
  "storage"
]);
function getParameterCacheKey(param, type) {
  if (type)
    return `${type}:${param}`;
  return param;
}
var parameterCache = /* @__PURE__ */ new Map([
  // Unnamed
  ["address", { type: "address" }],
  ["bool", { type: "bool" }],
  ["bytes", { type: "bytes" }],
  ["bytes32", { type: "bytes32" }],
  ["int", { type: "int256" }],
  ["int256", { type: "int256" }],
  ["string", { type: "string" }],
  ["uint", { type: "uint256" }],
  ["uint8", { type: "uint8" }],
  ["uint16", { type: "uint16" }],
  ["uint24", { type: "uint24" }],
  ["uint32", { type: "uint32" }],
  ["uint64", { type: "uint64" }],
  ["uint96", { type: "uint96" }],
  ["uint112", { type: "uint112" }],
  ["uint160", { type: "uint160" }],
  ["uint192", { type: "uint192" }],
  ["uint256", { type: "uint256" }],
  // Named
  ["address owner", { type: "address", name: "owner" }],
  ["address to", { type: "address", name: "to" }],
  ["bool approved", { type: "bool", name: "approved" }],
  ["bytes _data", { type: "bytes", name: "_data" }],
  ["bytes data", { type: "bytes", name: "data" }],
  ["bytes signature", { type: "bytes", name: "signature" }],
  ["bytes32 hash", { type: "bytes32", name: "hash" }],
  ["bytes32 r", { type: "bytes32", name: "r" }],
  ["bytes32 root", { type: "bytes32", name: "root" }],
  ["bytes32 s", { type: "bytes32", name: "s" }],
  ["string name", { type: "string", name: "name" }],
  ["string symbol", { type: "string", name: "symbol" }],
  ["string tokenURI", { type: "string", name: "tokenURI" }],
  ["uint tokenId", { type: "uint256", name: "tokenId" }],
  ["uint8 v", { type: "uint8", name: "v" }],
  ["uint256 balance", { type: "uint256", name: "balance" }],
  ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
  ["uint256 value", { type: "uint256", name: "value" }],
  // Indexed
  [
    "event:address indexed from",
    { type: "address", name: "from", indexed: true }
  ],
  ["event:address indexed to", { type: "address", name: "to", indexed: true }],
  [
    "event:uint indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ],
  [
    "event:uint256 indexed tokenId",
    { type: "uint256", name: "tokenId", indexed: true }
  ]
]);
var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
var dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
  var _a, _b;
  const parameterCacheKey = getParameterCacheKey(param, options == null ? void 0 : options.type);
  if (parameterCache.has(parameterCacheKey))
    return parameterCache.get(parameterCacheKey);
  const isTuple = isTupleRegex.test(param);
  const match = execTyped(
    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,
    param
  );
  if (!match)
    throw new BaseError("Invalid ABI parameter.", {
      details: param
    });
  if (match.name && isSolidityKeyword(match.name))
    throw new BaseError("Invalid ABI parameter.", {
      details: param,
      metaMessages: [
        `"${match.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
      ]
    });
  const name2 = match.name ? { name: match.name } : {};
  const indexed = match.modifier === "indexed" ? { indexed: true } : {};
  const structs = (options == null ? void 0 : options.structs) ?? {};
  let type;
  let components = {};
  if (isTuple) {
    type = "tuple";
    const params = splitParameters(match.type);
    const components_ = [];
    const length = params.length;
    for (let i = 0; i < length; i++) {
      components_.push(parseAbiParameter(params[i], { structs }));
    }
    components = { components: components_ };
  } else if (match.type in structs) {
    type = "tuple";
    components = { components: structs[match.type] };
  } else if (dynamicIntegerRegex.test(match.type)) {
    type = `${match.type}256`;
  } else {
    type = match.type;
    if (!((options == null ? void 0 : options.type) === "struct") && !isSolidityType(type))
      throw new BaseError("Unknown type.", {
        metaMessages: [`Type "${type}" is not a valid ABI type.`]
      });
  }
  if (match.modifier) {
    if (!((_b = (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.has) == null ? void 0 : _b.call(_a, match.modifier)))
      throw new BaseError("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${match.modifier}" not allowed${(options == null ? void 0 : options.type) ? ` in "${options.type}" type` : ""}.`
        ]
      });
    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
      throw new BaseError("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `Modifier "${match.modifier}" not allowed${(options == null ? void 0 : options.type) ? ` in "${options.type}" type` : ""}.`,
          `Data location can only be specified for array, struct, or mapping types, but "${match.modifier}" was given.`
        ]
      });
  }
  const abiParameter = {
    type: `${type}${match.array ?? ""}`,
    ...name2,
    ...indexed,
    ...components
  };
  parameterCache.set(parameterCacheKey, abiParameter);
  return abiParameter;
}
function splitParameters(params, result = [], current = "", depth = 0) {
  if (params === "") {
    if (current === "")
      return result;
    if (depth !== 0)
      throw new BaseError("Unbalanced parentheses.", {
        metaMessages: [
          `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
        ],
        details: `Depth "${depth}"`
      });
    return [...result, current.trim()];
  }
  const length = params.length;
  for (let i = 0; i < length; i++) {
    const char = params[i];
    const tail = params.slice(i + 1);
    switch (char) {
      case ",":
        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
      case "(":
        return splitParameters(tail, result, `${current}${char}`, depth + 1);
      case ")":
        return splitParameters(tail, result, `${current}${char}`, depth - 1);
      default:
        return splitParameters(tail, result, `${current}${char}`, depth);
    }
  }
  return [];
}
function isSolidityType(type) {
  return type === "address" || type === "bool" || type === "function" || type === "string" || bytesRegex.test(type) || integerRegex.test(type);
}
var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name2) {
  return name2 === "address" || name2 === "bool" || name2 === "function" || name2 === "string" || name2 === "tuple" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);
}
function isValidDataLocation(type, isArray) {
  return isArray || type === "bytes" || type === "string" || type === "tuple";
}
function parseStructs(signatures) {
  const shallowStructs = {};
  const signaturesLength = signatures.length;
  for (let i = 0; i < signaturesLength; i++) {
    const signature = signatures[i];
    if (!isStructSignature(signature))
      continue;
    const match = execStructSignature(signature);
    if (!match)
      throw new BaseError("Invalid struct signature.", {
        details: signature
      });
    const properties = match.properties.split(";");
    const components = [];
    const propertiesLength = properties.length;
    for (let k = 0; k < propertiesLength; k++) {
      const property = properties[k];
      const trimmed = property.trim();
      if (!trimmed)
        continue;
      const abiParameter = parseAbiParameter(trimmed, {
        type: "struct"
      });
      components.push(abiParameter);
    }
    if (!components.length)
      throw new BaseError("Invalid struct signature.", {
        details: signature,
        metaMessages: ["No properties exist."]
      });
    shallowStructs[match.name] = components;
  }
  const resolvedStructs = {};
  const entries = Object.entries(shallowStructs);
  const entriesLength = entries.length;
  for (let i = 0; i < entriesLength; i++) {
    const [name2, parameters] = entries[i];
    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);
  }
  return resolvedStructs;
}
var typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
  const components = [];
  const length = abiParameters.length;
  for (let i = 0; i < length; i++) {
    const abiParameter = abiParameters[i];
    const isTuple = isTupleRegex.test(abiParameter.type);
    if (isTuple)
      components.push(abiParameter);
    else {
      const match = execTyped(
        typeWithoutTupleRegex,
        abiParameter.type
      );
      if (!(match == null ? void 0 : match.type))
        throw new BaseError("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
      const { array, type } = match;
      if (type in structs) {
        if (ancestors.has(type))
          throw new BaseError("Circular reference detected.", {
            metaMessages: [`Struct "${type}" is a circular reference.`]
          });
        components.push({
          ...abiParameter,
          type: `tuple${array ?? ""}`,
          components: resolveStructs(
            structs[type] ?? [],
            structs,
            /* @__PURE__ */ new Set([...ancestors, type])
          )
        });
      } else {
        if (isSolidityType(type))
          components.push(abiParameter);
        else
          throw new BaseError("Unknown type.", {
            metaMessages: [
              `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
          });
      }
    }
  }
  return components;
}
function parseAbiParameter2(param) {
  let abiParameter;
  if (typeof param === "string")
    abiParameter = parseAbiParameter(param, {
      modifiers
    });
  else {
    const structs = parseStructs(param);
    const length = param.length;
    for (let i = 0; i < length; i++) {
      const signature = param[i];
      if (isStructSignature(signature))
        continue;
      abiParameter = parseAbiParameter(signature, { modifiers, structs });
      break;
    }
  }
  if (!abiParameter)
    throw new BaseError("Failed to parse ABI parameter.", {
      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
      docsPath: "/api/human.html#parseabiparameter-1"
    });
  return abiParameter;
}

// node_modules/web3-eth-abi/lib/esm/coders/utils.js
var WORD_SIZE = 32;
function alloc(size = 0) {
  var _a;
  if (((_a = globalThis.Buffer) === null || _a === void 0 ? void 0 : _a.alloc) !== void 0) {
    const buf = globalThis.Buffer.alloc(size);
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return new Uint8Array(size);
}
function convertExternalAbiParameter(abiParam) {
  var _a, _b;
  return Object.assign(Object.assign({}, abiParam), { name: (_a = abiParam.name) !== null && _a !== void 0 ? _a : "", components: (_b = abiParam.components) === null || _b === void 0 ? void 0 : _b.map((c) => convertExternalAbiParameter(c)) });
}
function isAbiParameter(param) {
  return !isNullish(param) && typeof param === "object" && !isNullish(param.type) && typeof param.type === "string";
}
function toAbiParams(abi) {
  return abi.map((input) => {
    var _a;
    if (isAbiParameter(input)) {
      return input;
    }
    if (typeof input === "string") {
      return convertExternalAbiParameter(parseAbiParameter2(input.replace(/tuple/, "")));
    }
    if (isSimplifiedStructFormat(input)) {
      const structName = Object.keys(input)[0];
      const structInfo = mapStructNameAndType(structName);
      structInfo.name = (_a = structInfo.name) !== null && _a !== void 0 ? _a : "";
      return Object.assign(Object.assign({}, structInfo), { components: mapStructToCoderFormat(input[structName]) });
    }
    throw new AbiError("Invalid abi");
  });
}
function extractArrayType(param) {
  const arrayParenthesisStart = param.type.lastIndexOf("[");
  const arrayParamType = param.type.substring(0, arrayParenthesisStart);
  const sizeString = param.type.substring(arrayParenthesisStart);
  let size = -1;
  if (sizeString !== "[]") {
    size = Number(sizeString.slice(1, -1));
    if (isNaN(size)) {
      throw new AbiError("Invalid fixed array size", { size: sizeString });
    }
  }
  return {
    param: { type: arrayParamType, name: "", components: param.components },
    size
  };
}
function isDynamic(param) {
  var _a, _b;
  if (param.type === "string" || param.type === "bytes" || param.type.endsWith("[]"))
    return true;
  if (param.type === "tuple") {
    return (_b = (_a = param.components) === null || _a === void 0 ? void 0 : _a.some(isDynamic)) !== null && _b !== void 0 ? _b : false;
  }
  if (param.type.endsWith("]")) {
    return isDynamic(extractArrayType(param).param);
  }
  return false;
}

// node_modules/web3-eth-abi/lib/esm/coders/base/address.js
var ADDRESS_BYTES_COUNT = 20;
var ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;
function encodeAddress(param, input) {
  if (typeof input !== "string") {
    throw new AbiError("address type expects string as input type", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  let address = input.toLowerCase();
  if (!address.startsWith("0x")) {
    address = `0x${address}`;
  }
  if (!isAddress(address)) {
    throw new AbiError("provided input is not valid address", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  const addressBytes = utils_exports.hexToUint8Array(address);
  const encoded = alloc(WORD_SIZE);
  encoded.set(addressBytes, ADDRESS_OFFSET);
  return {
    dynamic: false,
    encoded
  };
}
function decodeAddress(_param, bytes) {
  const addressBytes = bytes.subarray(ADDRESS_OFFSET, WORD_SIZE);
  if (addressBytes.length !== ADDRESS_BYTES_COUNT) {
    throw new AbiError("Invalid decoding input, not enough bytes to decode address", { bytes });
  }
  const result = utils_exports.uint8ArrayToHexString(addressBytes);
  return {
    result: toChecksumAddress(result),
    encoded: bytes.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/numbersLimits.js
var numberLimits = /* @__PURE__ */ new Map();
var base = BigInt(256);
for (let i = 8; i <= 256; i += 8) {
  numberLimits.set(`uint${i}`, {
    min: BigInt(0),
    max: base - BigInt(1)
  });
  numberLimits.set(`int${i}`, {
    min: -base / BigInt(2),
    max: base / BigInt(2) - BigInt(1)
  });
  base *= BigInt(256);
}
numberLimits.set(`int`, numberLimits.get("int256"));
numberLimits.set(`uint`, numberLimits.get("uint256"));

// node_modules/web3-eth-abi/lib/esm/coders/base/number.js
var mask = BigInt(1) << BigInt(256);
function bigIntToUint8Array(value, byteLength = WORD_SIZE) {
  let hexValue;
  if (value < 0) {
    hexValue = (mask + value).toString(16);
  } else {
    hexValue = value.toString(16);
  }
  hexValue = padLeft(hexValue, byteLength * 2);
  return utils_exports.hexToUint8Array(hexValue);
}
function uint8ArrayToBigInt(value, max) {
  const hexValue = utils_exports.uint8ArrayToHexString(value);
  const result = BigInt(hexValue);
  if (result <= max)
    return result;
  return result - mask;
}
function encodeNumber(param, input) {
  let value;
  try {
    value = toBigInt(input);
  } catch (e) {
    throw new AbiError("provided input is not number value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  if (value < limit.min) {
    throw new AbiError("provided input is less then minimum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (value > limit.max) {
    throw new AbiError("provided input is greater then maximum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    dynamic: false,
    encoded: bigIntToUint8Array(value)
  };
}
function decodeNumber(param, bytes) {
  if (bytes.length < WORD_SIZE) {
    throw new AbiError("Not enough bytes left to decode", { param, bytesLeft: bytes.length });
  }
  const boolBytes = bytes.subarray(0, WORD_SIZE);
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  const numberResult = uint8ArrayToBigInt(boolBytes, limit.max);
  if (numberResult < limit.min) {
    throw new AbiError("decoded value is less then minimum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (numberResult > limit.max) {
    throw new AbiError("decoded value is greater then maximum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    result: numberResult,
    encoded: bytes.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/bool.js
function encodeBoolean(param, input) {
  let value;
  try {
    value = toBool(input);
  } catch (e) {
    if (e instanceof InvalidBooleanError) {
      throw new AbiError("provided input is not valid boolean value", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
  }
  return encodeNumber({ type: "uint8", name: "" }, Number(value));
}
function decodeBool(_param, bytes) {
  const numberResult = decodeNumber({ type: "uint8", name: "" }, bytes);
  if (numberResult.result > 1 || numberResult.result < 0) {
    throw new AbiError("Invalid boolean value encoded", {
      boolBytes: bytes.subarray(0, WORD_SIZE),
      numberResult
    });
  }
  return {
    result: numberResult.result === BigInt(1),
    encoded: numberResult.encoded,
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/bytes.js
var MAX_STATIC_BYTES_COUNT = 32;
function encodeBytes(param, input) {
  if (typeof input === "string" && input.length % 2 !== 0) {
    input += "0";
  }
  if (!isBytes(input)) {
    throw new AbiError("provided input is not valid bytes value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const bytes = bytesToUint8Array(input);
  const [, size] = param.type.split("bytes");
  if (size) {
    if (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {
      throw new AbiError("invalid bytes type. Static byte type can have between 1 and 32 bytes", {
        type: param.type
      });
    }
    if (Number(size) < bytes.length) {
      throw new AbiError("provided input size is different than type size", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
    const encoded2 = alloc(WORD_SIZE);
    encoded2.set(bytes);
    return {
      dynamic: false,
      encoded: encoded2
    };
  }
  const partsLength = Math.ceil(bytes.length / WORD_SIZE);
  const encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);
  encoded.set(encodeNumber({ type: "uint32", name: "" }, bytes.length).encoded);
  encoded.set(bytes, WORD_SIZE);
  return {
    dynamic: true,
    encoded
  };
}
function decodeBytes(param, bytes) {
  const [, sizeString] = param.type.split("bytes");
  let size = Number(sizeString);
  let remainingBytes = bytes;
  let partsCount = 1;
  let consumed = 0;
  if (!size) {
    const result = decodeNumber({ type: "uint32", name: "" }, remainingBytes);
    size = Number(result.result);
    consumed += result.consumed;
    remainingBytes = result.encoded;
    partsCount = Math.ceil(size / WORD_SIZE);
  }
  if (size > bytes.length) {
    throw new AbiError("there is not enough data to decode", {
      type: param.type,
      encoded: bytes,
      size
    });
  }
  return {
    result: bytesToHex(remainingBytes.subarray(0, size)),
    encoded: remainingBytes.subarray(partsCount * WORD_SIZE),
    consumed: consumed + partsCount * WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/string.js
function encodeString(_param, input) {
  if (typeof input !== "string") {
    throw new AbiError("invalid input, should be string", { input });
  }
  const bytes = utf8ToBytes(input);
  return encodeBytes({ type: "bytes", name: "" }, bytes);
}
function decodeString(_param, bytes) {
  const r = decodeBytes({ type: "bytes", name: "" }, bytes);
  return {
    result: hexToUtf8(r.result),
    encoded: r.encoded,
    consumed: r.consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/utils.js
function encodeDynamicParams(encodedParams) {
  let staticSize = 0;
  let dynamicSize = 0;
  const staticParams = [];
  const dynamicParams = [];
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticSize += WORD_SIZE;
    } else {
      staticSize += encodedParam.encoded.length;
    }
  }
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticParams.push(encodeNumber({ type: "uint256", name: "" }, staticSize + dynamicSize));
      dynamicParams.push(encodedParam);
      dynamicSize += encodedParam.encoded.length;
    } else {
      staticParams.push(encodedParam);
    }
  }
  return uint8ArrayConcat(...staticParams.map((p) => p.encoded), ...dynamicParams.map((p) => p.encoded));
}

// node_modules/web3-eth-abi/lib/esm/coders/base/array.js
function encodeArray(param, values) {
  if (!Array.isArray(values)) {
    throw new AbiError("Expected value to be array", { abi: param, values });
  }
  const { size, param: arrayItemParam } = extractArrayType(param);
  const encodedParams = values.map((v) => encodeParamFromAbiParameter(arrayItemParam, v));
  const dynamic = size === -1;
  const dynamicItems = encodedParams.length > 0 && encodedParams[0].dynamic;
  if (!dynamic && values.length !== size) {
    throw new AbiError("Given arguments count doesn't match array length", {
      arrayLength: size,
      argumentsLength: values.length
    });
  }
  if (dynamic || dynamicItems) {
    const encodingResult = encodeDynamicParams(encodedParams);
    if (dynamic) {
      const encodedLength = encodeNumber({ type: "uint256", name: "" }, encodedParams.length).encoded;
      return {
        dynamic: true,
        encoded: encodedParams.length > 0 ? uint8ArrayConcat(encodedLength, encodingResult) : encodedLength
      };
    }
    return {
      dynamic: true,
      encoded: encodingResult
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat(...encodedParams.map((p) => p.encoded))
  };
}
function decodeArray(param, bytes) {
  let { size, param: arrayItemParam } = extractArrayType(param);
  const dynamic = size === -1;
  let consumed = 0;
  const result = [];
  let remaining = bytes;
  if (dynamic) {
    const lengthResult = decodeNumber({ type: "uint32", name: "" }, bytes);
    size = Number(lengthResult.result);
    consumed = lengthResult.consumed;
    remaining = lengthResult.encoded;
  }
  const hasDynamicChild = isDynamic(arrayItemParam);
  if (hasDynamicChild) {
    for (let i = 0; i < size; i += 1) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, remaining.subarray(i * WORD_SIZE));
      consumed += offsetResult.consumed;
      const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, remaining.subarray(Number(offsetResult.result)));
      consumed += decodedChildResult.consumed;
      result.push(decodedChildResult.result);
    }
    return {
      result,
      encoded: remaining.subarray(consumed),
      consumed
    };
  }
  for (let i = 0; i < size; i += 1) {
    const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, bytes.subarray(consumed));
    consumed += decodedChildResult.consumed;
    result.push(decodedChildResult.result);
  }
  return {
    result,
    encoded: bytes.subarray(consumed),
    consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/index.js
function encodeParamFromAbiParameter(param, value) {
  if (param.type === "string") {
    return encodeString(param, value);
  }
  if (param.type === "bool") {
    return encodeBoolean(param, value);
  }
  if (param.type === "address") {
    return encodeAddress(param, value);
  }
  if (param.type === "tuple") {
    return encodeTuple(param, value);
  }
  if (param.type.endsWith("]")) {
    return encodeArray(param, value);
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(param, value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return encodeNumber(param, value);
  }
  throw new AbiError("Unsupported", {
    param,
    value
  });
}
function decodeParamFromAbiParameter(param, bytes) {
  if (param.type === "string") {
    return decodeString(param, bytes);
  }
  if (param.type === "bool") {
    return decodeBool(param, bytes);
  }
  if (param.type === "address") {
    return decodeAddress(param, bytes);
  }
  if (param.type === "tuple") {
    return decodeTuple(param, bytes);
  }
  if (param.type.endsWith("]")) {
    return decodeArray(param, bytes);
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes(param, bytes);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(param, bytes);
  }
  throw new AbiError("Unsupported", {
    param,
    bytes
  });
}

// node_modules/web3-eth-abi/lib/esm/coders/base/tuple.js
function encodeTuple(param, input) {
  var _a, _b, _c;
  let dynamic = false;
  if (!Array.isArray(input) && typeof input !== "object") {
    throw new AbiError("param must be either Array or Object", {
      param,
      input
    });
  }
  const narrowedInput = input;
  const encoded = [];
  for (let i = 0; i < ((_b = (_a = param.components) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i += 1) {
    const paramComponent = param.components[i];
    let result;
    if (Array.isArray(narrowedInput)) {
      if (i >= narrowedInput.length) {
        throw new AbiError("input param length missmatch", {
          param,
          input
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, narrowedInput[i]);
    } else {
      const paramInput = narrowedInput[(_c = paramComponent.name) !== null && _c !== void 0 ? _c : ""];
      if (paramInput === void 0 || paramInput === null) {
        throw new AbiError("missing input defined in abi", {
          param,
          input,
          paramName: paramComponent.name
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, paramInput);
    }
    if (result.dynamic) {
      dynamic = true;
    }
    encoded.push(result);
  }
  if (dynamic) {
    return {
      dynamic: true,
      encoded: encodeDynamicParams(encoded)
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat(...encoded.map((e) => e.encoded))
  };
}
function decodeTuple(param, bytes) {
  const result = {
    __length__: 0
  };
  let consumed = 0;
  if (!param.components) {
    return {
      result,
      encoded: bytes,
      consumed
    };
  }
  let dynamicConsumed = 0;
  for (const [index, childParam] of param.components.entries()) {
    let decodedResult;
    if (isDynamic(childParam)) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, bytes.subarray(consumed));
      decodedResult = decodeParamFromAbiParameter(childParam, bytes.subarray(Number(offsetResult.result)));
      consumed += offsetResult.consumed;
      dynamicConsumed += decodedResult.consumed;
    } else {
      decodedResult = decodeParamFromAbiParameter(childParam, bytes.subarray(consumed));
      consumed += decodedResult.consumed;
    }
    result.__length__ += 1;
    result[index] = decodedResult.result;
    if (childParam.name && childParam.name !== "") {
      result[childParam.name] = decodedResult.result;
    }
  }
  return {
    encoded: bytes.subarray(consumed + dynamicConsumed),
    result,
    consumed: consumed + dynamicConsumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/decode.js
function decodeParameters(abis, bytes, _loose) {
  const abiParams = toAbiParams(abis);
  const bytesArray = utils_exports.hexToUint8Array(bytes);
  return decodeTuple({ type: "tuple", name: "", components: abiParams }, bytesArray).result;
}

// node_modules/web3-eth-abi/lib/esm/coders/encode.js
function inferParamsAbi(params) {
  const abi = [];
  params.forEach((param) => {
    if (Array.isArray(param)) {
      const inferredParams = inferParamsAbi(param);
      abi.push({
        type: "tuple",
        components: inferredParams,
        name: ""
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      });
    } else {
      abi.push({ type: toHex(param, true) });
    }
  });
  return abi;
}
function encodeParameters(abi, params) {
  if ((abi === null || abi === void 0 ? void 0 : abi.length) !== params.length) {
    throw new AbiError("Invalid number of values received for given ABI", {
      expected: abi === null || abi === void 0 ? void 0 : abi.length,
      received: params.length
    });
  }
  const abiParams = toAbiParams(abi);
  return utils_exports.uint8ArrayToHexString(encodeTuple({ type: "tuple", name: "", components: abiParams }, params).encoded);
}
function inferTypesAndEncodeParameters(params) {
  try {
    const abiParams = inferParamsAbi(params);
    return utils_exports.uint8ArrayToHexString(encodeTuple({ type: "tuple", name: "", components: abiParams }, params).encoded);
  } catch (e) {
    throw new AbiError("Could not infer types from given params", {
      params
    });
  }
}

// node_modules/web3-eth-abi/lib/esm/api/parameters_api.js
var encodeParameter = (abi, param) => encodeParameters([abi], [param]);
var decodeParametersWith = (abis, bytes, loose) => {
  try {
    if (abis.length > 0 && (!bytes || bytes === "0x" || bytes === "0X")) {
      throw new AbiError("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
    }
    return decodeParameters(abis, `0x${bytes.replace(/0x/i, "")}`, loose);
  } catch (err) {
    throw new AbiError(`Parameter decoding error: ${err.message}`, {
      internalErr: err
    });
  }
};
var decodeParameters2 = (abi, bytes) => decodeParametersWith(abi, bytes, false);
var decodeParameter = (abi, bytes) => decodeParameters2([abi], bytes)["0"];

// node_modules/web3-eth-abi/lib/esm/api/functions_api.js
var encodeFunctionSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiFunctionFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeFunctionSignature");
  }
  let name2;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name2 = jsonInterfaceMethodToString(functionName);
  } else {
    name2 = functionName;
  }
  return sha3Raw(name2).slice(0, 10);
};
var encodeFunctionCall = (jsonInterface, params) => {
  var _a;
  if (!isAbiFunctionFragment(jsonInterface)) {
    throw new AbiError("Invalid parameter value in encodeFunctionCall");
  }
  return `${encodeFunctionSignature(jsonInterface)}${encodeParameters((_a = jsonInterface.inputs) !== null && _a !== void 0 ? _a : [], params !== null && params !== void 0 ? params : []).replace("0x", "")}`;
};

// node_modules/web3-eth-abi/lib/esm/api/logs_api.js
var STATIC_TYPES = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"];
var _decodeParameter = (inputType, clonedTopic) => inputType === "string" ? clonedTopic : decodeParameter(inputType, clonedTopic);
var decodeLog = (inputs, data, topics) => {
  const clonedTopics = Array.isArray(topics) ? topics : [topics];
  const indexedInputs = {};
  const nonIndexedInputs = {};
  for (const [i, input] of inputs.entries()) {
    if (input.indexed) {
      indexedInputs[i] = input;
    } else {
      nonIndexedInputs[i] = input;
    }
  }
  const decodedNonIndexedInputs = data ? decodeParametersWith(Object.values(nonIndexedInputs), data, true) : { __length__: 0 };
  const offset = clonedTopics.length - Object.keys(indexedInputs).length;
  const decodedIndexedInputs = Object.values(indexedInputs).map((input, index) => STATIC_TYPES.some((s) => input.type.startsWith(s)) ? _decodeParameter(input.type, clonedTopics[index + offset]) : clonedTopics[index + offset]);
  const returnValues = { __length__: 0 };
  let indexedCounter = 0;
  let nonIndexedCounter = 0;
  for (const [i, res] of inputs.entries()) {
    returnValues[i] = res.type === "string" ? "" : void 0;
    if (indexedInputs[i]) {
      returnValues[i] = decodedIndexedInputs[indexedCounter];
      indexedCounter += 1;
    }
    if (nonIndexedInputs[i]) {
      returnValues[i] = decodedNonIndexedInputs[String(nonIndexedCounter)];
      nonIndexedCounter += 1;
    }
    if (res.name) {
      returnValues[res.name] = returnValues[i];
    }
    returnValues.__length__ += 1;
  }
  return returnValues;
};

// node_modules/web3-eth-abi/lib/esm/decode_contract_error_data.js
var decodeContractErrorData = (errorsAbi, error) => {
  if (error === null || error === void 0 ? void 0 : error.data) {
    let errorName;
    let errorSignature;
    let errorArgs;
    try {
      const errorSha = error.data.slice(0, 10);
      const errorAbi = errorsAbi.find((abi) => encodeErrorSignature(abi).startsWith(errorSha));
      if (errorAbi === null || errorAbi === void 0 ? void 0 : errorAbi.inputs) {
        errorName = errorAbi.name;
        errorSignature = jsonInterfaceMethodToString(errorAbi);
        errorArgs = decodeParameters2([...errorAbi.inputs], error.data.substring(10));
      } else if (error.data.startsWith("0x08c379a0")) {
        errorName = "Error";
        errorSignature = "Error(string)";
        errorArgs = decodeParameters2([
          {
            name: "message",
            type: "string"
          }
        ], error.data.substring(10));
      } else if (error.data.startsWith("0x4e487b71")) {
        errorName = "Panic";
        errorSignature = "Panic(uint256)";
        errorArgs = decodeParameters2([
          {
            name: "code",
            type: "uint256"
          }
        ], error.data.substring(10));
      } else {
        console.error("No matching error abi found for error data", error.data);
      }
    } catch (err) {
      console.error(err);
    }
    if (errorName) {
      error.setDecodedProperties(errorName, errorSignature, errorArgs);
    }
  }
};

// node_modules/web3-eth-abi/lib/esm/eip_712.js
var TYPE_REGEX = /^\w+/;
var ARRAY_REGEX = /^(.*)\[([0-9]*?)]$/;
var getDependencies = (typedData, type, dependencies = []) => {
  const match = type.match(TYPE_REGEX);
  const actualType = match[0];
  if (dependencies.includes(actualType)) {
    return dependencies;
  }
  if (!typedData.types[actualType]) {
    return dependencies;
  }
  return [
    actualType,
    ...typedData.types[actualType].reduce((previous, _type) => [
      ...previous,
      ...getDependencies(typedData, _type.type, previous).filter((dependency) => !previous.includes(dependency))
    ], [])
  ];
};
var encodeType = (typedData, type) => {
  const [primary, ...dependencies] = getDependencies(typedData, type);
  const types = [primary, ...dependencies.sort()];
  return types.map((dependency) => (
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    `${dependency}(${typedData.types[dependency].map((_type) => `${_type.type} ${_type.name}`)})`
  )).join("");
};
var getTypeHash = (typedData, type) => keccak256Wrapper(encodeType(typedData, type));
var getStructHash = (typedData, type, data) => keccak256Wrapper(encodeData(typedData, type, data));
var getMessage = (typedData, hash) => {
  const EIP_191_PREFIX = "1901";
  const message = `0x${EIP_191_PREFIX}${getStructHash(typedData, "EIP712Domain", typedData.domain).substring(2)}${getStructHash(typedData, typedData.primaryType, typedData.message).substring(2)}`;
  if (hash) {
    return keccak256Wrapper(message);
  }
  return message;
};
var encodeValue = (typedData, type, data) => {
  const match = type.match(ARRAY_REGEX);
  if (match) {
    const arrayType = match[1];
    const length = Number(match[2]) || void 0;
    if (!Array.isArray(data)) {
      throw new AbiError("Cannot encode data: value is not of array type", {
        data
      });
    }
    if (length && data.length !== length) {
      throw new AbiError(`Cannot encode data: expected length of ${length}, but got ${data.length}`, {
        data
      });
    }
    const encodedData = data.map((item) => encodeValue(typedData, arrayType, item));
    const types = encodedData.map((item) => item[0]);
    const values = encodedData.map((item) => item[1]);
    return ["bytes32", keccak256Wrapper(encodeParameters(types, values))];
  }
  if (typedData.types[type]) {
    return ["bytes32", getStructHash(typedData, type, data)];
  }
  if (type === "string") {
    return ["bytes32", keccak256Wrapper(data)];
  }
  if (type === "bytes") {
    return ["bytes32", keccak256Wrapper(data)];
  }
  return [type, data];
};
var encodeData = (typedData, type, data) => {
  const [types, values] = typedData.types[type].reduce(([_types, _values], field) => {
    if (isNullish(data[field.name]) || isNullish(field.type)) {
      throw new AbiError(`Cannot encode data: missing data for '${field.name}'`, {
        data,
        field
      });
    }
    const value = data[field.name];
    const [_type, encodedValue] = encodeValue(typedData, field.type, value);
    return [
      [..._types, _type],
      [..._values, encodedValue]
    ];
  }, [["bytes32"], [getTypeHash(typedData, type)]]);
  return encodeParameters(types, values);
};
export {
  decodeContractErrorData,
  decodeLog,
  decodeParameter,
  decodeParameters2 as decodeParameters,
  decodeParametersWith,
  encodeErrorSignature,
  encodeEventSignature,
  encodeFunctionCall,
  encodeFunctionSignature,
  encodeParameter,
  encodeParameters,
  flattenTypes,
  formatOddHexstrings,
  formatParam,
  getMessage as getEncodedEip712Data,
  inferTypesAndEncodeParameters,
  isAbiConstructorFragment,
  isAbiErrorFragment,
  isAbiEventFragment,
  isAbiFragment,
  isAbiFunctionFragment,
  isOddHexstring,
  isSimplifiedStructFormat,
  jsonInterfaceMethodToString,
  mapStructNameAndType,
  mapStructToCoderFormat,
  mapTypes
};
//# sourceMappingURL=web3-eth-abi.js.map
