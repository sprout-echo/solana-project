import {
  require_assert
} from "./chunk-GRZ7TWPM.js";
import {
  require_inherits_browser
} from "./chunk-CNYYE2TW.js";
import {
  require_buffer as require_buffer2
} from "./chunk-Z3UAXL6Y.js";
import {
  require_safe_buffer
} from "./chunk-THTHAMA4.js";
import {
  require_buffer
} from "./chunk-73PI7QCL.js";
import {
  require_crypto
} from "./chunk-AP5HHXD6.js";
import {
  __commonJS
} from "./chunk-LK32TJAX.js";

// node_modules/bitcore-lib-cash/package.json
var require_package = __commonJS({
  "node_modules/bitcore-lib-cash/package.json"(exports, module) {
    module.exports = {
      name: "bitcore-lib-cash",
      version: "10.0.23",
      description: "A pure and powerful JavaScript Bitcoin Cash library.",
      author: "BitPay <dev@bitpay.com>",
      main: "index.js",
      scripts: {
        test: "gulp test",
        "test:ci": "npm run test",
        coverage: "gulp coverage",
        build: "gulp",
        pub: "npm run build && npm publish"
      },
      keywords: [
        "bitcoin",
        "transaction",
        "address",
        "p2p",
        "ecies",
        "cryptocurrency",
        "blockchain",
        "payment",
        "bip21",
        "bip32",
        "bip37",
        "bip69",
        "bip70",
        "multisig"
      ],
      repository: {
        type: "git",
        url: "https://github.com/bitpay/bitcore/tree/master/packages/bitcore-lib-cash"
      },
      browser: {
        request: "browser-request"
      },
      dependencies: {
        "bitcore-lib": "^10.0.23",
        "bn.js": "=4.11.8",
        bs58: "^4.0.1",
        "buffer-compare": "=1.1.1",
        elliptic: "^6.5.3",
        inherits: "=2.0.1",
        lodash: "^4.17.20"
      },
      devDependencies: {
        "base-x": "=3.0.4",
        "bitcore-build": "^10.0.21",
        brfs: "^2.0.1",
        chai: "^4.2.0",
        gulp: "^4.0.0",
        sinon: "^7.1.1"
      },
      license: "MIT",
      gitHead: "5dffff0532ac0b236a3e1eb00983d89e2063afdf"
    };
  }
});

// node_modules/bitcore-lib-cash/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bitcore-lib-cash/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer2().Buffer;
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r <<= 4;
          if (c >= 49 && c <= 54) {
            r |= c - 49 + 10;
          } else if (c >= 17 && c <= 22) {
            r |= c - 17 + 10;
          } else {
            r |= c & 15;
          }
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        for (i = number.length - 6, j = 0; i >= start; i -= 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          r.strip();
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined2, symIterator = Symbol ? Symbol.iterator : undefined2, symToStringTag = Symbol ? Symbol.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol ? Symbol.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/bitcore-lib-cash/lib/errors/spec.js
var require_spec = __commonJS({
  "node_modules/bitcore-lib-cash/lib/errors/spec.js"(exports, module) {
    "use strict";
    var docsURL = "http://bitcore.io/";
    module.exports = [{
      name: "InvalidB58Char",
      message: "Invalid Base58 character: {0} in {1}"
    }, {
      name: "InvalidB58Checksum",
      message: "Invalid Base58 checksum for {0}"
    }, {
      name: "InvalidNetwork",
      message: "Invalid version for network: got {0}"
    }, {
      name: "InvalidState",
      message: "Invalid state: {0}"
    }, {
      name: "NotImplemented",
      message: "Function {0} was not implemented yet"
    }, {
      name: "InvalidNetworkArgument",
      message: 'Invalid network: must be "livenet" or "testnet", got {0}'
    }, {
      name: "InvalidArgument",
      message: function() {
        return "Invalid Argument" + (arguments[0] ? ": " + arguments[0] : "") + (arguments[1] ? " Documentation: " + docsURL + arguments[1] : "");
      }
    }, {
      name: "AbstractMethodInvoked",
      message: "Abstract Method Invocation: {0}"
    }, {
      name: "InvalidArgumentType",
      message: function() {
        return "Invalid Argument for " + arguments[2] + ", expected " + arguments[1] + " but got " + typeof arguments[0];
      }
    }, {
      name: "Unit",
      message: "Internal Error on Unit {0}",
      errors: [{
        "name": "UnknownCode",
        "message": "Unrecognized unit code: {0}"
      }, {
        "name": "InvalidRate",
        "message": "Invalid exchange rate: {0}"
      }]
    }, {
      name: "MerkleBlock",
      message: "Internal Error on MerkleBlock {0}",
      errors: [{
        "name": "InvalidMerkleTree",
        "message": "This MerkleBlock contain an invalid Merkle Tree"
      }]
    }, {
      name: "Transaction",
      message: "Internal Error on Transaction {0}",
      errors: [{
        name: "Input",
        message: "Internal Error on Input {0}",
        errors: [
          {
            name: "MissingScript",
            message: "Need a script to create an input"
          },
          {
            name: "UnsupportedScript",
            message: "Unsupported input script type: {0}"
          },
          {
            name: "MissingPreviousOutput",
            message: "No previous output information."
          },
          {
            name: "BlockHeightOutOfRange",
            message: "Block Height can only be between 0 and 65535"
          },
          {
            name: "LockTimeRange",
            message: "Seconds needs to be more that 0 and less that 33553920"
          }
        ]
      }, {
        name: "NeedMoreInfo",
        message: "{0}"
      }, {
        name: "InvalidSorting",
        message: "The sorting function provided did not return the change output as one of the array elements"
      }, {
        name: "InvalidOutputAmountSum",
        message: "{0}"
      }, {
        name: "MissingSignatures",
        message: "Some inputs have not been fully signed"
      }, {
        name: "InvalidIndex",
        message: "Invalid index: {0} is not between 0, {1}"
      }, {
        name: "UnableToVerifySignature",
        message: "Unable to verify signature: {0}"
      }, {
        name: "DustOutputs",
        message: "Dust amount detected in one output"
      }, {
        name: "InvalidSatoshis",
        message: "Output satoshis are invalid"
      }, {
        name: "FeeError",
        message: "Internal Error on Fee {0}",
        errors: [{
          name: "TooSmall",
          message: "Fee is too small: {0}"
        }, {
          name: "TooLarge",
          message: "Fee is too large: {0}"
        }, {
          name: "Different",
          message: "Unspent value is different from specified fee: {0}"
        }]
      }, {
        name: "ChangeAddressMissing",
        message: "Change address is missing"
      }, {
        name: "BlockHeightTooHigh",
        message: "Block Height can be at most 2^32 -1"
      }, {
        name: "NLockTimeOutOfRange",
        message: "Block Height can only be between 0 and 499 999 999"
      }, {
        name: "LockTimeTooEarly",
        message: "Lock Time can't be earlier than UNIX date 500 000 000"
      }]
    }, {
      name: "Script",
      message: "Internal Error on Script {0}",
      errors: [{
        name: "UnrecognizedAddress",
        message: "Expected argument {0} to be an address"
      }, {
        name: "CantDeriveAddress",
        message: "Can't derive address associated with script {0}, needs to be p2pkh in, p2pkh out, p2sh in, or p2sh out."
      }, {
        name: "InvalidBuffer",
        message: "Invalid script buffer: can't parse valid script from given buffer {0}"
      }]
    }, {
      name: "HDPrivateKey",
      message: "Internal Error on HDPrivateKey {0}",
      errors: [{
        name: "InvalidDerivationArgument",
        message: "Invalid derivation argument {0}, expected string, or number and boolean"
      }, {
        name: "InvalidEntropyArgument",
        message: "Invalid entropy: must be an hexa string or binary buffer, got {0}",
        errors: [{
          name: "TooMuchEntropy",
          message: 'Invalid entropy: more than 512 bits is non standard, got "{0}"'
        }, {
          name: "NotEnoughEntropy",
          message: 'Invalid entropy: at least 128 bits needed, got "{0}"'
        }]
      }, {
        name: "InvalidLength",
        message: "Invalid length for xprivkey string in {0}"
      }, {
        name: "InvalidPath",
        message: "Invalid derivation path: {0}"
      }, {
        name: "UnrecognizedArgument",
        message: 'Invalid argument: creating a HDPrivateKey requires a string, buffer, json or object, got "{0}"'
      }]
    }, {
      name: "HDPublicKey",
      message: "Internal Error on HDPublicKey {0}",
      errors: [{
        name: "ArgumentIsPrivateExtended",
        message: "Argument is an extended private key: {0}"
      }, {
        name: "InvalidDerivationArgument",
        message: "Invalid derivation argument: got {0}"
      }, {
        name: "InvalidLength",
        message: 'Invalid length for xpubkey: got "{0}"'
      }, {
        name: "InvalidPath",
        message: 'Invalid derivation path, it should look like: "m/1/100", got "{0}"'
      }, {
        name: "InvalidIndexCantDeriveHardened",
        message: "Invalid argument: creating a hardened path requires an HDPrivateKey"
      }, {
        name: "MustSupplyArgument",
        message: "Must supply an argument to create a HDPublicKey"
      }, {
        name: "UnrecognizedArgument",
        message: "Invalid argument for creation, must be string, json, buffer, or object"
      }]
    }];
  }
});

// node_modules/bitcore-lib-cash/lib/errors/index.js
var require_errors = __commonJS({
  "node_modules/bitcore-lib-cash/lib/errors/index.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    function format(message, args) {
      return message.replace("{0}", args[0]).replace("{1}", args[1]).replace("{2}", args[2]);
    }
    var traverseNode = function(parent, errorDefinition) {
      var NodeError = function() {
        if (_.isString(errorDefinition.message)) {
          this.message = format(errorDefinition.message, arguments);
        } else if (_.isFunction(errorDefinition.message)) {
          this.message = errorDefinition.message.apply(null, arguments);
        } else {
          throw new Error("Invalid error definition for " + errorDefinition.name);
        }
        this.stack = this.message + "\n" + new Error().stack;
      };
      NodeError.prototype = Object.create(parent.prototype);
      NodeError.prototype.name = parent.prototype.name + errorDefinition.name;
      parent[errorDefinition.name] = NodeError;
      if (errorDefinition.errors) {
        childDefinitions(NodeError, errorDefinition.errors);
      }
      return NodeError;
    };
    var childDefinitions = function(parent, childDefinitions2) {
      _.each(childDefinitions2, function(childDefinition) {
        traverseNode(parent, childDefinition);
      });
    };
    var traverseRoot = function(parent, errorsDefinition) {
      childDefinitions(parent, errorsDefinition);
      return parent;
    };
    var bitcore = {};
    bitcore.Error = function() {
      this.message = "Internal error";
      this.stack = this.message + "\n" + new Error().stack;
    };
    bitcore.Error.prototype = Object.create(Error.prototype);
    bitcore.Error.prototype.name = "bitcore.Error";
    var data = require_spec();
    traverseRoot(bitcore.Error, data);
    module.exports = bitcore.Error;
    module.exports.extend = function(spec) {
      return traverseNode(bitcore.Error, spec);
    };
  }
});

// node_modules/bitcore-lib-cash/lib/util/preconditions.js
var require_preconditions = __commonJS({
  "node_modules/bitcore-lib-cash/lib/util/preconditions.js"(exports, module) {
    "use strict";
    var errors = require_errors();
    var _ = require_lodash();
    module.exports = {
      checkState: function(condition, message) {
        if (!condition) {
          throw new errors.InvalidState(message);
        }
      },
      checkArgument: function(condition, argumentName, message, docsPath) {
        if (!condition) {
          throw new errors.InvalidArgument(argumentName, message, docsPath);
        }
      },
      checkArgumentType: function(argument, type, argumentName) {
        argumentName = argumentName || "(unknown name)";
        if (_.isString(type)) {
          if (type === "Buffer") {
            var buffer = require_buffer();
            if (!buffer.Buffer.isBuffer(argument)) {
              throw new errors.InvalidArgumentType(argument, type, argumentName);
            }
          } else if (typeof argument !== type) {
            throw new errors.InvalidArgumentType(argument, type, argumentName);
          }
        } else {
          if (!(argument instanceof type)) {
            throw new errors.InvalidArgumentType(argument, type.name, argumentName);
          }
        }
      }
    };
  }
});

// node_modules/bitcore-lib-cash/lib/crypto/bn.js
var require_bn2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/crypto/bn.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var $ = require_preconditions();
    var _ = require_lodash();
    var reversebuf = function(buf) {
      var buf2 = Buffer.alloc(buf.length);
      for (var i = 0; i < buf.length; i++) {
        buf2[i] = buf[buf.length - 1 - i];
      }
      return buf2;
    };
    BN.Zero = new BN(0);
    BN.One = new BN(1);
    BN.Minus1 = new BN(-1);
    BN.fromNumber = function(n) {
      $.checkArgument(_.isNumber(n));
      return new BN(n);
    };
    BN.fromString = function(str, base) {
      $.checkArgument(_.isString(str));
      return new BN(str, base);
    };
    BN.fromBuffer = function(buf, opts) {
      if (typeof opts !== "undefined" && opts.endian === "little") {
        buf = reversebuf(buf);
      }
      var hex = buf.toString("hex");
      var bn = new BN(hex, 16);
      return bn;
    };
    BN.fromSM = function(buf, opts) {
      var ret;
      if (buf.length === 0) {
        return BN.fromBuffer(Buffer.from([0]));
      }
      var endian = "big";
      if (opts) {
        endian = opts.endian;
      }
      if (endian === "little") {
        buf = reversebuf(buf);
      }
      if (buf[0] & 128) {
        buf[0] = buf[0] & 127;
        ret = BN.fromBuffer(buf);
        ret.neg().copy(ret);
      } else {
        ret = BN.fromBuffer(buf);
      }
      return ret;
    };
    BN.prototype.toNumber = function() {
      return parseInt(this.toString(10), 10);
    };
    BN.prototype.toBuffer = function(opts) {
      var buf, hex;
      if (opts && opts.size) {
        hex = this.toString(16, 2);
        var natlen = hex.length / 2;
        buf = Buffer.from(hex, "hex");
        if (natlen === opts.size) {
          buf = buf;
        } else if (natlen > opts.size) {
          buf = BN.trim(buf, natlen);
        } else if (natlen < opts.size) {
          buf = BN.pad(buf, natlen, opts.size);
        }
      } else {
        hex = this.toString(16, 2);
        buf = Buffer.from(hex, "hex");
      }
      if (typeof opts !== "undefined" && opts.endian === "little") {
        buf = reversebuf(buf);
      }
      return buf;
    };
    BN.prototype.toSMBigEndian = function() {
      var buf;
      if (this.cmp(BN.Zero) === -1) {
        buf = this.neg().toBuffer();
        if (buf[0] & 128) {
          buf = Buffer.concat([Buffer.from([128]), buf]);
        } else {
          buf[0] = buf[0] | 128;
        }
      } else {
        buf = this.toBuffer();
        if (buf[0] & 128) {
          buf = Buffer.concat([Buffer.from([0]), buf]);
        }
      }
      if (buf.length === 1 & buf[0] === 0) {
        buf = Buffer.from([]);
      }
      return buf;
    };
    BN.prototype.toSM = function(opts) {
      var endian = opts ? opts.endian : "big";
      var buf = this.toSMBigEndian();
      if (endian === "little") {
        buf = reversebuf(buf);
      }
      return buf;
    };
    BN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {
      var nMaxNumSize = size || 4;
      $.checkArgument(buf.length <= nMaxNumSize, new Error("script number overflow"));
      if (fRequireMinimal && buf.length > 0) {
        if ((buf[buf.length - 1] & 127) === 0) {
          if (buf.length <= 1 || (buf[buf.length - 2] & 128) === 0) {
            throw new Error("non-minimally encoded script number");
          }
        }
      }
      return BN.fromSM(buf, {
        endian: "little"
      });
    };
    BN.prototype.toScriptNumBuffer = function() {
      return this.toSM({
        endian: "little"
      });
    };
    BN.trim = function(buf, natlen) {
      return buf.slice(natlen - buf.length, buf.length);
    };
    BN.pad = function(buf, natlen, size) {
      var rbuf = Buffer.alloc(size);
      for (var i = 0; i < buf.length; i++) {
        rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];
      }
      for (i = 0; i < size - natlen; i++) {
        rbuf[i] = 0;
      }
      return rbuf;
    };
    BN.prototype.getSize = function() {
      const bin = this.toString(2).replace("-", "");
      const numBits = bin.length + 1;
      return numBits / 8;
    };
    BN.prototype.checkOperationForOverflow = function(operand, result, maxSize) {
      if (this.getSize() > maxSize || operand.getSize() > maxSize || result.getSize() > 8) {
        throw new Error("overflow");
      }
    };
    BN.prototype.safeAdd = function(bigNumToAdd, maxSize) {
      const sum = this.add(bigNumToAdd);
      this.checkOperationForOverflow(bigNumToAdd, sum, maxSize);
      return sum;
    };
    BN.prototype.safeSub = function(bigNumToSubtract, maxSize) {
      const difference = this.sub(bigNumToSubtract);
      this.checkOperationForOverflow(bigNumToSubtract, difference, maxSize);
      return difference;
    };
    BN.prototype.safeMul = function(bigNumToMultiply, maxSize) {
      const product = this.mul(bigNumToMultiply);
      this.checkOperationForOverflow(bigNumToMultiply, product, maxSize);
      return product;
    };
    module.exports = BN;
  }
});

// node_modules/bitcore-lib-cash/lib/util/js.js
var require_js = __commonJS({
  "node_modules/bitcore-lib-cash/lib/util/js.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var isHexa = function isHexa2(value) {
      if (!_.isString(value)) {
        return false;
      }
      return /^[0-9a-fA-F]+$/.test(value);
    };
    module.exports = {
      /**
       * Test if an argument is a valid JSON object. If it is, returns a truthy
       * value (the json object decoded), so no double JSON.parse call is necessary
       *
       * @param {string} arg
       * @return {Object|boolean} false if the argument is not a JSON string.
       */
      isValidJSON: function isValidJSON(arg) {
        var parsed;
        if (!_.isString(arg)) {
          return false;
        }
        try {
          parsed = JSON.parse(arg);
        } catch (e) {
          return false;
        }
        if (typeof parsed === "object") {
          return true;
        }
        return false;
      },
      isHexa,
      isHexaString: isHexa,
      /**
       * Clone an array
       */
      cloneArray: function(array) {
        return [].concat(array);
      },
      /**
       * Define immutable properties on a target object
       *
       * @param {Object} target - An object to be extended
       * @param {Object} values - An object of properties
       * @return {Object} The target object
       */
      defineImmutable: function defineImmutable(target, values) {
        Object.keys(values).forEach(function(key) {
          Object.defineProperty(target, key, {
            configurable: false,
            enumerable: true,
            value: values[key]
          });
        });
        return target;
      },
      /**
       * Checks that a value is a natural number, a positive integer or zero.
       *
       * @param {*} value
       * @return {Boolean}
       */
      isNaturalNumber: function isNaturalNumber(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
      }
    };
  }
});

// node_modules/bitcore-lib-cash/lib/util/buffer.js
var require_buffer3 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/util/buffer.js"(exports, module) {
    "use strict";
    var buffer = require_buffer();
    var assert = require_assert();
    var js = require_js();
    var $ = require_preconditions();
    function equals(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      var length = a.length;
      for (var i = 0; i < length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    module.exports = {
      /**
       * Fill a buffer with a value.
       *
       * @param {Buffer} buffer
       * @param {number} value
       * @return {Buffer}
       */
      fill: function fill(buffer2, value) {
        $.checkArgumentType(buffer2, "Buffer", "buffer");
        $.checkArgumentType(value, "number", "value");
        var length = buffer2.length;
        for (var i = 0; i < length; i++) {
          buffer2[i] = value;
        }
        return buffer2;
      },
      /**
       * Return a copy of a buffer
       *
       * @param {Buffer} original
       * @return {Buffer}
       */
      copy: function(original) {
        var buffer2 = Buffer.alloc(original.length);
        original.copy(buffer2);
        return buffer2;
      },
      /**
       * Returns true if the given argument is an instance of a buffer. Tests for
       * both node's Buffer and Uint8Array
       *
       * @param {*} arg
       * @return {boolean}
       */
      isBuffer: function isBuffer(arg) {
        return buffer.Buffer.isBuffer(arg) || arg instanceof Uint8Array;
      },
      /**
       * Returns a zero-filled byte array
       *
       * @param {number} bytes
       * @return {Buffer}
       */
      emptyBuffer: function emptyBuffer(bytes) {
        $.checkArgumentType(bytes, "number", "bytes");
        var result = Buffer.alloc(bytes);
        for (var i = 0; i < bytes; i++) {
          result.write("\0", i);
        }
        return result;
      },
      /**
       * Concatenates a buffer
       *
       * Shortcut for <tt>buffer.Buffer.concat</tt>
       */
      concat: buffer.Buffer.concat,
      equals,
      equal: equals,
      /**
       * Transforms a number from 0 to 255 into a Buffer of size 1 with that value
       *
       * @param {number} integer
       * @return {Buffer}
       */
      integerAsSingleByteBuffer: function integerAsSingleByteBuffer(integer) {
        $.checkArgumentType(integer, "number", "integer");
        return Buffer.from([integer & 255]);
      },
      /**
       * Transform a 4-byte integer into a Buffer of length 4.
       *
       * @param {number} integer
       * @return {Buffer}
       */
      integerAsBuffer: function integerAsBuffer(integer) {
        $.checkArgumentType(integer, "number", "integer");
        var bytes = [];
        bytes.push(integer >> 24 & 255);
        bytes.push(integer >> 16 & 255);
        bytes.push(integer >> 8 & 255);
        bytes.push(integer & 255);
        return Buffer.from(bytes);
      },
      /**
       * Transform the first 4 values of a Buffer into a number, in little endian encoding
       *
       * @param {Buffer} buffer
       * @return {number}
       */
      integerFromBuffer: function integerFromBuffer(buffer2) {
        $.checkArgumentType(buffer2, "Buffer", "buffer");
        return buffer2[0] << 24 | buffer2[1] << 16 | buffer2[2] << 8 | buffer2[3];
      },
      /**
       * Transforms the first byte of an array into a number ranging from -128 to 127
       * @param {Buffer} buffer
       * @return {number}
       */
      integerFromSingleByteBuffer: function integerFromBuffer(buffer2) {
        $.checkArgumentType(buffer2, "Buffer", "buffer");
        return buffer2[0];
      },
      /**
       * Transforms a buffer into a string with a number in hexa representation
       *
       * Shorthand for <tt>buffer.toString('hex')</tt>
       *
       * @param {Buffer} buffer
       * @return {string}
       */
      bufferToHex: function bufferToHex(buffer2) {
        $.checkArgumentType(buffer2, "Buffer", "buffer");
        return buffer2.toString("hex");
      },
      /**
       * Reverse a buffer
       * @param {Buffer} param
       * @return {Buffer}
       */
      reverse: function reverse(param) {
        return Buffer.from(param).reverse();
      }
    };
    module.exports.NULL_HASH = module.exports.fill(Buffer.alloc(32), 0);
    module.exports.EMPTY_BUFFER = Buffer.alloc(0);
  }
});

// node_modules/elliptic/package.json
var require_package2 = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.7",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/elliptic/node_modules/bn.js/lib/bn.js
var require_bn3 = __commonJS({
  "node_modules/elliptic/node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26) break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0) return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils = exports;
    var BN = require_bn3();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i;
      for (i = 0; i < naf.length; i += 1) {
        naf[i] = 0;
      }
      var ws = 1 << w + 1;
      var k = num.clone();
      for (i = 0; i < naf.length; i++) {
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z = (ws >> 1) - mod;
          else
            z = mod;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    var r;
    module.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto = require_crypto();
        if (typeof crypto.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn3();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn3();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils2();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var BN = require_bn3();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var assert = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash = exports;
    hash.utils = require_utils3();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils = require_utils2();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var utils = require_utils();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn3();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils2();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn3();
    var utils = require_utils2();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils = require_utils2();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package2().version;
    elliptic.utils = require_utils2();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/bitcore-lib-cash/lib/crypto/point.js
var require_point = __commonJS({
  "node_modules/bitcore-lib-cash/lib/crypto/point.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var BufferUtil = require_buffer3();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecPoint = ec.curve.point.bind(ec.curve);
    var ecPointFromX = ec.curve.pointFromX.bind(ec.curve);
    var Point = function Point2(x, y, isRed) {
      try {
        var point = ecPoint(x, y, isRed);
      } catch (e) {
        throw new Error("Invalid Point");
      }
      point.validate();
      return point;
    };
    Point.prototype = Object.getPrototypeOf(ec.curve.point());
    Point.fromX = function fromX(odd, x) {
      try {
        var point = ecPointFromX(x, odd);
      } catch (e) {
        throw new Error("Invalid X");
      }
      point.validate();
      return point;
    };
    Point.getG = function getG() {
      return ec.curve.g;
    };
    Point.getN = function getN() {
      return new BN(ec.curve.n.toArray());
    };
    if (!Point.prototype._getX)
      Point.prototype._getX = Point.prototype.getX;
    Point.prototype.getX = function getX() {
      return new BN(this._getX().toArray());
    };
    if (!Point.prototype._getY)
      Point.prototype._getY = Point.prototype.getY;
    Point.prototype.getY = function getY() {
      return new BN(this._getY().toArray());
    };
    Point.prototype.validate = function validate() {
      if (this.isInfinity()) {
        throw new Error("Point cannot be equal to Infinity");
      }
      var p2;
      try {
        p2 = ecPointFromX(this.getX(), this.getY().isOdd());
      } catch (e) {
        throw new Error("Point does not lie on the curve");
      }
      if (p2.y.cmp(this.y) !== 0) {
        throw new Error("Invalid y value for curve.");
      }
      if (!this.mul(Point.getN()).isInfinity()) {
        throw new Error("Point times N must be infinity");
      }
      return this;
    };
    Point.pointToCompressed = function pointToCompressed(point) {
      var xbuf = point.getX().toBuffer({ size: 32 });
      var ybuf = point.getY().toBuffer({ size: 32 });
      var prefix;
      var odd = ybuf[ybuf.length - 1] % 2;
      if (odd) {
        prefix = Buffer.from([3]);
      } else {
        prefix = Buffer.from([2]);
      }
      return BufferUtil.concat([prefix, xbuf]);
    };
    Point.prototype.hasSquare = function() {
      return !this.isInfinity() && this.isSquare(this.getY());
    };
    Point.prototype.isSquare = function(x) {
      let p = new BN("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "hex");
      let x0 = new BN(x);
      let base = x0.toRed(BN.red(p));
      let res = base.redPow(p.sub(BN.One).div(new BN(2))).fromRed();
      return res.eq(new BN(1));
    };
    module.exports = Point;
  }
});

// node_modules/bitcore-lib-cash/lib/crypto/signature.js
var require_signature3 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/crypto/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var _ = require_lodash();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var Signature = function Signature2(r, s, isSchnorr) {
      if (!(this instanceof Signature2)) {
        return new Signature2(r, s, isSchnorr);
      }
      if (r instanceof BN) {
        this.set({
          r,
          s,
          isSchnorr
        });
      } else if (r) {
        var obj = r;
        this.set(obj);
      }
    };
    Signature.prototype.set = function(obj) {
      this.r = obj.r || this.r || void 0;
      this.s = obj.s || this.s || void 0;
      this.i = typeof obj.i !== "undefined" ? obj.i : this.i;
      this.compressed = typeof obj.compressed !== "undefined" ? obj.compressed : this.compressed;
      this.isSchnorr = obj.isSchnorr || this.isSchnorr;
      this.nhashtype = obj.nhashtype || this.nhashtype || void 0;
      return this;
    };
    Signature.fromCompact = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf), "Argument is expected to be a Buffer");
      var sig = new Signature();
      var compressed = true;
      var i = buf.slice(0, 1)[0] - 27 - 4;
      if (i < 0) {
        compressed = false;
        i = i + 4;
      }
      var b2 = buf.slice(1, 33);
      var b3 = buf.slice(33, 65);
      $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error("i must be 0, 1, 2, or 3"));
      $.checkArgument(b2.length === 32, new Error("r must be 32 bytes"));
      $.checkArgument(b3.length === 32, new Error("s must be 32 bytes"));
      sig.compressed = compressed;
      sig.i = i;
      sig.r = BN.fromBuffer(b2);
      sig.s = BN.fromBuffer(b3);
      return sig;
    };
    Signature.fromDER = Signature.fromBuffer = function(buf, strict) {
      if (buf.length === 64) {
        let obj2 = Signature.parseSchnorrEncodedSig(buf);
        let sig2 = new Signature();
        sig2.r = obj2.r;
        sig2.s = obj2.s;
        sig2.isSchnorr = true;
        return sig2;
      }
      var obj = Signature.parseDER(buf, strict);
      var sig = new Signature();
      sig.r = obj.r;
      sig.s = obj.s;
      return sig;
    };
    Signature.fromTxFormat = function(buf) {
      var nhashtype = buf.readUInt8(buf.length - 1);
      var derbuf = buf.slice(0, buf.length - 1);
      var sig = new Signature.fromDER(derbuf, false);
      sig.nhashtype = nhashtype;
      return sig;
    };
    Signature.fromDataFormat = function(buf) {
      var derbuf = buf.slice(0, buf.length);
      var sig = new Signature.fromDER(derbuf, false);
      return sig;
    };
    Signature.fromString = function(str) {
      var buf = Buffer.from(str, "hex");
      return Signature.fromDER(buf);
    };
    Signature.fromTxString = function(str, encoding = "hex") {
      return Signature.fromTxFormat(Buffer.from(str, encoding));
    };
    Signature.parseSchnorrEncodedSig = function(buf) {
      let r = buf.slice(0, 32);
      let s = buf.slice(32, 64);
      let hashtype;
      if (buf.length === 65) {
        hashtype = buf.slice(64, 65);
        this.nhashtype = hashtype;
      }
      var obj = {
        r: BN.fromBuffer(r),
        s: BN.fromBuffer(s),
        nhashtype: hashtype
      };
      return obj;
    };
    Signature.parseDER = function(buf, strict) {
      $.checkArgument(BufferUtil.isBuffer(buf), new Error("DER formatted signature should be a buffer"));
      if (_.isUndefined(strict)) {
        strict = true;
      }
      var header = buf[0];
      $.checkArgument(header === 48, new Error("Header byte should be 0x30"));
      var length = buf[1];
      var buflength = buf.slice(2).length;
      $.checkArgument(!strict || length === buflength, new Error("Length byte should length of what follows"));
      length = length < buflength ? length : buflength;
      var rheader = buf[2 + 0];
      $.checkArgument(rheader === 2, new Error("Integer byte for r should be 0x02"));
      var rlength = buf[2 + 1];
      var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);
      var r = BN.fromBuffer(rbuf);
      var rneg = buf[2 + 1 + 1] === 0 ? true : false;
      $.checkArgument(rlength === rbuf.length, new Error("Length of r incorrect"));
      var sheader = buf[2 + 2 + rlength + 0];
      $.checkArgument(sheader === 2, new Error("Integer byte for s should be 0x02"));
      var slength = buf[2 + 2 + rlength + 1];
      var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);
      var s = BN.fromBuffer(sbuf);
      var sneg = buf[2 + 2 + rlength + 2 + 2] === 0 ? true : false;
      $.checkArgument(slength === sbuf.length, new Error("Length of s incorrect"));
      var sumlength = 2 + 2 + rlength + 2 + slength;
      $.checkArgument(length === sumlength - 2, new Error("Length of signature incorrect"));
      var obj = {
        header,
        length,
        rheader,
        rlength,
        rneg,
        rbuf,
        r,
        sheader,
        slength,
        sneg,
        sbuf,
        s
      };
      return obj;
    };
    Signature.prototype.toCompact = function(i, compressed) {
      i = typeof i === "number" ? i : this.i;
      compressed = typeof compressed === "boolean" ? compressed : this.compressed;
      if (!(i === 0 || i === 1 || i === 2 || i === 3)) {
        throw new Error("i must be equal to 0, 1, 2, or 3");
      }
      var val = i + 27 + 4;
      if (compressed === false) {
        val = val - 4;
      }
      var b1 = Buffer.from([val]);
      var b2 = this.r.toBuffer({
        size: 32
      });
      var b3 = this.s.toBuffer({
        size: 32
      });
      return Buffer.concat([b1, b2, b3]);
    };
    Signature.prototype.toBuffer = Signature.prototype.toDER = function() {
      if (this.isSchnorr) {
        return Buffer.concat([this.r.toBuffer({ size: 32 }), this.s.toBuffer({ size: 32 })]);
      }
      var rnbuf = this.r.toBuffer();
      var snbuf = this.s.toBuffer();
      var rneg = rnbuf[0] & 128 ? true : false;
      var sneg = snbuf[0] & 128 ? true : false;
      var rbuf = rneg ? Buffer.concat([Buffer.from([0]), rnbuf]) : rnbuf;
      var sbuf = sneg ? Buffer.concat([Buffer.from([0]), snbuf]) : snbuf;
      var rlength = rbuf.length;
      var slength = sbuf.length;
      var length = 2 + rlength + 2 + slength;
      var rheader = 2;
      var sheader = 2;
      var header = 48;
      var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);
      return der;
    };
    Signature.prototype.toString = function() {
      var buf = this.toDER();
      return buf.toString("hex");
    };
    Signature.isTxDER = function(buf) {
      return Signature.isDER(buf.slice(0, buf.length - 1));
    };
    Signature.isDER = function(buf) {
      if (buf.length < 8 || buf.length > 72) {
        return false;
      }
      if (buf[0] != 48) {
        return false;
      }
      if (buf[1] != buf.length - 2) {
        return false;
      }
      if (buf[2] != 2) {
        return false;
      }
      var lenR = buf[3];
      if (lenR == 0) {
        return false;
      }
      if (buf[4] & 128) {
        return false;
      }
      if (lenR > buf.length - 7) {
        return false;
      }
      if (lenR > 1 && buf[4] == 0 && !(buf[5] & 128)) {
        return false;
      }
      var startS = lenR + 4;
      if (buf[startS] != 2) {
        return false;
      }
      var lenS = buf[startS + 1];
      if (lenS == 0) {
        return false;
      }
      if (buf[startS + 2] & 128) {
        return false;
      }
      if (startS + lenS + 2 != buf.length) {
        return false;
      }
      if (lenS > 1 && buf[startS + 2] == 0 && !(buf[startS + 3] & 128)) {
        return false;
      }
      return true;
    };
    Signature.prototype.hasLowS = function() {
      if (this.s.lt(new BN(1)) || this.s.gt(new BN("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex"))) {
        return false;
      }
      return true;
    };
    Signature.prototype.hasDefinedHashtype = function() {
      if (!JSUtil.isNaturalNumber(this.nhashtype)) {
        return false;
      }
      var mask = ~(Signature.SIGHASH_FORKID | Signature.SIGHASH_ANYONECANPAY) >>> 0;
      var temp = this.nhashtype & mask;
      if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {
        return false;
      }
      return true;
    };
    Signature.prototype.toTxFormat = function(signingMethod) {
      var derbuf = this.toDER(signingMethod);
      var buf = Buffer.alloc(1);
      buf.writeUInt8(this.nhashtype, 0);
      return Buffer.concat([derbuf, buf]);
    };
    Signature.SIGHASH_ALL = 1;
    Signature.SIGHASH_NONE = 2;
    Signature.SIGHASH_SINGLE = 3;
    Signature.SIGHASH_FORKID = 64;
    Signature.SIGHASH_ANYONECANPAY = 128;
    module.exports = Signature;
  }
});

// node_modules/bitcore-lib-cash/lib/crypto/hash.js
var require_hash2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/crypto/hash.js"(exports, module) {
    "use strict";
    var crypto = require_crypto();
    var BufferUtil = require_buffer3();
    var $ = require_preconditions();
    var Hash = module.exports;
    Hash.sha1 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto.createHash("sha1").update(buf).digest();
    };
    Hash.sha1.blocksize = 512;
    Hash.sha256 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto.createHash("sha256").update(buf).digest();
    };
    Hash.sha256.blocksize = 512;
    Hash.sha256sha256 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return Hash.sha256(Hash.sha256(buf));
    };
    Hash.ripemd160 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto.createHash("ripemd160").update(buf).digest();
    };
    Hash.sha256ripemd160 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return Hash.ripemd160(Hash.sha256(buf));
    };
    Hash.sha512 = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return crypto.createHash("sha512").update(buf).digest();
    };
    Hash.sha512.blocksize = 1024;
    Hash.hmac = function(hashf, data, key) {
      $.checkArgument(BufferUtil.isBuffer(data));
      $.checkArgument(BufferUtil.isBuffer(key));
      $.checkArgument(hashf.blocksize);
      var blocksize = hashf.blocksize / 8;
      if (key.length > blocksize) {
        key = hashf(key);
      } else if (key < blocksize) {
        var fill = Buffer.alloc(blocksize);
        fill.fill(0);
        key.copy(fill);
        key = fill;
      }
      var o_key = Buffer.alloc(blocksize);
      o_key.fill(92);
      var i_key = Buffer.alloc(blocksize);
      i_key.fill(54);
      var o_key_pad = Buffer.alloc(blocksize);
      var i_key_pad = Buffer.alloc(blocksize);
      for (var i = 0; i < blocksize; i++) {
        o_key_pad[i] = o_key[i] ^ key[i];
        i_key_pad[i] = i_key[i] ^ key[i];
      }
      return hashf(Buffer.concat([o_key_pad, hashf(Buffer.concat([i_key_pad, data]))]));
    };
    Hash.sha256hmac = function(data, key) {
      return Hash.hmac(Hash.sha256, data, key);
    };
    Hash.sha512hmac = function(data, key) {
      return Hash.hmac(Hash.sha512, data, key);
    };
  }
});

// node_modules/bitcore-lib-cash/lib/networks.js
var require_networks = __commonJS({
  "node_modules/bitcore-lib-cash/lib/networks.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var networks = [];
    var networkMaps = {};
    function Network() {
    }
    Network.prototype.toString = function toString() {
      return this.name;
    };
    function get(arg, keys) {
      if (~networks.indexOf(arg)) {
        return arg;
      }
      if (keys) {
        if (!_.isArray(keys)) {
          keys = [keys];
        }
        for (var i = 0; i < networks.length; i++) {
          var network = networks[i];
          var filteredNet = _.pick(network, keys);
          var netValues = _.values(filteredNet);
          if (~netValues.indexOf(arg)) {
            return network;
          }
        }
        return void 0;
      }
      return networkMaps[arg];
    }
    function prefixToArray(prefix) {
      var result = [];
      for (var i = 0; i < prefix.length; i++) {
        result.push(prefix.charCodeAt(i) & 31);
      }
      return result;
    }
    function addNetwork(data) {
      var network = new Network();
      JSUtil.defineImmutable(network, {
        name: data.name,
        alias: data.alias,
        pubkeyhash: data.pubkeyhash,
        privatekey: data.privatekey,
        scripthash: data.scripthash,
        xpubkey: data.xpubkey,
        xprivkey: data.xprivkey
      });
      var indexBy = data.indexBy || Object.keys(data);
      if (data.prefix) {
        _.extend(network, {
          prefix: data.prefix,
          prefixArray: prefixToArray(data.prefix)
        });
      }
      if (data.networkMagic) {
        _.extend(network, {
          networkMagic: BufferUtil.integerAsBuffer(data.networkMagic)
        });
      }
      if (data.port) {
        _.extend(network, {
          port: data.port
        });
      }
      if (data.dnsSeeds) {
        _.extend(network, {
          dnsSeeds: data.dnsSeeds
        });
      }
      networks.push(network);
      indexNetworkBy(network, indexBy);
      return network;
    }
    function indexNetworkBy(network, keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var networkValue = network[key];
        if (!_.isUndefined(networkValue) && !_.isObject(networkValue)) {
          networkMaps[networkValue] = network;
        }
      }
    }
    function removeNetwork(network) {
      if (typeof network !== "object") {
        network = get(network);
      }
      for (var i = 0; i < networks.length; i++) {
        if (networks[i] === network) {
          networks.splice(i, 1);
        }
      }
      for (var key in networkMaps) {
        if (networkMaps[key].length) {
          const index = networkMaps[key].indexOf(network);
          if (index >= 0) {
            networkMaps[key].splice(index, 1);
          }
          if (networkMaps[key].length === 0) {
            delete networkMaps[key];
          }
        } else if (networkMaps[key] === network) {
          delete networkMaps[key];
        }
      }
    }
    var dnsSeeds = [
      "seed.bitcoinabc.org",
      "seed-abc.bitcoinforks.org",
      "btccash-seeder.bitcoinunlimited.info",
      "seeder.jasonbcox.com",
      "seed.deadalnix.me",
      "seed.bchd.cash"
    ];
    var liveNetwork = {
      name: "livenet",
      alias: "mainnet",
      prefix: "bitcoincash",
      pubkeyhash: 28,
      privatekey: 128,
      scripthash: 40,
      xpubkey: 76067358,
      xprivkey: 76066276,
      networkMagic: 3823236072,
      port: 8333,
      dnsSeeds
    };
    var testNetwork = {
      name: "testnet",
      prefix: "bchtest",
      pubkeyhash: 111,
      privatekey: 239,
      scripthash: 196,
      xpubkey: 70617039,
      xprivkey: 70615956,
      networkMagic: 4108710900,
      port: 18333,
      dnsSeeds
    };
    var regtestNetwork = {
      name: "regtest",
      prefix: "bchreg",
      pubkeyhash: 111,
      privatekey: 239,
      scripthash: 196,
      xpubkey: 70617039,
      xprivkey: 70615956,
      networkMagic: 3669344250,
      port: 18444,
      dnsSeeds: [],
      indexBy: [
        "port",
        "name",
        "prefix",
        "networkMagic"
      ]
    };
    addNetwork(testNetwork);
    addNetwork(regtestNetwork);
    addNetwork(liveNetwork);
    var livenet = get("livenet");
    var regtest = get("regtest");
    var testnet = get("testnet");
    function enableRegtest() {
      testnet.regtestEnabled = true;
    }
    function disableRegtest() {
      testnet.regtestEnabled = false;
    }
    module.exports = {
      add: addNetwork,
      remove: removeNetwork,
      defaultNetwork: livenet,
      livenet,
      mainnet: livenet,
      testnet,
      regtest,
      get,
      enableRegtest,
      disableRegtest
    };
  }
});

// node_modules/bitcore-lib-cash/node_modules/base-x/src/index.js
var require_src = __commonJS({
  "node_modules/bitcore-lib-cash/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (psz < source.length) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// node_modules/bitcore-lib-cash/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/bitcore-lib-cash/node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/bitcore-lib-cash/lib/encoding/base58.js
var require_base58 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/encoding/base58.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var bs58 = require_bs58();
    var buffer = require_buffer();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
    var Base58 = function Base582(obj) {
      if (!(this instanceof Base582)) {
        return new Base582(obj);
      }
      if (Buffer.isBuffer(obj)) {
        var buf = obj;
        this.fromBuffer(buf);
      } else if (typeof obj === "string") {
        var str = obj;
        this.fromString(str);
      } else if (obj) {
        this.set(obj);
      }
    };
    Base58.validCharacters = function validCharacters(chars) {
      if (buffer.Buffer.isBuffer(chars)) {
        chars = chars.toString();
      }
      return _.every(_.map(chars, function(char) {
        return _.includes(ALPHABET, char);
      }));
    };
    Base58.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf || void 0;
      return this;
    };
    Base58.encode = function(buf) {
      if (!buffer.Buffer.isBuffer(buf)) {
        throw new Error("Input should be a buffer");
      }
      return bs58.encode(buf);
    };
    Base58.decode = function(str) {
      if (typeof str !== "string") {
        throw new Error("Input should be a string");
      }
      return Buffer.from(bs58.decode(str));
    };
    Base58.prototype.fromBuffer = function(buf) {
      this.buf = buf;
      return this;
    };
    Base58.prototype.fromString = function(str) {
      var buf = Base58.decode(str);
      this.buf = buf;
      return this;
    };
    Base58.prototype.toBuffer = function() {
      return this.buf;
    };
    Base58.prototype.toString = function() {
      return Base58.encode(this.buf);
    };
    module.exports = Base58;
  }
});

// node_modules/bitcore-lib-cash/lib/encoding/base58check.js
var require_base58check = __commonJS({
  "node_modules/bitcore-lib-cash/lib/encoding/base58check.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var Base58 = require_base58();
    var buffer = require_buffer();
    var sha256sha256 = require_hash2().sha256sha256;
    var Base58Check = function Base58Check2(obj) {
      if (!(this instanceof Base58Check2))
        return new Base58Check2(obj);
      if (Buffer.isBuffer(obj)) {
        var buf = obj;
        this.fromBuffer(buf);
      } else if (typeof obj === "string") {
        var str = obj;
        this.fromString(str);
      } else if (obj) {
        this.set(obj);
      }
    };
    Base58Check.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf || void 0;
      return this;
    };
    Base58Check.validChecksum = function validChecksum(data, checksum) {
      if (_.isString(data)) {
        data = Buffer.from(Base58.decode(data));
      }
      if (_.isString(checksum)) {
        checksum = Buffer.from(Base58.decode(checksum));
      }
      if (!checksum) {
        checksum = data.slice(-4);
        data = data.slice(0, -4);
      }
      return Base58Check.checksum(data).toString("hex") === checksum.toString("hex");
    };
    Base58Check.decode = function(s) {
      if (typeof s !== "string")
        throw new Error("Input must be a string");
      var buf = Buffer.from(Base58.decode(s));
      if (buf.length < 4)
        throw new Error("Input string too short");
      var data = buf.slice(0, -4);
      var csum = buf.slice(-4);
      var hash = sha256sha256(data);
      var hash4 = hash.slice(0, 4);
      if (csum.toString("hex") !== hash4.toString("hex"))
        throw new Error("Checksum mismatch");
      return data;
    };
    Base58Check.checksum = function(buffer2) {
      return sha256sha256(buffer2).slice(0, 4);
    };
    Base58Check.encode = function(buf) {
      if (!Buffer.isBuffer(buf))
        throw new Error("Input must be a buffer");
      var checkedBuf = Buffer.alloc(buf.length + 4);
      var hash = Base58Check.checksum(buf);
      buf.copy(checkedBuf);
      hash.copy(checkedBuf, buf.length);
      return Base58.encode(checkedBuf);
    };
    Base58Check.prototype.fromBuffer = function(buf) {
      this.buf = buf;
      return this;
    };
    Base58Check.prototype.fromString = function(str) {
      var buf = Base58Check.decode(str);
      this.buf = buf;
      return this;
    };
    Base58Check.prototype.toBuffer = function() {
      return this.buf;
    };
    Base58Check.prototype.toString = function() {
      return Base58Check.encode(this.buf);
    };
    module.exports = Base58Check;
  }
});

// node_modules/bitcore-lib-cash/lib/util/base32.js
var require_base32 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/util/base32.js"(exports, module) {
    "use strict";
    var $ = require_preconditions();
    var CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var CHARSET_INVERSE_INDEX = {
      "q": 0,
      "p": 1,
      "z": 2,
      "r": 3,
      "y": 4,
      "9": 5,
      "x": 6,
      "8": 7,
      "g": 8,
      "f": 9,
      "2": 10,
      "t": 11,
      "v": 12,
      "d": 13,
      "w": 14,
      "0": 15,
      "s": 16,
      "3": 17,
      "j": 18,
      "n": 19,
      "5": 20,
      "4": 21,
      "k": 22,
      "h": 23,
      "c": 24,
      "e": 25,
      "6": 26,
      "m": 27,
      "u": 28,
      "a": 29,
      "7": 30,
      "l": 31
    };
    function encode(data) {
      $.checkArgument(data instanceof Array, "Must be Array");
      var base32 = "";
      for (var i = 0; i < data.length; i++) {
        var value = data[i];
        $.checkArgument(0 <= value && value < 32, "value " + value);
        base32 += CHARSET[value];
      }
      return base32;
    }
    function decode(base32) {
      $.checkArgument(typeof base32 === "string", "Must be base32-encoded string");
      var data = [];
      for (var i = 0; i < base32.length; i++) {
        var value = base32[i];
        $.checkArgument(value in CHARSET_INVERSE_INDEX, "value " + value);
        data.push(CHARSET_INVERSE_INDEX[value]);
      }
      return data;
    }
    module.exports = {
      encode,
      decode
    };
  }
});

// node_modules/bitcore-lib-cash/lib/util/convertBits.js
var require_convertBits = __commonJS({
  "node_modules/bitcore-lib-cash/lib/util/convertBits.js"(exports, module) {
    "use strict";
    var $ = require_preconditions();
    module.exports = function(data, from, to, strict) {
      strict = strict || false;
      var accumulator = 0;
      var bits = 0;
      var result = [];
      var mask = (1 << to) - 1;
      for (var i = 0; i < data.length; i++) {
        var value = data[i];
        $.checkArgument(!(value < 0 || value >> from !== 0), "value " + value);
        accumulator = accumulator << from | value;
        bits += from;
        while (bits >= to) {
          bits -= to;
          result.push(accumulator >> bits & mask);
        }
      }
      if (!strict) {
        if (bits > 0) {
          result.push(accumulator << to - bits & mask);
        }
      } else {
        $.checkState(!(bits >= from || accumulator << to - bits & mask), "Conversion requires padding but strict mode was used");
      }
      return result;
    };
  }
});

// node_modules/bitcore-lib-cash/lib/encoding/bufferreader.js
var require_bufferreader = __commonJS({
  "node_modules/bitcore-lib-cash/lib/encoding/bufferreader.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var BN = require_bn2();
    var BufferReader = function BufferReader2(buf) {
      if (!(this instanceof BufferReader2)) {
        return new BufferReader2(buf);
      }
      if (_.isUndefined(buf)) {
        return;
      }
      if (Buffer.isBuffer(buf)) {
        this.set({
          buf
        });
      } else if (_.isString(buf)) {
        var b = Buffer.from(buf, "hex");
        if (b.length * 2 != buf.length)
          throw new TypeError("Invalid hex string");
        this.set({
          buf: b
        });
      } else if (_.isObject(buf)) {
        var obj = buf;
        this.set(obj);
      } else {
        throw new TypeError("Unrecognized argument for BufferReader");
      }
    };
    BufferReader.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf || void 0;
      this.pos = obj.pos || this.pos || 0;
      return this;
    };
    BufferReader.prototype.eof = function() {
      return this.pos >= this.buf.length;
    };
    BufferReader.prototype.finished = BufferReader.prototype.eof;
    BufferReader.prototype.read = function(len) {
      $.checkArgument(!_.isUndefined(len), "Must specify a length");
      var buf = this.buf.slice(this.pos, this.pos + len);
      this.pos = this.pos + len;
      return buf;
    };
    BufferReader.prototype.readAll = function() {
      var buf = this.buf.slice(this.pos, this.buf.length);
      this.pos = this.buf.length;
      return buf;
    };
    BufferReader.prototype.readUInt8 = function() {
      var val = this.buf.readUInt8(this.pos);
      this.pos = this.pos + 1;
      return val;
    };
    BufferReader.prototype.readUInt16BE = function() {
      var val = this.buf.readUInt16BE(this.pos);
      this.pos = this.pos + 2;
      return val;
    };
    BufferReader.prototype.readUInt16LE = function() {
      var val = this.buf.readUInt16LE(this.pos);
      this.pos = this.pos + 2;
      return val;
    };
    BufferReader.prototype.readUInt32BE = function() {
      var val = this.buf.readUInt32BE(this.pos);
      this.pos = this.pos + 4;
      return val;
    };
    BufferReader.prototype.readUInt32LE = function() {
      var val = this.buf.readUInt32LE(this.pos);
      this.pos = this.pos + 4;
      return val;
    };
    BufferReader.prototype.readInt32LE = function() {
      var val = this.buf.readInt32LE(this.pos);
      this.pos = this.pos + 4;
      return val;
    };
    BufferReader.prototype.readUInt64BEBN = function() {
      var buf = this.buf.slice(this.pos, this.pos + 8);
      var bn = BN.fromBuffer(buf);
      this.pos = this.pos + 8;
      return bn;
    };
    BufferReader.prototype.readUInt64LEBN = function() {
      var second = this.buf.readUInt32LE(this.pos);
      var first = this.buf.readUInt32LE(this.pos + 4);
      var combined = first * 4294967296 + second;
      var bn;
      if (combined <= 9007199254740991) {
        bn = new BN(combined);
      } else {
        var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);
        bn = new BN(data, 10, "le");
      }
      this.pos = this.pos + 8;
      return bn;
    };
    BufferReader.prototype.readVarintNum = function() {
      var first = this.readUInt8();
      switch (first) {
        case 253:
          return this.readUInt16LE();
        case 254:
          return this.readUInt32LE();
        case 255:
          var bn = this.readUInt64LEBN();
          var n = bn.toNumber();
          if (n <= Math.pow(2, 53)) {
            return n;
          } else {
            throw new Error("number too large to retain precision - use readVarintBN");
          }
          break;
        default:
          return first;
      }
    };
    BufferReader.prototype.readVarLengthBuffer = function() {
      var len = this.readVarintNum();
      var buf = this.read(len);
      $.checkState(buf.length === len, "Invalid length while reading varlength buffer. Expected to read: " + len + " and read " + buf.length);
      return buf;
    };
    BufferReader.prototype.readVarintBuf = function() {
      var first = this.buf.readUInt8(this.pos);
      switch (first) {
        case 253:
          return this.read(1 + 2);
        case 254:
          return this.read(1 + 4);
        case 255:
          return this.read(1 + 8);
        default:
          return this.read(1);
      }
    };
    BufferReader.prototype.readVarintBN = function() {
      var first = this.readUInt8();
      switch (first) {
        case 253:
          return new BN(this.readUInt16LE());
        case 254:
          return new BN(this.readUInt32LE());
        case 255:
          return this.readUInt64LEBN();
        default:
          return new BN(first);
      }
    };
    BufferReader.prototype.reverse = function() {
      var buf = Buffer.alloc(this.buf.length);
      for (var i = 0; i < buf.length; i++) {
        buf[i] = this.buf[this.buf.length - 1 - i];
      }
      this.buf = buf;
      return this;
    };
    BufferReader.prototype.readReverse = function(len) {
      if (_.isUndefined(len)) {
        len = this.buf.length;
      }
      var buf = this.buf.slice(this.pos, this.pos + len);
      this.pos = this.pos + len;
      return BufferUtil.reverse(buf);
    };
    module.exports = BufferReader;
  }
});

// node_modules/bitcore-lib-cash/lib/encoding/bufferwriter.js
var require_bufferwriter = __commonJS({
  "node_modules/bitcore-lib-cash/lib/encoding/bufferwriter.js"(exports, module) {
    "use strict";
    var bufferUtil = require_buffer3();
    var assert = require_assert();
    var BufferWriter = function BufferWriter2(obj) {
      if (!(this instanceof BufferWriter2))
        return new BufferWriter2(obj);
      this.bufLen = 0;
      if (obj)
        this.set(obj);
      else
        this.bufs = [];
    };
    BufferWriter.prototype.set = function(obj) {
      this.bufs = obj.bufs || this.bufs || [];
      this.bufLen = this.bufs.reduce(function(prev, buf) {
        return prev + buf.length;
      }, 0);
      return this;
    };
    BufferWriter.prototype.toBuffer = function() {
      return this.concat();
    };
    BufferWriter.prototype.concat = function() {
      return Buffer.concat(this.bufs, this.bufLen);
    };
    BufferWriter.prototype.write = function(buf) {
      assert(bufferUtil.isBuffer(buf));
      this.bufs.push(buf);
      this.bufLen += buf.length;
      return this;
    };
    BufferWriter.prototype.writeReverse = function(buf) {
      assert(bufferUtil.isBuffer(buf));
      this.bufs.push(bufferUtil.reverse(buf));
      this.bufLen += buf.length;
      return this;
    };
    BufferWriter.prototype.writeUInt8 = function(n) {
      var buf = Buffer.alloc(1);
      buf.writeUInt8(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt16BE = function(n) {
      var buf = Buffer.alloc(2);
      buf.writeUInt16BE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt16LE = function(n) {
      var buf = Buffer.alloc(2);
      buf.writeUInt16LE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt32BE = function(n) {
      var buf = Buffer.alloc(4);
      buf.writeUInt32BE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeInt32LE = function(n) {
      var buf = Buffer.alloc(4);
      buf.writeInt32LE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt32LE = function(n) {
      var buf = Buffer.alloc(4);
      buf.writeUInt32LE(n, 0);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt64BEBN = function(bn) {
      var buf = bn.toBuffer({ size: 8 });
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeUInt64LEBN = function(bn) {
      var buf = bn.toBuffer({ size: 8 });
      this.writeReverse(buf);
      return this;
    };
    BufferWriter.prototype.writeVarintNum = function(n) {
      var buf = BufferWriter.varintBufNum(n);
      this.write(buf);
      return this;
    };
    BufferWriter.prototype.writeVarintBN = function(bn) {
      var buf = BufferWriter.varintBufBN(bn);
      this.write(buf);
      return this;
    };
    BufferWriter.varintBufNum = function(n) {
      var buf = void 0;
      if (n < 253) {
        buf = Buffer.alloc(1);
        buf.writeUInt8(n, 0);
      } else if (n < 65536) {
        buf = Buffer.alloc(1 + 2);
        buf.writeUInt8(253, 0);
        buf.writeUInt16LE(n, 1);
      } else if (n < 4294967296) {
        buf = Buffer.alloc(1 + 4);
        buf.writeUInt8(254, 0);
        buf.writeUInt32LE(n, 1);
      } else {
        buf = Buffer.alloc(1 + 8);
        buf.writeUInt8(255, 0);
        buf.writeInt32LE(n & -1, 1);
        buf.writeUInt32LE(Math.floor(n / 4294967296), 5);
      }
      return buf;
    };
    BufferWriter.varintBufBN = function(bn) {
      var buf = void 0;
      var n = bn.toNumber();
      if (n < 253) {
        buf = Buffer.alloc(1);
        buf.writeUInt8(n, 0);
      } else if (n < 65536) {
        buf = Buffer.alloc(1 + 2);
        buf.writeUInt8(253, 0);
        buf.writeUInt16LE(n, 1);
      } else if (n < 4294967296) {
        buf = Buffer.alloc(1 + 4);
        buf.writeUInt8(254, 0);
        buf.writeUInt32LE(n, 1);
      } else {
        var bw = new BufferWriter();
        bw.writeUInt8(255);
        bw.writeUInt64LEBN(bn);
        var buf = bw.concat();
      }
      return buf;
    };
    module.exports = BufferWriter;
  }
});

// node_modules/bitcore-lib-cash/lib/opcode.js
var require_opcode = __commonJS({
  "node_modules/bitcore-lib-cash/lib/opcode.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    function Opcode(num) {
      if (!(this instanceof Opcode)) {
        return new Opcode(num);
      }
      var value;
      if (_.isNumber(num)) {
        value = num;
      } else if (_.isString(num)) {
        value = Opcode.map[num];
      } else {
        throw new TypeError('Unrecognized num type: "' + typeof num + '" for Opcode');
      }
      JSUtil.defineImmutable(this, {
        num: value
      });
      return this;
    }
    Opcode.fromBuffer = function(buf) {
      $.checkArgument(BufferUtil.isBuffer(buf));
      return new Opcode(Number("0x" + buf.toString("hex")));
    };
    Opcode.fromNumber = function(num) {
      $.checkArgument(_.isNumber(num));
      return new Opcode(num);
    };
    Opcode.fromString = function(str) {
      $.checkArgument(_.isString(str));
      var value = Opcode.map[str];
      if (typeof value === "undefined") {
        throw new TypeError("Invalid opcodestr");
      }
      return new Opcode(value);
    };
    Opcode.prototype.toHex = function() {
      return this.num.toString(16);
    };
    Opcode.prototype.toBuffer = function() {
      return Buffer.from(this.toHex(), "hex");
    };
    Opcode.prototype.toNumber = function() {
      return this.num;
    };
    Opcode.prototype.toString = function() {
      var str = Opcode.reverseMap[this.num];
      if (typeof str === "undefined") {
        throw new Error("Opcode does not have a string representation");
      }
      return str;
    };
    Opcode.smallInt = function(n) {
      $.checkArgument(_.isNumber(n), "Invalid Argument: n should be number");
      $.checkArgument(n >= 0 && n <= 16, "Invalid Argument: n must be between 0 and 16");
      if (n === 0) {
        return Opcode("OP_0");
      }
      return new Opcode(Opcode.map.OP_1 + n - 1);
    };
    Opcode.map = {
      // push value
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      // control
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      // stack ops
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      // splice ops
      OP_CAT: 126,
      OP_SPLIT: 127,
      OP_NUM2BIN: 128,
      OP_BIN2NUM: 129,
      OP_SIZE: 130,
      // bit logic
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      // numeric
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      // crypto
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      // timelocks
      OP_NOP2: 177,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_NOP3: 178,
      OP_CHECKSEQUENCEVERIFY: 178,
      // expansion
      OP_NOP1: 176,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      // More crypto
      OP_CHECKDATASIG: 186,
      OP_CHECKDATASIGVERIFY: 187,
      OP_REVERSEBYTES: 188,
      OP_PREFIX_BEGIN: 240,
      OP_PREFIX_END: 241,
      // template matching params
      OP_SMALLINTEGER: 250,
      OP_PUBKEYS: 251,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255,
      // introspection
      OP_INPUTINDEX: 192,
      OP_ACTIVEBYTECODE: 193,
      OP_TXVERSION: 194,
      OP_TXINPUTCOUNT: 195,
      OP_TXOUTPUTCOUNT: 196,
      OP_TXLOCKTIME: 197,
      OP_UTXOVALUE: 198,
      OP_UTXOBYTECODE: 199,
      OP_OUTPOINTTXHASH: 200,
      OP_OUTPOINTINDEX: 201,
      OP_INPUTBYTECODE: 202,
      OP_INPUTSEQUENCENUMBER: 203,
      OP_OUTPUTVALUE: 204,
      OP_OUTPUTBYTECODE: 205,
      // introspection of tokens
      OP_UTXOTOKENCATEGORY: 206,
      OP_UTXOTOKENCOMMITMENT: 207,
      OP_UTXOTOKENAMOUNT: 208,
      OP_OUTPUTTOKENCATEGORY: 209,
      OP_OUTPUTTOKENCOMMITMENT: 210,
      OP_OUTPUTTOKENAMOUNT: 211,
      OP_RESERVED3: 212,
      OP_RESERVED4: 213
    };
    Opcode.reverseMap = [];
    for (k in Opcode.map) {
      Opcode.reverseMap[Opcode.map[k]] = k;
    }
    var k;
    _.extend(Opcode, Opcode.map);
    Opcode.isSmallIntOp = function(opcode) {
      if (opcode instanceof Opcode) {
        opcode = opcode.toNumber();
      }
      return opcode === Opcode.map.OP_0 || opcode >= Opcode.map.OP_1 && opcode <= Opcode.map.OP_16;
    };
    Opcode.prototype.inspect = function() {
      return "<Opcode: " + this.toString() + ", hex: " + this.toHex() + ", decimal: " + this.num + ">";
    };
    module.exports = Opcode;
  }
});

// node_modules/bitcore-lib-cash/lib/script/escrow.js
var require_escrow = __commonJS({
  "node_modules/bitcore-lib-cash/lib/script/escrow.js"(exports, module) {
    var _ = require_lodash();
    var Hash = require_hash2();
    var Opcode = require_opcode();
    var PublicKey = require_publickey2();
    var Escrow = {};
    var pushOpcodeFromNumber = function(n) {
      return {
        0: Opcode.OP_0,
        1: Opcode.OP_1,
        2: Opcode.OP_2,
        3: Opcode.OP_3,
        4: Opcode.OP_4,
        5: Opcode.OP_5,
        6: Opcode.OP_6,
        7: Opcode.OP_7,
        8: Opcode.OP_8,
        9: Opcode.OP_9,
        10: Opcode.OP_10,
        11: Opcode.OP_11,
        12: Opcode.OP_12,
        13: Opcode.OP_13,
        14: Opcode.OP_14,
        15: Opcode.OP_15,
        16: Opcode.OP_16
      }[n];
    };
    var getNumMerkleLevels = function(numPublicKeys) {
      return Math.ceil(Math.log2(numPublicKeys));
    };
    Escrow.getMerkleRoot = function getMerkleRoot(hashes) {
      if (hashes.length === 1) {
        return hashes[0];
      }
      const parentHashes = _.chunk(hashes, 2).map((hashPair) => Hash.sha256ripemd160(Buffer.concat(hashPair)));
      return getMerkleRoot(parentHashes);
    };
    Escrow.generateMerkleRootFromPublicKeys = function(publicKeys) {
      const numLevels = getNumMerkleLevels(publicKeys.length);
      const numItems = Math.pow(2, numLevels);
      const sortedPublicKeys = publicKeys.map((publicKey) => publicKey.toString("hex")).sort().map((publicKeyString) => PublicKey.fromString(publicKeyString).toBuffer());
      const zeros = Array(numItems - publicKeys.length).fill(Buffer.alloc(0));
      const leaves = sortedPublicKeys.concat(zeros).map((value) => Hash.sha256ripemd160(value));
      return Escrow.getMerkleRoot(leaves);
    };
    var generateSingleInputPublicKeyValidationOperations = function(inputPublicKey) {
      const inputPublicKeyHash = Hash.sha256ripemd160(inputPublicKey.toBuffer());
      return [Opcode.OP_DUP, Opcode.OP_HASH160, inputPublicKeyHash, Opcode.OP_EQUALVERIFY];
    };
    var generateMerkleBasedInputPublicKeyValidationOperations = function(inputPublicKeys) {
      const numLevels = getNumMerkleLevels(inputPublicKeys.length);
      const rootHash = Escrow.generateMerkleRootFromPublicKeys(inputPublicKeys);
      const merkleTreeConstructionOperationsForEachLevel = Array(numLevels).fill([
        Opcode.OP_FROMALTSTACK,
        Opcode.OP_IF,
        Opcode.OP_SWAP,
        Opcode.OP_ENDIF,
        Opcode.OP_CAT,
        Opcode.OP_HASH160
      ]).reduce((arr, item) => arr.concat(item), []);
      return [
        ...Array(numLevels).fill(Opcode.OP_TOALTSTACK),
        pushOpcodeFromNumber(numLevels),
        Opcode.OP_PICK,
        Opcode.OP_HASH160,
        ...merkleTreeConstructionOperationsForEachLevel,
        rootHash,
        Opcode.OP_EQUALVERIFY
      ];
    };
    Escrow.generateInputPublicKeyValidationOperations = function(inputPublicKeys) {
      if (inputPublicKeys.length === 1) {
        return generateSingleInputPublicKeyValidationOperations(inputPublicKeys[0]);
      }
      return generateMerkleBasedInputPublicKeyValidationOperations(inputPublicKeys);
    };
    Escrow.generateRedeemScriptOperations = function(inputPublicKeys, reclaimPublicKey) {
      const checkCustomerReclaimPublicKey = [
        Opcode.OP_DUP,
        Opcode.OP_HASH160,
        Hash.sha256ripemd160(reclaimPublicKey.toBuffer()),
        Opcode.OP_EQUAL,
        Opcode.OP_IF,
        Opcode.OP_CHECKSIG,
        Opcode.OP_ELSE
      ];
      const checkInputPublicKey = Escrow.generateInputPublicKeyValidationOperations(inputPublicKeys);
      const ensureTransactionsAreUnique = [
        Opcode.OP_OVER,
        Opcode.OP_4,
        Opcode.OP_PICK,
        Opcode.OP_EQUAL,
        Opcode.OP_NOT,
        Opcode.OP_VERIFY
      ];
      const ensureBothSignaturesAreValid = [
        Opcode.OP_DUP,
        Opcode.OP_TOALTSTACK,
        Opcode.OP_CHECKDATASIGVERIFY,
        Opcode.OP_FROMALTSTACK,
        Opcode.OP_CHECKDATASIG,
        Opcode.OP_ENDIF
      ];
      const allOperations = [
        ...checkCustomerReclaimPublicKey,
        ...checkInputPublicKey,
        ...ensureTransactionsAreUnique,
        ...ensureBothSignaturesAreValid
      ];
      return allOperations;
    };
    module.exports = Escrow;
  }
});

// node_modules/bitcore-lib-cash/lib/script/script.js
var require_script = __commonJS({
  "node_modules/bitcore-lib-cash/lib/script/script.js"(exports, module) {
    var Address = require_address();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash = require_hash2();
    var Opcode = require_opcode();
    var PublicKey = require_publickey2();
    var Signature = require_signature3();
    var Networks = require_networks();
    var $ = require_preconditions();
    var _ = require_lodash();
    var errors = require_errors();
    var buffer = require_buffer();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var Escrow = require_escrow();
    var Script = function Script2(from) {
      if (!(this instanceof Script2)) {
        return new Script2(from);
      }
      this.chunks = [];
      if (BufferUtil.isBuffer(from)) {
        return Script2.fromBuffer(from);
      } else if (from instanceof Address) {
        return Script2.fromAddress(from);
      } else if (from instanceof Script2) {
        return Script2.fromBuffer(from.toBuffer());
      } else if (_.isString(from)) {
        return Script2.fromString(from);
      } else if (_.isObject(from) && _.isArray(from.chunks)) {
        this.set(from);
      }
    };
    Script.prototype.set = function(obj) {
      $.checkArgument(_.isObject(obj));
      $.checkArgument(_.isArray(obj.chunks));
      this.chunks = obj.chunks;
      return this;
    };
    Script.fromBuffer = function(buffer2) {
      var script = new Script();
      script.chunks = [];
      var br = new BufferReader(buffer2);
      while (!br.finished()) {
        try {
          var opcodenum = br.readUInt8();
          var len, buf;
          if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
            len = opcodenum;
            script.chunks.push({
              buf: br.read(len),
              len,
              opcodenum
            });
          } else if (opcodenum === Opcode.OP_PUSHDATA1) {
            len = br.readUInt8();
            buf = br.read(len);
            script.chunks.push({
              buf,
              len,
              opcodenum
            });
          } else if (opcodenum === Opcode.OP_PUSHDATA2) {
            len = br.readUInt16LE();
            buf = br.read(len);
            script.chunks.push({
              buf,
              len,
              opcodenum
            });
          } else if (opcodenum === Opcode.OP_PUSHDATA4) {
            len = br.readUInt32LE();
            buf = br.read(len);
            script.chunks.push({
              buf,
              len,
              opcodenum
            });
          } else {
            script.chunks.push({
              opcodenum
            });
          }
        } catch (e) {
          if (e instanceof RangeError) {
            throw new errors.Script.InvalidBuffer(buffer2.toString("hex"));
          }
          throw e;
        }
      }
      return script;
    };
    Script.prototype.toBuffer = function() {
      var bw = new BufferWriter();
      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        var opcodenum = chunk.opcodenum;
        bw.writeUInt8(chunk.opcodenum);
        if (chunk.buf) {
          if (opcodenum < Opcode.OP_PUSHDATA1) {
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode.OP_PUSHDATA1) {
            bw.writeUInt8(chunk.len);
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode.OP_PUSHDATA2) {
            bw.writeUInt16LE(chunk.len);
            bw.write(chunk.buf);
          } else if (opcodenum === Opcode.OP_PUSHDATA4) {
            bw.writeUInt32LE(chunk.len);
            bw.write(chunk.buf);
          }
        }
      }
      return bw.concat();
    };
    Script.fromASM = function(str) {
      var script = new Script();
      script.chunks = [];
      var tokens = str.split(" ");
      var i = 0;
      while (i < tokens.length) {
        var token = tokens[i];
        var opcode = Opcode(token);
        var opcodenum = opcode.toNumber();
        if (_.isUndefined(opcodenum)) {
          var buf = Buffer.from(tokens[i], "hex");
          var opcodenum;
          var len = buf.length;
          if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
            opcodenum = len;
          } else if (len < Math.pow(2, 8)) {
            opcodenum = Opcode.OP_PUSHDATA1;
          } else if (len < Math.pow(2, 16)) {
            opcodenum = Opcode.OP_PUSHDATA2;
          } else if (len < Math.pow(2, 32)) {
            opcodenum = Opcode.OP_PUSHDATA4;
          }
          script.chunks.push({
            buf,
            len: buf.length,
            opcodenum
          });
          i = i + 1;
        } else {
          script.chunks.push({
            opcodenum
          });
          i = i + 1;
        }
      }
      return script;
    };
    Script.fromHex = function(str) {
      return new Script(Buffer.from(str, "hex"));
    };
    Script.fromString = function(str) {
      if (JSUtil.isHexa(str) || str.length === 0) {
        return new Script(Buffer.from(str, "hex"));
      }
      var script = new Script();
      script.chunks = [];
      var tokens = str.split(" ");
      var i = 0;
      while (i < tokens.length) {
        var token = tokens[i];
        var opcode = Opcode(token);
        var opcodenum = opcode.toNumber();
        if (_.isUndefined(opcodenum)) {
          opcodenum = parseInt(token);
          if (opcodenum > 0 && opcodenum < Opcode.OP_PUSHDATA1) {
            script.chunks.push({
              buf: Buffer.from(tokens[i + 1].slice(2), "hex"),
              len: opcodenum,
              opcodenum
            });
            i = i + 2;
          } else {
            throw new Error("Invalid script: " + JSON.stringify(str));
          }
        } else if (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4) {
          if (tokens[i + 2].slice(0, 2) !== "0x") {
            throw new Error("Pushdata data must start with 0x");
          }
          script.chunks.push({
            buf: Buffer.from(tokens[i + 2].slice(2), "hex"),
            len: parseInt(tokens[i + 1]),
            opcodenum
          });
          i = i + 3;
        } else {
          script.chunks.push({
            opcodenum
          });
          i = i + 1;
        }
      }
      return script;
    };
    Script.prototype._chunkToString = function(chunk, type) {
      var opcodenum = chunk.opcodenum;
      var asm = type === "asm";
      var str = "";
      if (!chunk.buf) {
        if (typeof Opcode.reverseMap[opcodenum] !== "undefined") {
          if (asm) {
            if (opcodenum === 0) {
              str = str + " 0";
            } else if (opcodenum === 79) {
              str = str + " -1";
            } else {
              str = str + " " + Opcode(opcodenum).toString();
            }
          } else {
            str = str + " " + Opcode(opcodenum).toString();
          }
        } else {
          var numstr = opcodenum.toString(16);
          if (numstr.length % 2 !== 0) {
            numstr = "0" + numstr;
          }
          if (asm) {
            str = str + " " + numstr;
          } else {
            str = str + " 0x" + numstr;
          }
        }
      } else {
        if (!asm && (opcodenum === Opcode.OP_PUSHDATA1 || opcodenum === Opcode.OP_PUSHDATA2 || opcodenum === Opcode.OP_PUSHDATA4)) {
          str = str + " " + Opcode(opcodenum).toString();
        }
        if (chunk.len > 0) {
          if (asm) {
            str = str + " " + chunk.buf.toString("hex");
          } else {
            str = str + " " + chunk.len + " 0x" + chunk.buf.toString("hex");
          }
        }
      }
      return str;
    };
    Script.prototype.toASM = function() {
      var str = "";
      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        str += this._chunkToString(chunk, "asm");
      }
      return str.substr(1);
    };
    Script.prototype.toString = function() {
      var str = "";
      for (var i = 0; i < this.chunks.length; i++) {
        var chunk = this.chunks[i];
        str += this._chunkToString(chunk);
      }
      return str.substr(1);
    };
    Script.prototype.toHex = function() {
      return this.toBuffer().toString("hex");
    };
    Script.prototype.inspect = function() {
      return "<Script: " + this.toString() + ">";
    };
    Script.prototype.isPublicKeyHashOut = function() {
      return !!(this.chunks.length === 5 && this.chunks[0].opcodenum === Opcode.OP_DUP && this.chunks[1].opcodenum === Opcode.OP_HASH160 && this.chunks[2].buf && this.chunks[2].buf.length === 20 && this.chunks[3].opcodenum === Opcode.OP_EQUALVERIFY && this.chunks[4].opcodenum === Opcode.OP_CHECKSIG);
    };
    Script.prototype.isPublicKeyHashIn = function() {
      if (this.chunks.length === 2) {
        var signatureBuf = this.chunks[0].buf;
        var pubkeyBuf = this.chunks[1].buf;
        if (signatureBuf && signatureBuf.length && pubkeyBuf && pubkeyBuf.length) {
          var version = pubkeyBuf[0];
          if ((version === 4 || version === 6 || version === 7) && pubkeyBuf.length === 65) {
            return true;
          } else if ((version === 3 || version === 2) && pubkeyBuf.length === 33) {
            return true;
          }
        }
      }
      return false;
    };
    Script.prototype.getPublicKey = function() {
      $.checkState(this.isPublicKeyOut() || this.isPublicKeyHashIn(), "Can't retrieve PublicKey from a non-PK output or non-PKH input");
      return this.isPublicKeyOut() ? this.chunks[0].buf : this.chunks[1].buf;
    };
    Script.prototype.getPublicKeyHash = function() {
      $.checkState(this.isPublicKeyHashOut(), "Can't retrieve PublicKeyHash from a non-PKH output");
      return this.chunks[2].buf;
    };
    Script.prototype.isPublicKeyOut = function() {
      if (this.chunks.length === 2 && this.chunks[0].buf && this.chunks[0].buf.length && this.chunks[1].opcodenum === Opcode.OP_CHECKSIG) {
        var pubkeyBuf = this.chunks[0].buf;
        var version = pubkeyBuf[0];
        var isVersion = false;
        if ((version === 4 || version === 6 || version === 7) && pubkeyBuf.length === 65) {
          isVersion = true;
        } else if ((version === 3 || version === 2) && pubkeyBuf.length === 33) {
          isVersion = true;
        }
        if (isVersion) {
          return PublicKey.isValid(pubkeyBuf);
        }
      }
      return false;
    };
    Script.prototype.isPublicKeyIn = function() {
      if (this.chunks.length === 1) {
        var signatureBuf = this.chunks[0].buf;
        if (signatureBuf && signatureBuf.length && signatureBuf[0] === 48) {
          return true;
        }
      }
      return false;
    };
    Script.prototype.isWitnessProgram = function(values) {
      if (!values) {
        values = {};
      }
      var buf = this.toBuffer();
      if (buf.length < 4 || buf.length > 42) {
        return false;
      }
      if (buf[0] !== Opcode.OP_0 && !(buf[0] >= Opcode.OP_1 && buf[0] <= Opcode.OP_16)) {
        return false;
      }
      if (buf.length === buf[1] + 2) {
        values.version = buf[0];
        values.program = buf.slice(2, buf.length);
        return true;
      }
      return false;
    };
    Script.prototype.isScriptHashOut = function(fEnableP2SH32) {
      var buf = this.toBuffer();
      const isP2SH20 = buf.length === 23 && buf[0] === Opcode.OP_HASH160 && buf[1] === 20 && buf[buf.length - 1] === Opcode.OP_EQUAL;
      if (isP2SH20) {
        return true;
      }
      if (!fEnableP2SH32) {
        return false;
      }
      const isP2SH32 = buf.length === 35 && buf[0] === Opcode.OP_HASH256 && buf[1] === 32 && buf[buf.length - 1] === Opcode.OP_EQUAL;
      return isP2SH32;
    };
    Script.prototype.isScriptHashIn = function() {
      if (this.chunks.length <= 1) {
        return false;
      }
      var redeemChunk = this.chunks[this.chunks.length - 1];
      var redeemBuf = redeemChunk.buf;
      if (!redeemBuf) {
        return false;
      }
      var redeemScript;
      try {
        redeemScript = Script.fromBuffer(redeemBuf);
      } catch (e) {
        if (e instanceof errors.Script.InvalidBuffer) {
          return false;
        }
        throw e;
      }
      var type = redeemScript.classify();
      return type !== Script.types.UNKNOWN;
    };
    Script.prototype.isMultisigOut = function() {
      return this.chunks.length > 3 && Opcode.isSmallIntOp(this.chunks[0].opcodenum) && this.chunks.slice(1, this.chunks.length - 2).every(function(obj) {
        return obj.buf && BufferUtil.isBuffer(obj.buf);
      }) && Opcode.isSmallIntOp(this.chunks[this.chunks.length - 2].opcodenum) && this.chunks[this.chunks.length - 1].opcodenum === Opcode.OP_CHECKMULTISIG;
    };
    Script.prototype.isMultisigIn = function() {
      return this.chunks.length >= 2 && this.chunks[0].opcodenum === 0 && this.chunks.slice(1, this.chunks.length).every(function(obj) {
        return obj.buf && BufferUtil.isBuffer(obj.buf) && Signature.isTxDER(obj.buf);
      });
    };
    Script.prototype.isDataOut = function() {
      var step1 = this.chunks.length >= 1 && this.chunks[0].opcodenum === Opcode.OP_RETURN && this.toBuffer().length <= 223;
      if (!step1) return false;
      var chunks = this.chunks.slice(1);
      var script2 = new Script({ chunks });
      return script2.isPushOnly();
    };
    Script.prototype.getData = function() {
      if (this.isDataOut() || this.isScriptHashOut()) {
        if (_.isUndefined(this.chunks[1])) {
          return Buffer.alloc(0);
        } else {
          return Buffer.from(this.chunks[1].buf);
        }
      }
      if (this.isPublicKeyHashOut()) {
        return Buffer.from(this.chunks[2].buf);
      }
      throw new Error("Unrecognized script type to get data from");
    };
    Script.prototype.isPushOnly = function() {
      return _.every(this.chunks, function(chunk) {
        return chunk.opcodenum <= Opcode.OP_16 || chunk.opcodenum === Opcode.OP_PUSHDATA1 || chunk.opcodenum === Opcode.OP_PUSHDATA2 || chunk.opcodenum === Opcode.OP_PUSHDATA4;
      });
    };
    Script.types = {};
    Script.types.UNKNOWN = "Unknown";
    Script.types.PUBKEY_OUT = "Pay to public key";
    Script.types.PUBKEY_IN = "Spend from public key";
    Script.types.PUBKEYHASH_OUT = "Pay to public key hash";
    Script.types.PUBKEYHASH_IN = "Spend from public key hash";
    Script.types.SCRIPTHASH_OUT = "Pay to script hash";
    Script.types.SCRIPTHASH_IN = "Spend from script hash";
    Script.types.MULTISIG_OUT = "Pay to multisig";
    Script.types.MULTISIG_IN = "Spend from multisig";
    Script.types.DATA_OUT = "Data push";
    Script.OP_RETURN_STANDARD_SIZE = 220;
    Script.prototype.classify = function() {
      if (this._isInput) {
        return this.classifyInput();
      } else if (this._isOutput) {
        return this.classifyOutput();
      } else {
        var outputType = this.classifyOutput();
        return outputType != Script.types.UNKNOWN ? outputType : this.classifyInput();
      }
    };
    Script.outputIdentifiers = {};
    Script.outputIdentifiers.PUBKEY_OUT = Script.prototype.isPublicKeyOut;
    Script.outputIdentifiers.PUBKEYHASH_OUT = Script.prototype.isPublicKeyHashOut;
    Script.outputIdentifiers.MULTISIG_OUT = Script.prototype.isMultisigOut;
    Script.outputIdentifiers.SCRIPTHASH_OUT = Script.prototype.isScriptHashOut;
    Script.outputIdentifiers.DATA_OUT = Script.prototype.isDataOut;
    Script.prototype.classifyOutput = function() {
      for (var type in Script.outputIdentifiers) {
        if (Script.outputIdentifiers[type].bind(this)()) {
          return Script.types[type];
        }
      }
      return Script.types.UNKNOWN;
    };
    Script.inputIdentifiers = {};
    Script.inputIdentifiers.PUBKEY_IN = Script.prototype.isPublicKeyIn;
    Script.inputIdentifiers.PUBKEYHASH_IN = Script.prototype.isPublicKeyHashIn;
    Script.inputIdentifiers.MULTISIG_IN = Script.prototype.isMultisigIn;
    Script.inputIdentifiers.SCRIPTHASH_IN = Script.prototype.isScriptHashIn;
    Script.prototype.classifyInput = function() {
      for (var type in Script.inputIdentifiers) {
        if (Script.inputIdentifiers[type].bind(this)()) {
          return Script.types[type];
        }
      }
      return Script.types.UNKNOWN;
    };
    Script.prototype.isStandard = function() {
      return this.classify() !== Script.types.UNKNOWN;
    };
    Script.prototype.prepend = function(obj) {
      this._addByType(obj, true);
      return this;
    };
    Script.prototype.equals = function(script) {
      $.checkState(script instanceof Script, "Must provide another script");
      if (this.chunks.length !== script.chunks.length) {
        return false;
      }
      var i;
      for (i = 0; i < this.chunks.length; i++) {
        if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.isBuffer(script.chunks[i].buf)) {
          return false;
        }
        if (BufferUtil.isBuffer(this.chunks[i].buf) && !BufferUtil.equals(this.chunks[i].buf, script.chunks[i].buf)) {
          return false;
        } else if (this.chunks[i].opcodenum !== script.chunks[i].opcodenum) {
          return false;
        }
      }
      return true;
    };
    Script.prototype.add = function(obj) {
      this._addByType(obj, false);
      return this;
    };
    Script.prototype._addByType = function(obj, prepend) {
      if (typeof obj === "string") {
        this._addOpcode(obj, prepend);
      } else if (typeof obj === "number") {
        this._addOpcode(obj, prepend);
      } else if (obj instanceof Opcode) {
        this._addOpcode(obj, prepend);
      } else if (BufferUtil.isBuffer(obj)) {
        this._addBuffer(obj, prepend);
      } else if (obj instanceof Script) {
        this.chunks = this.chunks.concat(obj.chunks);
      } else if (typeof obj === "object") {
        this._insertAtPosition(obj, prepend);
      } else {
        throw new Error("Invalid script chunk");
      }
    };
    Script.prototype._insertAtPosition = function(op, prepend) {
      if (prepend) {
        this.chunks.unshift(op);
      } else {
        this.chunks.push(op);
      }
    };
    Script.prototype._addOpcode = function(opcode, prepend) {
      var op;
      if (typeof opcode === "number") {
        op = opcode;
      } else if (opcode instanceof Opcode) {
        op = opcode.toNumber();
      } else {
        op = Opcode(opcode).toNumber();
      }
      this._insertAtPosition({
        opcodenum: op
      }, prepend);
      return this;
    };
    Script.prototype._addBuffer = function(buf, prepend) {
      var opcodenum;
      var len = buf.length;
      if (len >= 0 && len < Opcode.OP_PUSHDATA1) {
        opcodenum = len;
      } else if (len < Math.pow(2, 8)) {
        opcodenum = Opcode.OP_PUSHDATA1;
      } else if (len < Math.pow(2, 16)) {
        opcodenum = Opcode.OP_PUSHDATA2;
      } else if (len < Math.pow(2, 32)) {
        opcodenum = Opcode.OP_PUSHDATA4;
      } else {
        throw new Error("You can't push that much data");
      }
      this._insertAtPosition({
        buf,
        len,
        opcodenum
      }, prepend);
      return this;
    };
    Script.prototype.removeCodeseparators = function() {
      var chunks = [];
      for (var i = 0; i < this.chunks.length; i++) {
        if (this.chunks[i].opcodenum !== Opcode.OP_CODESEPARATOR) {
          chunks.push(this.chunks[i]);
        }
      }
      this.chunks = chunks;
      return this;
    };
    Script.buildEscrowOut = function(inputPublicKeys, reclaimPublicKey) {
      $.checkArgument(inputPublicKeys.length < 65536, "Number of input public keys exceeds 65,536");
      $.checkArgument(inputPublicKeys.length > 0, "Must provide at least one input public key");
      $.checkArgument(reclaimPublicKey, "Must provide a reclaim public key");
      const redeemScript = new Script();
      const redeemScriptOperations = Escrow.generateRedeemScriptOperations(inputPublicKeys, reclaimPublicKey);
      redeemScriptOperations.forEach((operation) => redeemScript.add(operation));
      return redeemScript;
    };
    Script.buildMultisigOut = function(publicKeys, threshold, opts) {
      $.checkArgument(
        threshold <= publicKeys.length,
        "Number of required signatures must be less than or equal to the number of public keys"
      );
      opts = opts || {};
      var script = new Script();
      script.add(Opcode.smallInt(threshold));
      publicKeys = _.map(publicKeys, PublicKey);
      var sorted = publicKeys;
      if (!opts.noSorting) {
        sorted = _.sortBy(publicKeys, function(publicKey2) {
          return publicKey2.toString("hex");
        });
      }
      for (var i = 0; i < sorted.length; i++) {
        var publicKey = sorted[i];
        script.add(publicKey.toBuffer());
      }
      script.add(Opcode.smallInt(publicKeys.length));
      script.add(Opcode.OP_CHECKMULTISIG);
      return script;
    };
    Script.buildMultisigIn = function(pubkeys, threshold, signatures, opts) {
      $.checkArgument(_.isArray(pubkeys));
      $.checkArgument(_.isNumber(threshold));
      $.checkArgument(_.isArray(signatures));
      opts = opts || {};
      var s = new Script();
      if (opts.signingMethod === "schnorr" && opts.checkBits) {
        let checkBitsString = Buffer.from(opts.checkBits).reverse().join("");
        let checkBitsDecimal = parseInt(checkBitsString, 2);
        let checkBitsHex = parseInt(checkBitsDecimal.toString(16), 16);
        let N = pubkeys.length;
        if (N >= 1 && N <= 4) {
          s.add(Opcode(checkBitsHex));
        } else if (N >= 5 && N <= 8) {
          if (checkBitsHex === 129) {
            s.add(Opcode("OP_1NEGATE"));
          } else if (checkBitsHex > 16) {
            s.add(1);
            s.add(checkBitsHex);
          } else {
            s.add(Opcode(checkBitsHex));
          }
        } else if (N >= 9 && N <= 16) {
          s.add(2);
          s.add(checkBitsHex);
        } else if (N >= 17 && N <= 20) {
          s.add(3);
          s.add(checkBitsHex);
        }
      } else {
        s.add(Opcode.OP_0);
      }
      _.each(signatures, function(signature) {
        $.checkArgument(BufferUtil.isBuffer(signature), "Signatures must be an array of Buffers");
        s.add(signature);
      });
      return s;
    };
    Script.buildP2SHMultisigIn = function(pubkeys, threshold, signatures, opts) {
      $.checkArgument(_.isArray(pubkeys));
      $.checkArgument(_.isNumber(threshold));
      $.checkArgument(_.isArray(signatures));
      opts = opts || {};
      var s = new Script();
      if (opts.signingMethod === "schnorr" && opts.checkBits) {
        let checkBitsString = Buffer.from(opts.checkBits).reverse().join("");
        let checkBitsDecimal = parseInt(checkBitsString, 2);
        let checkBitsHex = parseInt(checkBitsDecimal.toString(16), 16);
        let N = pubkeys.length;
        if (N >= 1 && N <= 4) {
          s.add(Opcode.smallInt(checkBitsDecimal));
        } else if (N >= 5 && N <= 8) {
          if (checkBitsHex === 129) {
            s.add(Opcode("OP_1NEGATE"));
          } else if (checkBitsHex > 16) {
            s.add(1);
            s.add(checkBitsHex);
          } else {
            s.add(Opcode.smallInt(checkBitsDecimal));
          }
        } else if (N >= 9 && N <= 16) {
          s.add(2);
          s.add(checkBitsHex);
        } else if (N >= 17 && N <= 20) {
          s.add(3);
          s.add(checkBitsHex);
        }
      } else {
        s.add(Opcode.OP_0);
      }
      _.each(signatures, function(signature) {
        $.checkArgument(BufferUtil.isBuffer(signature), "Signatures must be an array of Buffers");
        s.add(signature);
      });
      s.add((opts.cachedMultisig || Script.buildMultisigOut(pubkeys, threshold, opts)).toBuffer());
      return s;
    };
    Script.buildPublicKeyHashOut = function(to) {
      $.checkArgument(!_.isUndefined(to));
      $.checkArgument(to instanceof PublicKey || to instanceof Address || _.isString(to));
      if (to instanceof PublicKey) {
        to = to.toAddress();
      } else if (_.isString(to)) {
        to = new Address(to);
      }
      var s = new Script();
      s.add(Opcode.OP_DUP).add(Opcode.OP_HASH160).add(to.hashBuffer).add(Opcode.OP_EQUALVERIFY).add(Opcode.OP_CHECKSIG);
      s._network = to.network;
      return s;
    };
    Script.buildPublicKeyOut = function(pubkey) {
      $.checkArgument(pubkey instanceof PublicKey);
      var s = new Script();
      s.add(pubkey.toBuffer()).add(Opcode.OP_CHECKSIG);
      return s;
    };
    Script.buildDataOut = function(data, encoding) {
      $.checkArgument(_.isUndefined(data) || _.isString(data) || BufferUtil.isBuffer(data));
      if (_.isString(data)) {
        data = Buffer.from(data, encoding);
      }
      var s = new Script();
      s.add(Opcode.OP_RETURN);
      if (!_.isUndefined(data)) {
        s.add(data);
      }
      return s;
    };
    Script.buildScriptHashOut = function(script) {
      $.checkArgument(script instanceof Script || script instanceof Address && script.isPayToScriptHash());
      var s = new Script();
      s.add(Opcode.OP_HASH160).add(script instanceof Address ? script.hashBuffer : Hash.sha256ripemd160(script.toBuffer())).add(Opcode.OP_EQUAL);
      s._network = script._network || script.network;
      return s;
    };
    Script.buildPublicKeyIn = function(signature, sigtype) {
      $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
      $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
      if (signature instanceof Signature) {
        signature = signature.toBuffer();
      }
      var script = new Script();
      script.add(BufferUtil.concat([
        signature,
        BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
      ]));
      return script;
    };
    Script.buildPublicKeyHashIn = function(publicKey, signature, sigtype) {
      $.checkArgument(signature instanceof Signature || BufferUtil.isBuffer(signature));
      $.checkArgument(_.isUndefined(sigtype) || _.isNumber(sigtype));
      if (signature instanceof Signature) {
        signature = signature.toBuffer();
      }
      var script = new Script().add(BufferUtil.concat([
        signature,
        BufferUtil.integerAsSingleByteBuffer(sigtype || Signature.SIGHASH_ALL)
      ])).add(new PublicKey(publicKey).toBuffer());
      return script;
    };
    Script.buildEscrowIn = function(publicKey, signature, redeemScript) {
      $.checkArgument(signature instanceof Signature);
      const sighashAll = Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      return new Script().add(BufferUtil.concat([signature.toBuffer("schnorr"), BufferUtil.integerAsSingleByteBuffer(sighashAll)])).add(publicKey.toBuffer()).add(redeemScript.toBuffer());
    };
    Script.empty = function() {
      return new Script();
    };
    Script.prototype.toScriptHashOut = function() {
      return Script.buildScriptHashOut(this);
    };
    Script.fromAddress = function(address) {
      address = Address(address);
      if (address.isPayToScriptHash()) {
        return Script.buildScriptHashOut(address);
      } else if (address.isPayToPublicKeyHash()) {
        return Script.buildPublicKeyHashOut(address);
      }
      throw new errors.Script.UnrecognizedAddress(address);
    };
    Script.prototype.getAddressInfo = function(opts) {
      if (this._isInput) {
        return this._getInputAddressInfo();
      } else if (this._isOutput) {
        return this._getOutputAddressInfo();
      } else {
        var info = this._getOutputAddressInfo();
        if (!info) {
          return this._getInputAddressInfo();
        }
        return info;
      }
    };
    Script.prototype._getOutputAddressInfo = function() {
      var info = {};
      if (this.isScriptHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address.PayToScriptHash;
      } else if (this.isPublicKeyHashOut()) {
        info.hashBuffer = this.getData();
        info.type = Address.PayToPublicKeyHash;
      } else {
        return false;
      }
      return info;
    };
    Script.prototype._getInputAddressInfo = function() {
      var info = {};
      if (this.isPublicKeyHashIn()) {
        info.hashBuffer = Hash.sha256ripemd160(this.chunks[1].buf);
        info.type = Address.PayToPublicKeyHash;
      } else if (this.isScriptHashIn()) {
        info.hashBuffer = Hash.sha256ripemd160(this.chunks[this.chunks.length - 1].buf);
        info.type = Address.PayToScriptHash;
      } else {
        return false;
      }
      return info;
    };
    Script.prototype.toAddress = function(network) {
      var info = this.getAddressInfo();
      if (!info) {
        return false;
      }
      info.network = Networks.get(network) || this._network || Networks.defaultNetwork;
      return new Address(info);
    };
    Script.prototype.findAndDelete = function(script) {
      var buf = script.toBuffer();
      var hex = buf.toString("hex");
      for (var i = 0; i < this.chunks.length; i++) {
        var script2 = Script({
          chunks: [this.chunks[i]]
        });
        var buf2 = script2.toBuffer();
        var hex2 = buf2.toString("hex");
        if (hex === hex2) {
          this.chunks.splice(i, 1);
        }
      }
      return this;
    };
    Script.prototype.checkMinimalPush = function(i) {
      var chunk = this.chunks[i];
      var buf = chunk.buf;
      var opcodenum = chunk.opcodenum;
      if (!buf) {
        return true;
      }
      if (buf.length === 0) {
        return opcodenum === Opcode.OP_0;
      } else if (buf.length === 1 && buf[0] >= 1 && buf[0] <= 16) {
        return false;
      } else if (buf.length === 1 && buf[0] === 129) {
        return false;
      } else if (buf.length <= 75) {
        return opcodenum === buf.length;
      } else if (buf.length <= 255) {
        return opcodenum === Opcode.OP_PUSHDATA1;
      } else if (buf.length <= 65535) {
        return opcodenum === Opcode.OP_PUSHDATA2;
      }
      return true;
    };
    Script.prototype._decodeOP_N = function(opcode) {
      if (opcode === Opcode.OP_0) {
        return 0;
      } else if (opcode >= Opcode.OP_1 && opcode <= Opcode.OP_16) {
        return opcode - (Opcode.OP_1 - 1);
      } else {
        throw new Error("Invalid opcode: " + JSON.stringify(opcode));
      }
    };
    Script.prototype.getSignatureOperationsCount = function(accurate) {
      accurate = _.isUndefined(accurate) ? true : accurate;
      var self2 = this;
      var n = 0;
      var lastOpcode = Opcode.OP_INVALIDOPCODE;
      _.each(self2.chunks, function getChunk(chunk) {
        var opcode = chunk.opcodenum;
        if (opcode == Opcode.OP_CHECKSIG || opcode == Opcode.OP_CHECKSIGVERIFY) {
          n++;
        } else if (opcode == Opcode.OP_CHECKMULTISIG || opcode == Opcode.OP_CHECKMULTISIGVERIFY) {
          if (accurate && lastOpcode >= Opcode.OP_1 && lastOpcode <= Opcode.OP_16) {
            n += self2._decodeOP_N(lastOpcode);
          } else {
            n += 20;
          }
        }
        lastOpcode = opcode;
      });
      return n;
    };
    module.exports = Script;
  }
});

// node_modules/bitcore-lib-cash/lib/crypto/random.js
var require_random = __commonJS({
  "node_modules/bitcore-lib-cash/lib/crypto/random.js"(exports, module) {
    "use strict";
    function Random() {
    }
    Random.getRandomBuffer = function(size) {
      if (process.browser)
        return Random.getRandomBufferBrowser(size);
      else
        return Random.getRandomBufferNode(size);
    };
    Random.getRandomBufferNode = function(size) {
      var crypto = require_crypto();
      return crypto.randomBytes(size);
    };
    Random.getRandomBufferBrowser = function(size) {
      if (!window.crypto && !window.msCrypto)
        throw new Error("window.crypto not available");
      if (window.crypto && window.crypto.getRandomValues)
        var crypto = window.crypto;
      else if (window.msCrypto && window.msCrypto.getRandomValues)
        var crypto = window.msCrypto;
      else
        throw new Error("window.crypto.getRandomValues not available");
      var bbuf = new Uint8Array(size);
      crypto.getRandomValues(bbuf);
      var buf = Buffer.from(bbuf);
      return buf;
    };
    Random.getPseudoRandomBuffer = function(size) {
      var b32 = 4294967296;
      var b = Buffer.alloc(size);
      var r;
      for (var i = 0; i <= size; i++) {
        var j = Math.floor(i / 4);
        var k = i - j * 4;
        if (k === 0) {
          r = Math.random() * b32;
          b[i] = r & 255;
        } else {
          b[i] = (r = r >>> 8) & 255;
        }
      }
      return b;
    };
    module.exports = Random;
  }
});

// node_modules/bitcore-lib-cash/lib/crypto/schnorr.js
var require_schnorr = __commonJS({
  "node_modules/bitcore-lib-cash/lib/crypto/schnorr.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var Point = require_point();
    var Signature = require_signature3();
    var PublicKey = require_publickey2();
    var Random = require_random();
    var Hash = require_hash2();
    var BufferUtil = require_buffer3();
    var _ = require_lodash();
    var $ = require_preconditions();
    var Schnorr = function Schnorr2(obj) {
      if (!(this instanceof Schnorr2)) {
        return new Schnorr2(obj);
      }
      if (obj) {
        this.set(obj);
      }
    };
    function getrBuffer(r) {
      let rNaturalLength = r.toBuffer().length;
      if (rNaturalLength < 32) {
        return r.toBuffer({ size: 32 });
      }
      return r.toBuffer();
    }
    function getsBuffer(s) {
      let sNaturalLength = s.toBuffer().length;
      if (sNaturalLength < 32) {
        return s.toBuffer({ size: 32 });
      }
      return s.toBuffer();
    }
    Schnorr.prototype.set = function(obj) {
      this.hashbuf = obj.hashbuf || this.hashbuf;
      this.endian = obj.endian || this.endian;
      this.privkey = obj.privkey || this.privkey;
      this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
      this.sig = obj.sig || this.sig;
      this.verified = obj.verified || this.verified;
      return this;
    };
    Schnorr.prototype.privkey2pubkey = function() {
      this.pubkey = this.privkey.toPublicKey();
    };
    Schnorr.prototype.toPublicKey = function() {
      return this.privkey.toPublicKey();
    };
    Schnorr.prototype.sign = function() {
      var hashbuf = this.hashbuf;
      var privkey = this.privkey;
      var d = privkey.bn;
      $.checkState(hashbuf && privkey && d, new Error("invalid parameters"));
      $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error("hashbuf must be a 32 byte buffer"));
      var e = BN.fromBuffer(hashbuf, this.endian ? {
        endian: this.endian
      } : void 0);
      var obj = this._findSignature(d, e);
      obj.compressed = this.pubkey.compressed;
      obj.isSchnorr = true;
      this.sig = new Signature(obj);
      return this;
    };
    Schnorr.prototype._findSignature = function(d, e) {
      let n = Point.getN();
      let G = Point.getG();
      $.checkState(!d.lte(new BN(0)), new Error("privkey out of field of curve"));
      $.checkState(!d.gte(n), new Error("privkey out of field of curve"));
      let k = this.nonceFunctionRFC6979(d.toBuffer({ size: 32 }), e.toBuffer({ size: 32 }));
      let P = G.mul(d);
      let R = G.mul(k);
      if (R.hasSquare()) {
        k = k;
      } else {
        k = n.sub(k);
      }
      let r = R.getX();
      let e0 = BN.fromBuffer(Hash.sha256(Buffer.concat([getrBuffer(r), Point.pointToCompressed(P), e.toBuffer({ size: 32 })])));
      let s = e0.mul(d).add(k).mod(n);
      return {
        r,
        s
      };
    };
    Schnorr.prototype.sigError = function() {
      if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {
        return "hashbuf must be a 32 byte buffer";
      }
      let sigLength = getrBuffer(this.sig.r).length + getsBuffer(this.sig.s).length;
      if (!(sigLength === 64 || sigLength === 65)) {
        return "signature must be a 64 byte or 65 byte array";
      }
      let hashbuf = this.endian === "little" ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;
      let P = this.pubkey.point;
      let G = Point.getG();
      if (P.isInfinity()) return true;
      let r = this.sig.r;
      let s = this.sig.s;
      let p = new BN("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", "hex");
      let n = Point.getN();
      if (r.gte(p) || s.gte(n)) {
        return true;
      }
      let Br = getrBuffer(this.sig.r);
      let Bp = Point.pointToCompressed(P);
      let hash = Hash.sha256(Buffer.concat([Br, Bp, hashbuf]));
      let e = BN.fromBuffer(hash, "big").umod(n);
      let sG = G.mul(s);
      let eP = P.mul(n.sub(e));
      let R = sG.add(eP);
      if (R.isInfinity() || !R.hasSquare() || !R.getX().eq(r)) {
        return true;
      }
      return false;
    };
    Schnorr.prototype.verify = function() {
      if (!this.sigError()) {
        this.verified = true;
      } else {
        this.verified = false;
      }
      return this;
    };
    Schnorr.prototype.nonceFunctionRFC6979 = function(privkey, msgbuf) {
      let V = Buffer.from("0101010101010101010101010101010101010101010101010101010101010101", "hex");
      let K = Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex");
      let blob = Buffer.concat([privkey, msgbuf, Buffer.from("", "ascii"), Buffer.from("Schnorr+SHA256  ", "ascii")]);
      K = Hash.sha256hmac(Buffer.concat([V, Buffer.from("00", "hex"), blob]), K);
      V = Hash.sha256hmac(V, K);
      K = Hash.sha256hmac(Buffer.concat([V, Buffer.from("01", "hex"), blob]), K);
      V = Hash.sha256hmac(V, K);
      let k = new BN(0);
      let T;
      while (true) {
        V = Hash.sha256hmac(V, K);
        T = BN.fromBuffer(V);
        k = T;
        $.checkState(V.length >= 32, "V length should be >= 32");
        if (k.gt(new BN(0)) && k.lt(Point.getN())) {
          break;
        }
        K = Hash.sha256hmac(Buffer.concat([V, Buffer.from("00", "hex")]), K);
        V = Hash.hmac(Hash.sha256, V, K);
      }
      return k;
    };
    Schnorr.sign = function(hashbuf, privkey, endian) {
      return Schnorr().set({
        hashbuf,
        endian,
        privkey
      }).sign().sig;
    };
    Schnorr.verify = function(hashbuf, sig, pubkey, endian) {
      return Schnorr().set({
        hashbuf,
        endian,
        sig,
        pubkey
      }).verify().verified;
    };
    module.exports = Schnorr;
  }
});

// node_modules/buffer-compare/index.js
var require_buffer_compare = __commonJS({
  "node_modules/buffer-compare/index.js"(exports, module) {
    module.exports = function(a, b) {
      if (typeof a.compare === "function") return a.compare(b);
      if (a === b) return 0;
      var x = a.length;
      var y = b.length;
      var i = 0;
      var len = Math.min(x, y);
      while (i < len) {
        if (a[i] !== b[i]) break;
        ++i;
      }
      if (i !== len) {
        x = a[i];
        y = b[i];
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/output.js
var require_output = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/output.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var BN = require_bn2();
    var buffer = require_buffer();
    var bufferUtil = require_buffer3();
    var JSUtil = require_js();
    var BufferWriter = require_bufferwriter();
    var BufferReader = require_bufferreader();
    var Script = require_script2();
    var $ = require_preconditions();
    var errors = require_errors();
    var MAX_SAFE_INTEGER = 9007199254740991;
    function Output(args) {
      if (!(this instanceof Output)) {
        return new Output(args);
      }
      if (_.isObject(args)) {
        this.satoshis = args.satoshis;
        if (bufferUtil.isBuffer(args.script)) {
          this._scriptBuffer = args.script;
        } else {
          var script;
          if (_.isString(args.script) && JSUtil.isHexa(args.script)) {
            script = Buffer.from(args.script, "hex");
          } else {
            script = args.script;
          }
          this.setScript(script);
        }
        this.tokenData = args.tokenData;
      } else {
        throw new TypeError("Unrecognized argument for Output");
      }
    }
    Object.defineProperty(Output.prototype, "script", {
      configurable: false,
      enumerable: true,
      get: function() {
        if (this._script) {
          return this._script;
        } else {
          this.setScriptFromBuffer(this._scriptBuffer);
          return this._script;
        }
      }
    });
    Object.defineProperty(Output.prototype, "satoshis", {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._satoshis;
      },
      set: function(num) {
        if (num instanceof BN) {
          this._satoshisBN = num;
          this._satoshis = num.toNumber();
        } else if (_.isString(num)) {
          this._satoshis = parseInt(num);
          this._satoshisBN = BN.fromNumber(this._satoshis);
        } else {
          $.checkArgument(
            JSUtil.isNaturalNumber(num),
            "Output satoshis is not a natural number"
          );
          this._satoshisBN = BN.fromNumber(num);
          this._satoshis = num;
        }
        $.checkState(
          JSUtil.isNaturalNumber(this._satoshis),
          "Output satoshis is not a natural number"
        );
      }
    });
    var maximumAmount = new BN("9223372036854775807");
    var nftCapabilityNumberToLabel = ["none", "mutable", "minting"];
    var nftCapabilityLabelToNumber = {
      "none": 0,
      "mutable": 1,
      "minting": 2
    };
    Object.defineProperty(Output.prototype, "tokenData", {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._tokenData;
      },
      set: function(tokenData) {
        if (typeof tokenData === "object") {
          $.checkState(typeof tokenData.category !== "undefined", "tokenData must have a category (a hex-encoded string or buffer)");
          const categoryBuf = typeof tokenData.category === "string" ? Buffer.from(tokenData.category, "hex") : Buffer.from(tokenData.category);
          $.checkState(categoryBuf.length === 32, "tokenData must have a 32-byte category");
          const category = categoryBuf.toString("hex");
          $.checkState(typeof tokenData.amount !== "undefined", "tokenData must have an amount (from 0 to 9223372036854775807)");
          $.checkState(typeof tokenData.amount !== "number" || tokenData.amount <= Number.MAX_SAFE_INTEGER, "to avoid precision loss, tokenData amount must provided as a string for values greater than 9007199254740991.");
          const amount = new BN(tokenData.amount);
          $.checkState(amount.gten(0), "tokenData amount must be greater than or equal to 0");
          $.checkState(amount.lte(maximumAmount), "tokenData amount must be less than or equal to 9223372036854775807.");
          if (typeof tokenData.nft === "object") {
            const nft = {};
            nft.capability = tokenData.nft.capability === void 0 ? "none" : String(tokenData.nft.capability);
            $.checkState(nftCapabilityNumberToLabel.includes(nft.capability), 'nft capability must be "none", "mutable", or "minting".');
            const commitment = tokenData.nft.commitment === void 0 ? Buffer.of() : typeof tokenData.nft.commitment === "string" ? Buffer.from(tokenData.nft.commitment, "hex") : Buffer.from(tokenData.nft.commitment);
            $.checkState(commitment.length <= 40, "nft commitment length must be less than or equal to 40 bytes.");
            nft.commitment = commitment.toString("hex");
            this._tokenData = { category, amount, nft };
          } else {
            $.checkState(amount.gtn(0), "tokenData must encode at least one token");
            this._tokenData = { category, amount };
          }
        }
      }
    });
    Output.prototype.invalidSatoshis = function() {
      if (this._satoshis > MAX_SAFE_INTEGER) {
        return "transaction txout satoshis greater than max safe integer";
      }
      if (this._satoshis !== this._satoshisBN.toNumber()) {
        return "transaction txout satoshis has corrupted value";
      }
      if (this._satoshis < 0) {
        return "transaction txout negative";
      }
      return false;
    };
    Object.defineProperty(Output.prototype, "satoshisBN", {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._satoshisBN;
      },
      set: function(num) {
        this._satoshisBN = num;
        this._satoshis = num.toNumber();
        $.checkState(
          JSUtil.isNaturalNumber(this._satoshis),
          "Output satoshis is not a natural number"
        );
      }
    });
    Output.prototype.toObject = Output.prototype.toJSON = function toObject() {
      var obj = {
        satoshis: this.satoshis
      };
      obj.script = this._scriptBuffer.toString("hex");
      if (this._tokenData !== void 0) {
        obj.tokenData = this._tokenData;
        obj.tokenData.amount = obj.tokenData.amount.toString();
      }
      return obj;
    };
    Output.fromObject = function(data) {
      return new Output(data);
    };
    Output.prototype.setScriptFromBuffer = function(buffer2) {
      this._scriptBuffer = buffer2;
      try {
        this._script = Script.fromBuffer(this._scriptBuffer);
        this._script._isOutput = true;
      } catch (e) {
        if (e instanceof errors.Script.InvalidBuffer) {
          this._script = null;
        } else {
          throw e;
        }
      }
    };
    Output.prototype.setScript = function(script) {
      if (script instanceof Script) {
        this._scriptBuffer = script.toBuffer();
        this._script = script;
        this._script._isOutput = true;
      } else if (_.isString(script)) {
        this._script = Script.fromString(script);
        this._scriptBuffer = this._script.toBuffer();
        this._script._isOutput = true;
      } else if (bufferUtil.isBuffer(script)) {
        this.setScriptFromBuffer(script);
      } else {
        throw new TypeError("Invalid argument type: script");
      }
      $.checkState(this._scriptBuffer[0] !== PREFIX_TOKEN, "Invalid output script: output script may not begin with PREFIX_TOKEN (239).");
      return this;
    };
    Output.prototype.inspect = function() {
      var scriptStr;
      if (this.script) {
        scriptStr = this.script.inspect();
      } else {
        scriptStr = this._scriptBuffer.toString("hex");
      }
      let tokenInfo = "";
      if (typeof this._tokenData !== "undefined") {
        const nftInfo = typeof this._tokenData.nft === "undefined" ? "" : `; nft [capability: ${this._tokenData.nft.capability}; commitment: ${this._tokenData.nft.commitment}]`;
        tokenInfo = `(token category: ${this._tokenData.category}; amount: ${this._tokenData.amount}${nftInfo} ) `;
      }
      return "<Output (" + this.satoshis + " sats) " + tokenInfo + scriptStr + ">";
    };
    var PREFIX_TOKEN = 239;
    var HAS_AMOUNT = 16;
    var HAS_NFT = 32;
    var HAS_COMMITMENT_LENGTH = 64;
    var RESERVED_BIT = 128;
    var categoryLength = 32;
    var tokenFormatMask = 240;
    var nftCapabilityMask = 15;
    var maximumCapability = 2;
    Output.fromBufferReader = function(br) {
      var obj = {};
      obj.satoshis = br.readUInt64LEBN();
      var size = br.readVarintNum();
      if (size !== 0) {
        var scriptSlot = br.read(size);
        if (scriptSlot[0] === PREFIX_TOKEN) {
          $.checkState(scriptSlot.length >= 34, "Invalid token prefix: insufficient length.");
          const tokenDataAndBytecode = BufferReader(scriptSlot.slice(1));
          obj.tokenData = {};
          obj.tokenData.category = tokenDataAndBytecode.read(categoryLength).reverse();
          const tokenBitfield = tokenDataAndBytecode.readUInt8();
          const prefixStructure = tokenBitfield & tokenFormatMask;
          $.checkState((prefixStructure & RESERVED_BIT) === 0, "Invalid token prefix: reserved bit is set.");
          const nftCapabilityInt = tokenBitfield & nftCapabilityMask;
          $.checkState(nftCapabilityInt <= maximumCapability, `Invalid token prefix: capability must be none (0), mutable (1), or minting (2). Capability value: ${nftCapabilityInt}`);
          const hasNft = (prefixStructure & HAS_NFT) !== 0;
          const hasCommitmentLength = (prefixStructure & HAS_COMMITMENT_LENGTH) !== 0;
          if (hasCommitmentLength && !hasNft) $.checkState(false, "Invalid token prefix: commitment requires an NFT.");
          const hasAmount = (prefixStructure & HAS_AMOUNT) !== 0;
          if (hasNft) {
            obj.tokenData.nft = {};
            obj.tokenData.nft.capability = nftCapabilityNumberToLabel[nftCapabilityInt];
            if (hasCommitmentLength) {
              const length = tokenDataAndBytecode.readVarintNum();
              $.checkState(length > 0, "Invalid token prefix: if encoded, commitment length must be greater than 0.");
              obj.tokenData.nft.commitment = tokenDataAndBytecode.read(length);
            } else {
              obj.tokenData.nft.commitment = Buffer.of();
            }
          } else {
            $.checkState(nftCapabilityInt === 0, "Invalid token prefix: capability requires an NFT.");
            $.checkState(hasAmount, "Invalid token prefix: must encode at least one token.");
          }
          obj.tokenData.amount = hasAmount ? tokenDataAndBytecode.readVarintBN() : new BN(0);
          obj.script = tokenDataAndBytecode.readAll();
        } else {
          obj.script = scriptSlot;
        }
      } else {
        obj.script = Buffer.from([]);
      }
      return new Output(obj);
    };
    Output.prototype.toBufferWriter = function(writer) {
      if (!writer) {
        writer = new BufferWriter();
      }
      writer.writeUInt64LEBN(this._satoshisBN);
      var script = this._scriptBuffer;
      if (typeof this._tokenData !== "undefined") {
        const tokenPrefix = new BufferWriter();
        tokenPrefix.writeUInt8(PREFIX_TOKEN);
        tokenPrefix.write(Buffer.from(this._tokenData.category, "hex").reverse());
        const hasNft = this._tokenData.nft === void 0 ? 0 : HAS_NFT;
        const capabilityInt = this._tokenData.nft === void 0 ? 0 : nftCapabilityLabelToNumber[this._tokenData.nft.capability];
        const hasCommitmentLength = this._tokenData.nft !== void 0 && this._tokenData.nft.commitment.length > 0 ? HAS_COMMITMENT_LENGTH : 0;
        const amount = new BN(this._tokenData.amount);
        const hasAmount = amount.gtn(0) ? HAS_AMOUNT : 0;
        const tokenBitfield = hasNft | capabilityInt | hasCommitmentLength | hasAmount;
        tokenPrefix.writeUInt8(tokenBitfield);
        if (hasCommitmentLength) {
          const commitment = Buffer.from(this._tokenData.nft.commitment, "hex");
          tokenPrefix.writeVarintNum(commitment.length);
          tokenPrefix.write(commitment);
        }
        if (hasAmount) {
          tokenPrefix.writeVarintBN(amount);
        }
        const tokenPrefixBuffer = tokenPrefix.toBuffer();
        const totalLength = tokenPrefixBuffer.length + script.length;
        writer.writeVarintNum(totalLength);
        writer.write(tokenPrefixBuffer);
        writer.write(script);
        return writer;
      }
      writer.writeVarintNum(script.length);
      writer.write(script);
      return writer;
    };
    module.exports = Output;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/input/input.js
var require_input = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/input/input.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var errors = require_errors();
    var BufferWriter = require_bufferwriter();
    var buffer = require_buffer();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var Script = require_script2();
    var Sighash = require_sighash();
    var Output = require_output();
    var MAXINT = 4294967295;
    var DEFAULT_RBF_SEQNUMBER = MAXINT - 2;
    var DEFAULT_SEQNUMBER = MAXINT;
    var DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;
    var SEQUENCE_LOCKTIME_DISABLE_FLAG2 = Math.pow(2, 31);
    var SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2, 22);
    var SEQUENCE_LOCKTIME_MASK = 65535;
    var SEQUENCE_LOCKTIME_GRANULARITY = 512;
    var SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2, 16) - 1;
    function Input(params) {
      if (!(this instanceof Input)) {
        return new Input(params);
      }
      if (params) {
        return this._fromObject(params);
      }
    }
    Input.MAXINT = MAXINT;
    Input.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;
    Input.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;
    Input.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;
    Input.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;
    Object.defineProperty(Input.prototype, "script", {
      configurable: false,
      enumerable: true,
      get: function() {
        if (this.isNull()) {
          return null;
        }
        if (!this._script) {
          this._script = new Script(this._scriptBuffer);
          this._script._isInput = true;
        }
        return this._script;
      }
    });
    Input.fromObject = function(obj) {
      $.checkArgument(_.isObject(obj));
      var input = new Input();
      return input._fromObject(obj);
    };
    Input.prototype._fromObject = function(params) {
      var prevTxId;
      if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {
        prevTxId = Buffer.from(params.prevTxId, "hex");
      } else {
        prevTxId = params.prevTxId;
      }
      this.output = params.output ? params.output instanceof Output ? params.output : new Output(params.output) : void 0;
      this.prevTxId = prevTxId || params.txidbuf;
      this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;
      this.sequenceNumber = _.isUndefined(params.sequenceNumber) ? _.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum : params.sequenceNumber;
      if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {
        throw new errors.Transaction.Input.MissingScript();
      }
      this.setScript(params.scriptBuffer || params.script);
      return this;
    };
    Input.prototype.toObject = Input.prototype.toJSON = function toObject() {
      var obj = {
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        sequenceNumber: this.sequenceNumber,
        script: this._scriptBuffer.toString("hex")
      };
      if (this.script) {
        obj.scriptString = this.script.toString();
      }
      if (this.output) {
        obj.output = this.output.toObject();
      }
      return obj;
    };
    Input.fromBufferReader = function(br) {
      var input = new Input();
      input.prevTxId = br.readReverse(32);
      input.outputIndex = br.readUInt32LE();
      input._scriptBuffer = br.readVarLengthBuffer();
      input.sequenceNumber = br.readUInt32LE();
      return input;
    };
    Input.prototype.toBufferWriter = function(writer) {
      if (!writer) {
        writer = new BufferWriter();
      }
      writer.writeReverse(this.prevTxId);
      writer.writeUInt32LE(this.outputIndex);
      var script = this._scriptBuffer;
      writer.writeVarintNum(script.length);
      writer.write(script);
      writer.writeUInt32LE(this.sequenceNumber);
      return writer;
    };
    Input.prototype.setScript = function(script) {
      this._script = null;
      if (script instanceof Script) {
        this._script = script;
        this._script._isInput = true;
        this._scriptBuffer = script.toBuffer();
      } else if (script === null) {
        this._script = Script.empty();
        this._script._isInput = true;
        this._scriptBuffer = this._script.toBuffer();
      } else if (JSUtil.isHexa(script)) {
        this._scriptBuffer = Buffer.from(script, "hex");
      } else if (_.isString(script)) {
        this._script = new Script(script);
        this._script._isInput = true;
        this._scriptBuffer = this._script.toBuffer();
      } else if (BufferUtil.isBuffer(script)) {
        this._scriptBuffer = Buffer.from(script);
      } else {
        throw new TypeError("Invalid argument type: script");
      }
      return this;
    };
    Input.prototype.getSignatures = function() {
      throw new errors.AbstractMethodInvoked(
        "Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported) for input: " + JSON.stringify(this)
      );
    };
    Input.prototype.isFullySigned = function() {
      throw new errors.AbstractMethodInvoked("Input#isFullySigned");
    };
    Input.prototype.isFinal = function() {
      return this.sequenceNumber !== 4294967295;
    };
    Input.prototype.addSignature = function() {
      throw new errors.AbstractMethodInvoked("Input#addSignature");
    };
    Input.prototype.clearSignatures = function() {
      throw new errors.AbstractMethodInvoked("Input#clearSignatures");
    };
    Input.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signature.signature.nhashtype = signature.sigtype;
      return Sighash.verify(
        transaction,
        signature.signature,
        signature.publicKey,
        signature.inputIndex,
        this.output.script,
        this.output.satoshisBN,
        void 0,
        signingMethod
      );
    };
    Input.prototype.isNull = function() {
      return this.prevTxId.toString("hex") === "0000000000000000000000000000000000000000000000000000000000000000" && this.outputIndex === 4294967295;
    };
    Input.prototype._estimateSize = function() {
      return this.toBufferWriter().toBuffer().length;
    };
    Input.prototype.lockForSeconds = function(seconds) {
      $.checkArgument(_.isNumber(seconds));
      if (seconds < 0 || seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {
        throw new errors.Transaction.Input.LockTimeRange();
      }
      seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY));
      this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG;
      return this;
    };
    Input.prototype.lockUntilBlockHeight = function(heightDiff) {
      $.checkArgument(_.isNumber(heightDiff));
      if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {
        throw new errors.Transaction.Input.BlockHeightOutOfRange();
      }
      this.sequenceNumber = heightDiff;
      return this;
    };
    Input.prototype.getLockTime = function() {
      if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG2) {
        return null;
      }
      if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {
        var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);
        return seconds;
      } else {
        var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;
        return blockHeight;
      }
    };
    module.exports = Input;
  }
});

// node_modules/bitcore-lib-cash/node_modules/inherits/inherits_browser.js
var require_inherits_browser2 = __commonJS({
  "node_modules/bitcore-lib-cash/node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/signature.js
var require_signature4 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/signature.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var inherits = require_inherits_browser2();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var PublicKey = require_publickey2();
    var errors = require_errors();
    var Signature = require_signature3();
    function TransactionSignature(arg) {
      if (!(this instanceof TransactionSignature)) {
        return new TransactionSignature(arg);
      }
      if (arg instanceof TransactionSignature) {
        return arg;
      }
      if (_.isObject(arg)) {
        return this._fromObject(arg);
      }
      throw new errors.InvalidArgument("TransactionSignatures must be instantiated from an object");
    }
    inherits(TransactionSignature, Signature);
    TransactionSignature.prototype._fromObject = function(arg) {
      this._checkObjectArgs(arg);
      this.publicKey = new PublicKey(arg.publicKey);
      this.prevTxId = BufferUtil.isBuffer(arg.prevTxId) ? arg.prevTxId : Buffer.from(arg.prevTxId, "hex");
      this.outputIndex = arg.outputIndex;
      this.inputIndex = arg.inputIndex;
      this.signature = arg.signature instanceof Signature ? arg.signature : BufferUtil.isBuffer(arg.signature) ? Signature.fromBuffer(arg.signature) : Signature.fromString(arg.signature);
      this.sigtype = arg.sigtype;
      return this;
    };
    TransactionSignature.prototype._checkObjectArgs = function(arg) {
      $.checkArgument(PublicKey(arg.publicKey), "publicKey");
      $.checkArgument(!_.isUndefined(arg.inputIndex), "inputIndex");
      $.checkArgument(!_.isUndefined(arg.outputIndex), "outputIndex");
      $.checkState(_.isNumber(arg.inputIndex), "inputIndex must be a number");
      $.checkState(_.isNumber(arg.outputIndex), "outputIndex must be a number");
      $.checkArgument(arg.signature, "signature");
      $.checkArgument(arg.prevTxId, "prevTxId");
      $.checkState(arg.signature instanceof Signature || BufferUtil.isBuffer(arg.signature) || JSUtil.isHexa(arg.signature), "signature must be a buffer or hexa value");
      $.checkState(BufferUtil.isBuffer(arg.prevTxId) || JSUtil.isHexa(arg.prevTxId), "prevTxId must be a buffer or hexa value");
      $.checkArgument(arg.sigtype, "sigtype");
      $.checkState(_.isNumber(arg.sigtype), "sigtype must be a number");
    };
    TransactionSignature.prototype.toObject = TransactionSignature.prototype.toJSON = function toObject() {
      return {
        publicKey: this.publicKey.toString(),
        prevTxId: this.prevTxId.toString("hex"),
        outputIndex: this.outputIndex,
        inputIndex: this.inputIndex,
        signature: this.signature.toString(),
        sigtype: this.sigtype
      };
    };
    TransactionSignature.fromObject = function(object) {
      $.checkArgument(object);
      return new TransactionSignature(object);
    };
    module.exports = TransactionSignature;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/input/publickey.js
var require_publickey = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/input/publickey.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser2();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var Input = require_input();
    var Output = require_output();
    var Sighash = require_sighash();
    var Script = require_script2();
    var Signature = require_signature3();
    var TransactionSignature = require_signature4();
    function PublicKeyInput() {
      Input.apply(this, arguments);
    }
    inherits(PublicKeyInput, Input);
    PublicKeyInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      var publicKey = privateKey.toPublicKey();
      if (publicKey.toString() === this.output.script.getPublicKey().toString("hex")) {
        return [new TransactionSignature({
          publicKey,
          prevTxId: this.prevTxId,
          outputIndex: this.outputIndex,
          inputIndex: index,
          signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN, void 0, signingMethod),
          sigtype
        })];
      }
      return [];
    };
    PublicKeyInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Signature is invalid");
      this.setScript(Script.buildPublicKeyIn(
        signature.signature.toDER(signingMethod),
        signature.sigtype
      ));
      return this;
    };
    PublicKeyInput.prototype.clearSignatures = function() {
      this.setScript(Script.empty());
      return this;
    };
    PublicKeyInput.prototype.isFullySigned = function() {
      return this.script.isPublicKeyIn();
    };
    PublicKeyInput.SCRIPT_MAX_SIZE = 73;
    PublicKeyInput.prototype._estimateSize = function() {
      return PublicKeyInput.SCRIPT_MAX_SIZE;
    };
    module.exports = PublicKeyInput;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/input/publickeyhash.js
var require_publickeyhash = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/input/publickeyhash.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser2();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var Hash = require_hash2();
    var Input = require_input();
    var Output = require_output();
    var Sighash = require_sighash();
    var Script = require_script2();
    var Signature = require_signature3();
    var TransactionSignature = require_signature4();
    function PublicKeyHashInput() {
      Input.apply(this, arguments);
    }
    inherits(PublicKeyHashInput, Input);
    PublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());
      sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {
        return [new TransactionSignature({
          publicKey: privateKey.publicKey,
          prevTxId: this.prevTxId,
          outputIndex: this.outputIndex,
          inputIndex: index,
          signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN, void 0, signingMethod),
          sigtype
        })];
      }
      return [];
    };
    PublicKeyHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(this.isValidSignature(transaction, signature, signingMethod), "Signature is invalid");
      this.setScript(Script.buildPublicKeyHashIn(
        signature.publicKey,
        signature.signature.toDER(signingMethod),
        signature.sigtype
      ));
      return this;
    };
    PublicKeyHashInput.prototype.clearSignatures = function() {
      this.setScript(Script.empty());
      return this;
    };
    PublicKeyHashInput.prototype.isFullySigned = function() {
      return this.script.isPublicKeyHashIn();
    };
    PublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34;
    PublicKeyHashInput.prototype._estimateSize = function() {
      return PublicKeyHashInput.SCRIPT_MAX_SIZE;
    };
    module.exports = PublicKeyHashInput;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/input/multisig.js
var require_multisig = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/input/multisig.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var inherits = require_inherits_browser2();
    var Transaction = require_transaction();
    var Input = require_input();
    var Output = require_output();
    var $ = require_preconditions();
    var Script = require_script2();
    var Signature = require_signature3();
    var Sighash = require_sighash();
    var PublicKey = require_publickey2();
    var BufferUtil = require_buffer3();
    var TransactionSignature = require_signature4();
    function MultiSigInput(input, pubkeys, threshold, signatures, opts) {
      opts = opts || {};
      Input.apply(this, arguments);
      var self2 = this;
      pubkeys = pubkeys || input.publicKeys;
      threshold = threshold || input.threshold;
      signatures = signatures || input.signatures;
      if (opts.noSorting) {
        this.publicKeys = pubkeys;
      } else {
        this.publicKeys = _.sortBy(pubkeys, function(publicKey) {
          return publicKey.toString("hex");
        });
      }
      $.checkState(
        Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script),
        "Provided public keys don't match to the provided output script"
      );
      this.publicKeyIndex = {};
      _.each(this.publicKeys, function(publicKey, index) {
        self2.publicKeyIndex[publicKey.toString()] = index;
      });
      this.threshold = threshold;
      this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
    }
    inherits(MultiSigInput, Input);
    MultiSigInput.prototype.toObject = function() {
      var obj = Input.prototype.toObject.apply(this, arguments);
      obj.threshold = this.threshold;
      obj.publicKeys = _.map(this.publicKeys, function(publicKey) {
        return publicKey.toString();
      });
      obj.signatures = this._serializeSignatures();
      return obj;
    };
    MultiSigInput.prototype._deserializeSignatures = function(signatures) {
      return _.map(signatures, function(signature) {
        if (!signature) {
          return void 0;
        }
        return new TransactionSignature(signature);
      });
    };
    MultiSigInput.prototype._serializeSignatures = function() {
      return _.map(this.signatures, function(signature) {
        if (!signature) {
          return void 0;
        }
        return signature.toObject();
      });
    };
    MultiSigInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      var self2 = this;
      var results = [];
      _.each(this.publicKeys, function(publicKey) {
        if (publicKey.toString() === privateKey.publicKey.toString()) {
          results.push(new TransactionSignature({
            publicKey: privateKey.publicKey,
            prevTxId: self2.prevTxId,
            outputIndex: self2.outputIndex,
            inputIndex: index,
            signature: Sighash.sign(transaction, privateKey, sigtype, index, self2.output.script, self2.output.satoshisBN, void 0, signingMethod),
            sigtype
          }));
        }
      });
      return results;
    };
    MultiSigInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(!this.isFullySigned(), "All needed signatures have already been added");
      $.checkArgument(
        !_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),
        "Signature has no matching public key"
      );
      $.checkState(this.isValidSignature(transaction, signature, signingMethod));
      this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
      this._updateScript(signingMethod);
      return this;
    };
    MultiSigInput.prototype._updateScript = function(signingMethod) {
      this.setScript(Script.buildMultisigIn(
        this.publicKeys,
        this.threshold,
        this._createSignatures(signingMethod)
      ));
      return this;
    };
    MultiSigInput.prototype._createSignatures = function(signingMethod) {
      return _.map(
        _.filter(this.signatures, function(signature) {
          return !_.isUndefined(signature);
        }),
        function(signature) {
          return BufferUtil.concat([
            signature.signature.toDER(signingMethod),
            BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
          ]);
        }
      );
    };
    MultiSigInput.prototype.clearSignatures = function() {
      this.signatures = new Array(this.publicKeys.length);
      this._updateScript();
    };
    MultiSigInput.prototype.isFullySigned = function() {
      return this.countSignatures() === this.threshold;
    };
    MultiSigInput.prototype.countMissingSignatures = function() {
      return this.threshold - this.countSignatures();
    };
    MultiSigInput.prototype.countSignatures = function() {
      return _.reduce(this.signatures, function(sum, signature) {
        return sum + !!signature;
      }, 0);
    };
    MultiSigInput.prototype.publicKeysWithoutSignature = function() {
      var self2 = this;
      return _.filter(this.publicKeys, function(publicKey) {
        return !self2.signatures[self2.publicKeyIndex[publicKey.toString()]];
      });
    };
    MultiSigInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signature.signature.nhashtype = signature.sigtype;
      return Sighash.verify(
        transaction,
        signature.signature,
        signature.publicKey,
        signature.inputIndex,
        this.output.script,
        this.output.satoshisBN,
        void 0,
        signingMethod
      );
    };
    MultiSigInput.normalizeSignatures = function(transaction, input, inputIndex, signatures, publicKeys, signingMethod) {
      return publicKeys.map(function(pubKey) {
        var signatureMatch = null;
        signatures = signatures.filter(function(signatureBuffer) {
          if (signatureMatch) {
            return true;
          }
          var signature = new TransactionSignature({
            signature: Signature.fromTxFormat(signatureBuffer),
            publicKey: pubKey,
            prevTxId: input.prevTxId,
            outputIndex: input.outputIndex,
            inputIndex,
            sigtype: Signature.SIGHASH_ALL
          });
          signature.signature.nhashtype = signature.sigtype;
          var isMatch = Sighash.verify(
            transaction,
            signature.signature,
            signature.publicKey,
            signature.inputIndex,
            input.output.script,
            void 0,
            signingMethod
          );
          if (isMatch) {
            signatureMatch = signature;
            return false;
          }
          return true;
        });
        return signatureMatch ? signatureMatch : null;
      });
    };
    MultiSigInput.OPCODES_SIZE = 1;
    MultiSigInput.SIGNATURE_SIZE = 73;
    MultiSigInput.prototype._estimateSize = function() {
      return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;
    };
    module.exports = MultiSigInput;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/input/multisigscripthash.js
var require_multisigscripthash = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/input/multisigscripthash.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var inherits = require_inherits_browser2();
    var Input = require_input();
    var Output = require_output();
    var $ = require_preconditions();
    var Script = require_script2();
    var Signature = require_signature3();
    var Sighash = require_sighash();
    var PublicKey = require_publickey2();
    var BufferUtil = require_buffer3();
    var TransactionSignature = require_signature4();
    function MultiSigScriptHashInput(input, pubkeys, threshold, signatures, opts) {
      opts = opts || {};
      Input.apply(this, arguments);
      var self2 = this;
      pubkeys = pubkeys || input.publicKeys;
      threshold = threshold || input.threshold;
      signatures = signatures || input.signatures;
      if (opts.noSorting) {
        this.publicKeys = pubkeys;
      } else {
        this.publicKeys = _.sortBy(pubkeys, function(publicKey) {
          return publicKey.toString("hex");
        });
      }
      this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold, opts);
      $.checkState(
        Script.buildScriptHashOut(this.redeemScript).equals(this.output.script),
        "Provided public keys don't hash to the provided output"
      );
      this.publicKeyIndex = {};
      _.each(this.publicKeys, function(publicKey, index) {
        self2.publicKeyIndex[publicKey.toString()] = index;
      });
      this.threshold = threshold;
      this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);
      this.checkBitsField = new Uint8Array(this.publicKeys.length);
    }
    inherits(MultiSigScriptHashInput, Input);
    MultiSigScriptHashInput.prototype.toObject = function() {
      var obj = Input.prototype.toObject.apply(this, arguments);
      obj.threshold = this.threshold;
      obj.publicKeys = _.map(this.publicKeys, function(publicKey) {
        return publicKey.toString();
      });
      obj.signatures = this._serializeSignatures();
      return obj;
    };
    MultiSigScriptHashInput.prototype._deserializeSignatures = function(signatures) {
      return _.map(signatures, function(signature) {
        if (!signature) {
          return void 0;
        }
        return new TransactionSignature(signature);
      });
    };
    MultiSigScriptHashInput.prototype._serializeSignatures = function() {
      return _.map(this.signatures, function(signature) {
        if (!signature) {
          return void 0;
        }
        return signature.toObject();
      });
    };
    MultiSigScriptHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
      $.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      var self2 = this;
      var results = [];
      for (const publicKey of this.publicKeys) {
        if (publicKey.toString() === privateKey.publicKey.toString()) {
          results.push(new TransactionSignature({
            publicKey: privateKey.publicKey,
            prevTxId: self2.prevTxId,
            outputIndex: self2.outputIndex,
            inputIndex: index,
            signature: Sighash.sign(transaction, privateKey, sigtype, index, self2.redeemScript, self2.output.satoshisBN, void 0, signingMethod),
            sigtype
          }));
        }
      }
      return results;
    };
    MultiSigScriptHashInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(!this.isFullySigned(), "All needed signatures have already been added");
      $.checkArgument(
        !_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]),
        "Signature has no matching public key"
      );
      $.checkState(this.isValidSignature(transaction, signature, signingMethod));
      this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;
      this.checkBitsField[this.publicKeyIndex[signature.publicKey.toString()]] = signature !== void 0 ? 1 : 0;
      this._updateScript(signingMethod, this.checkBitsField);
      return this;
    };
    MultiSigScriptHashInput.prototype._updateScript = function(signingMethod, checkBitsField) {
      this.setScript(Script.buildP2SHMultisigIn(
        this.publicKeys,
        this.threshold,
        this._createSignatures(signingMethod),
        { cachedMultisig: this.redeemScript, checkBits: checkBitsField, signingMethod }
      ));
      return this;
    };
    MultiSigScriptHashInput.prototype._createSignatures = function(signingMethod) {
      return _.map(
        _.filter(this.signatures, function(signature) {
          return !_.isUndefined(signature);
        }),
        function(signature) {
          return BufferUtil.concat([
            signature.signature.toDER(signingMethod),
            BufferUtil.integerAsSingleByteBuffer(signature.sigtype)
          ]);
        }
      );
    };
    MultiSigScriptHashInput.prototype.clearSignatures = function() {
      this.signatures = new Array(this.publicKeys.length);
      this._updateScript();
    };
    MultiSigScriptHashInput.prototype.isFullySigned = function() {
      return this.countSignatures() === this.threshold;
    };
    MultiSigScriptHashInput.prototype.countMissingSignatures = function() {
      return this.threshold - this.countSignatures();
    };
    MultiSigScriptHashInput.prototype.countSignatures = function() {
      return _.reduce(this.signatures, function(sum, signature) {
        return sum + !!signature;
      }, 0);
    };
    MultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function() {
      var self2 = this;
      return _.filter(this.publicKeys, function(publicKey) {
        return !self2.signatures[self2.publicKeyIndex[publicKey.toString()]];
      });
    };
    MultiSigScriptHashInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signingMethod = signingMethod || (signature.signature.isSchnorr ? "schnorr" : "ecdsa");
      signature.signature.nhashtype = signature.sigtype;
      return Sighash.verify(
        transaction,
        signature.signature,
        signature.publicKey,
        signature.inputIndex,
        this.redeemScript,
        this.output.satoshisBN,
        void 0,
        signingMethod
      );
    };
    MultiSigScriptHashInput.OPCODES_SIZE = 7;
    MultiSigScriptHashInput.SIGNATURE_SIZE = 74;
    MultiSigScriptHashInput.PUBKEY_SIZE = 34;
    MultiSigScriptHashInput.prototype._estimateSize = function() {
      return MultiSigScriptHashInput.OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;
    };
    module.exports = MultiSigScriptHashInput;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/input/escrow.js
var require_escrow2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/input/escrow.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser2();
    var $ = require_preconditions();
    var Input = require_input();
    var Output = require_output();
    var Script = require_script2();
    var Sighash = require_sighash();
    var Signature = require_signature3();
    var TransactionSignature = require_signature4();
    function EscrowInput(input, inputPublicKeys, reclaimPublicKey, signatures) {
      Input.apply(this, arguments);
      signatures = signatures || input.signatures || [];
      this.inputPublicKeys = inputPublicKeys;
      this.reclaimPublicKey = reclaimPublicKey;
      this.redeemScript = Script.buildEscrowOut(inputPublicKeys, reclaimPublicKey);
      $.checkState(
        Script.buildScriptHashOut(this.redeemScript).equals(this.output.script),
        "Provided public keys don't hash to the provided output"
      );
      this.signatures = this._deserializeSignatures(signatures);
    }
    inherits(EscrowInput, Input);
    EscrowInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData, signingMethod) {
      if (this.reclaimPublicKey.toString() !== privateKey.publicKey.toString()) return [];
      $.checkState(this.output instanceof Output);
      sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      const signature = new TransactionSignature({
        publicKey: privateKey.publicKey,
        prevTxId: this.prevTxId,
        outputIndex: this.outputIndex,
        inputIndex: index,
        signature: Sighash.sign(
          transaction,
          privateKey,
          sigtype,
          index,
          this.redeemScript,
          this.output.satoshisBN,
          void 0,
          signingMethod
        ),
        sigtype
      });
      return [signature];
    };
    EscrowInput.prototype.addSignature = function(transaction, signature, signingMethod) {
      $.checkState(this.isValidSignature(transaction, signature, signingMethod));
      const reclaimScript = Script.buildEscrowIn(this.reclaimPublicKey, signature.signature, this.redeemScript);
      this.setScript(reclaimScript);
      this.signatures = [signature];
    };
    EscrowInput.prototype.isValidSignature = function(transaction, signature, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      signature.signature.nhashtype = signature.sigtype;
      return Sighash.verify(
        transaction,
        signature.signature,
        signature.publicKey,
        signature.inputIndex,
        this.redeemScript,
        this.output.satoshisBN,
        void 0,
        signingMethod
      );
    };
    EscrowInput.prototype.clearSignatures = function() {
      this.signatures = [];
    };
    EscrowInput.prototype.isFullySigned = function() {
      return this.signatures.length === 1;
    };
    EscrowInput.prototype._deserializeSignatures = function(signatures) {
      return signatures.map((signature) => new TransactionSignature(signature));
    };
    module.exports = EscrowInput;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/input/index.js
var require_input2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/input/index.js"(exports, module) {
    module.exports = require_input();
    module.exports.PublicKey = require_publickey();
    module.exports.PublicKeyHash = require_publickeyhash();
    module.exports.MultiSig = require_multisig();
    module.exports.MultiSigScriptHash = require_multisigscripthash();
    module.exports.Escrow = require_escrow2();
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/sighash.js
var require_sighash = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/sighash.js"(exports, module) {
    "use strict";
    var buffer = require_buffer();
    var Signature = require_signature3();
    var Script = require_script2();
    var Output = require_output();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var BN = require_bn2();
    var Hash = require_hash2();
    var ECDSA = require_ecdsa();
    var Schnorr = require_schnorr();
    var $ = require_preconditions();
    var BufferUtil = require_buffer3();
    var Interpreter = require_interpreter();
    var _ = require_lodash();
    var SIGHASH_SINGLE_BUG = "0000000000000000000000000000000000000000000000000000000000000001";
    var BITS_64_ON = "ffffffffffffffff";
    var DEFAULT_SIGN_FLAGS = Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID;
    var sighashForForkId = function(transaction, sighashType, inputNumber, subscript, satoshisBN) {
      var input = transaction.inputs[inputNumber];
      $.checkArgument(
        satoshisBN instanceof BN,
        "For ForkId=0 signatures, satoshis or complete input must be provided"
      );
      function GetForkId() {
        return 0;
      }
      ;
      function GetPrevoutHash(tx) {
        var writer2 = new BufferWriter();
        _.each(tx.inputs, function(input2) {
          writer2.writeReverse(input2.prevTxId);
          writer2.writeUInt32LE(input2.outputIndex);
        });
        var buf2 = writer2.toBuffer();
        var ret2 = Hash.sha256sha256(buf2);
        return ret2;
      }
      function GetSequenceHash(tx) {
        var writer2 = new BufferWriter();
        _.each(tx.inputs, function(input2) {
          writer2.writeUInt32LE(input2.sequenceNumber);
        });
        var buf2 = writer2.toBuffer();
        var ret2 = Hash.sha256sha256(buf2);
        return ret2;
      }
      function GetOutputsHash(tx, n) {
        var writer2 = new BufferWriter();
        if (_.isUndefined(n)) {
          _.each(tx.outputs, function(output) {
            output.toBufferWriter(writer2);
          });
        } else {
          tx.outputs[n].toBufferWriter(writer2);
        }
        var buf2 = writer2.toBuffer();
        var ret2 = Hash.sha256sha256(buf2);
        return ret2;
      }
      var hashPrevouts = BufferUtil.emptyBuffer(32);
      var hashSequence = BufferUtil.emptyBuffer(32);
      var hashOutputs = BufferUtil.emptyBuffer(32);
      if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {
        hashPrevouts = GetPrevoutHash(transaction);
      }
      if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {
        hashSequence = GetSequenceHash(transaction);
      }
      if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {
        hashOutputs = GetOutputsHash(transaction);
      } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {
        hashOutputs = GetOutputsHash(transaction, inputNumber);
      }
      function getHash(w) {
        var buf2 = w.toBuffer();
        var ret2 = Hash.sha256sha256(buf2);
        ret2 = new BufferReader(ret2).readReverse();
        return ret2;
      }
      ;
      var writer = new BufferWriter();
      writer.writeInt32LE(transaction.version);
      writer.write(hashPrevouts);
      writer.write(hashSequence);
      writer.writeReverse(input.prevTxId);
      writer.writeUInt32LE(input.outputIndex);
      writer.writeVarintNum(subscript.toBuffer().length);
      writer.write(subscript.toBuffer());
      writer.writeUInt64LEBN(satoshisBN);
      var sequenceNumber = input.sequenceNumber;
      writer.writeUInt32LE(sequenceNumber);
      writer.write(hashOutputs);
      writer.writeUInt32LE(transaction.nLockTime);
      writer.writeUInt32LE(sighashType >>> 0);
      var buf = writer.toBuffer();
      var ret = Hash.sha256sha256(buf);
      ret = new BufferReader(ret).readReverse();
      return ret;
    };
    var sighash = function sighash2(transaction, sighashType, inputNumber, subscript, satoshisBN, flags) {
      var Transaction = require_transaction();
      var Input = require_input2();
      if (_.isUndefined(flags)) {
        flags = DEFAULT_SIGN_FLAGS;
      }
      var txcopy = Transaction.shallowCopy(transaction);
      subscript = new Script(subscript);
      if (flags & Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION) {
        var forkValue = sighashType >> 8;
        var newForkValue = 16711680 | forkValue ^ 57005;
        sighashType = newForkValue << 8 | sighashType & 255;
      }
      if (sighashType & Signature.SIGHASH_FORKID && flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {
        return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);
      }
      subscript.removeCodeseparators();
      var i;
      for (i = 0; i < txcopy.inputs.length; i++) {
        txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());
      }
      txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);
      if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {
        for (i = 0; i < txcopy.inputs.length; i++) {
          if (i !== inputNumber) {
            txcopy.inputs[i].sequenceNumber = 0;
          }
        }
      }
      if ((sighashType & 31) === Signature.SIGHASH_NONE) {
        txcopy.outputs = [];
      } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {
        if (inputNumber >= txcopy.outputs.length) {
          return Buffer.from(SIGHASH_SINGLE_BUG, "hex");
        }
        txcopy.outputs.length = inputNumber + 1;
        for (i = 0; i < inputNumber; i++) {
          txcopy.outputs[i] = new Output({
            satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, "hex")),
            script: Script.empty()
          });
        }
      }
      if (sighashType & Signature.SIGHASH_ANYONECANPAY) {
        txcopy.inputs = [txcopy.inputs[inputNumber]];
      }
      var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();
      var ret = Hash.sha256sha256(buf);
      ret = new BufferReader(ret).readReverse();
      return ret;
    };
    function sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN, flags, signingMethod) {
      var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN, flags);
      signingMethod = signingMethod || "ecdsa";
      let sig;
      if (signingMethod === "schnorr") {
        sig = Schnorr.sign(hashbuf, privateKey, "little").set({
          nhashtype: sighashType
        });
        return sig;
      } else if (signingMethod === "ecdsa") {
        sig = ECDSA.sign(hashbuf, privateKey, "little").set({
          nhashtype: sighashType
        });
        return sig;
      }
    }
    function verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN, flags, signingMethod) {
      $.checkArgument(!_.isUndefined(transaction));
      $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));
      var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN, flags);
      signingMethod = signingMethod || "ecdsa";
      if (signingMethod === "schnorr") {
        return Schnorr.verify(hashbuf, signature, publicKey, "little");
      } else if (signingMethod === "ecdsa") {
        return ECDSA.verify(hashbuf, signature, publicKey, "little");
      }
    }
    module.exports = {
      sighash,
      sign,
      verify
    };
  }
});

// node_modules/bitcore-lib-cash/lib/unit.js
var require_unit = __commonJS({
  "node_modules/bitcore-lib-cash/lib/unit.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var errors = require_errors();
    var $ = require_preconditions();
    var UNITS = {
      "BTC": [1e8, 8],
      "mBTC": [1e5, 5],
      "uBTC": [100, 2],
      "bits": [100, 2],
      "satoshis": [1, 0]
    };
    function Unit(amount, code) {
      if (!(this instanceof Unit)) {
        return new Unit(amount, code);
      }
      if (_.isNumber(code)) {
        if (code <= 0) {
          throw new errors.Unit.InvalidRate(code);
        }
        amount = amount / code;
        code = Unit.BTC;
      }
      this._value = this._from(amount, code);
      var self2 = this;
      var defineAccesor = function(key) {
        Object.defineProperty(self2, key, {
          get: function() {
            return self2.to(key);
          },
          enumerable: true
        });
      };
      Object.keys(UNITS).forEach(defineAccesor);
    }
    Object.keys(UNITS).forEach(function(key) {
      Unit[key] = key;
    });
    Unit.fromObject = function fromObject(data) {
      $.checkArgument(_.isObject(data), "Argument is expected to be an object");
      return new Unit(data.amount, data.code);
    };
    Unit.fromBTC = function(amount) {
      return new Unit(amount, Unit.BTC);
    };
    Unit.fromMillis = Unit.fromMilis = function(amount) {
      return new Unit(amount, Unit.mBTC);
    };
    Unit.fromMicros = Unit.fromBits = function(amount) {
      return new Unit(amount, Unit.bits);
    };
    Unit.fromSatoshis = function(amount) {
      return new Unit(amount, Unit.satoshis);
    };
    Unit.fromFiat = function(amount, rate) {
      return new Unit(amount, rate);
    };
    Unit.prototype._from = function(amount, code) {
      if (!UNITS[code]) {
        throw new errors.Unit.UnknownCode(code);
      }
      return parseInt((amount * UNITS[code][0]).toFixed());
    };
    Unit.prototype.to = function(code) {
      if (_.isNumber(code)) {
        if (code <= 0) {
          throw new errors.Unit.InvalidRate(code);
        }
        return parseFloat((this.BTC * code).toFixed(2));
      }
      if (!UNITS[code]) {
        throw new errors.Unit.UnknownCode(code);
      }
      var value = this._value / UNITS[code][0];
      return parseFloat(value.toFixed(UNITS[code][1]));
    };
    Unit.prototype.toBTC = function() {
      return this.to(Unit.BTC);
    };
    Unit.prototype.toMillis = Unit.prototype.toMilis = function() {
      return this.to(Unit.mBTC);
    };
    Unit.prototype.toMicros = Unit.prototype.toBits = function() {
      return this.to(Unit.bits);
    };
    Unit.prototype.toSatoshis = function() {
      return this.to(Unit.satoshis);
    };
    Unit.prototype.atRate = function(rate) {
      return this.to(rate);
    };
    Unit.prototype.toString = function() {
      return this.satoshis + " satoshis";
    };
    Unit.prototype.toObject = Unit.prototype.toJSON = function toObject() {
      return {
        amount: this.BTC,
        code: Unit.BTC
      };
    };
    Unit.prototype.inspect = function() {
      return "<Unit: " + this.toString() + ">";
    };
    module.exports = Unit;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/unspentoutput.js
var require_unspentoutput = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/unspentoutput.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var JSUtil = require_js();
    var Script = require_script2();
    var Address = require_address();
    var Unit = require_unit();
    function UnspentOutput(data) {
      if (!(this instanceof UnspentOutput)) {
        return new UnspentOutput(data);
      }
      $.checkArgument(_.isObject(data), "Must provide an object from where to extract data");
      var address = data.address ? new Address(data.address) : void 0;
      var txId = data.txid ? data.txid : data.txId;
      if (!txId || !JSUtil.isHexaString(txId) || txId.length > 64) {
        throw new Error("Invalid TXID in object", data);
      }
      var outputIndex = _.isUndefined(data.vout) ? data.outputIndex : data.vout;
      if (!_.isNumber(outputIndex)) {
        throw new Error("Invalid outputIndex, received " + outputIndex);
      }
      $.checkArgument(
        !_.isUndefined(data.scriptPubKey) || !_.isUndefined(data.script) || !_.isUndefined(address),
        "Must provide the scriptPubKey, script, or address for that output!"
      );
      var script = new Script(data.scriptPubKey || data.script || Script.fromAddress(address));
      $.checkArgument(
        !_.isUndefined(data.amount) || !_.isUndefined(data.satoshis),
        "Must provide an amount for the output"
      );
      var amount = !_.isUndefined(data.amount) ? new Unit.fromBTC(data.amount).toSatoshis() : data.satoshis;
      $.checkArgument(_.isNumber(amount), "Amount must be a number");
      JSUtil.defineImmutable(this, {
        address,
        txId,
        outputIndex,
        script,
        satoshis: amount
      });
    }
    UnspentOutput.prototype.inspect = function() {
      return "<UnspentOutput: " + this.txId + ":" + this.outputIndex + ", satoshis: " + this.satoshis + ", address: " + this.address + ">";
    };
    UnspentOutput.prototype.toString = function() {
      return this.txId + ":" + this.outputIndex;
    };
    UnspentOutput.fromObject = function(data) {
      return new UnspentOutput(data);
    };
    UnspentOutput.prototype.toObject = UnspentOutput.prototype.toJSON = function toObject() {
      return {
        address: this.address ? this.address.toString() : void 0,
        txid: this.txId,
        vout: this.outputIndex,
        scriptPubKey: this.script.toBuffer().toString("hex"),
        amount: Unit.fromSatoshis(this.satoshis).toBTC()
      };
    };
    module.exports = UnspentOutput;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/transaction.js
var require_transaction = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/transaction.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var buffer = require_buffer();
    var compare = Buffer.compare || require_buffer_compare();
    var errors = require_errors();
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash = require_hash2();
    var Signature = require_signature3();
    var Sighash = require_sighash();
    var Address = require_address();
    var UnspentOutput = require_unspentoutput();
    var Input = require_input2();
    var PublicKeyHashInput = Input.PublicKeyHash;
    var PublicKeyInput = Input.PublicKey;
    var MultiSigScriptHashInput = Input.MultiSigScriptHash;
    var MultiSigInput = Input.MultiSig;
    var EscrowInput = Input.Escrow;
    var Output = require_output();
    var Script = require_script2();
    var PrivateKey = require_privatekey();
    var PublicKey = require_publickey2();
    var BN = require_bn2();
    function Transaction(serialized) {
      if (!(this instanceof Transaction)) {
        return new Transaction(serialized);
      }
      this.inputs = [];
      this.outputs = [];
      this._inputAmount = void 0;
      this._outputAmount = void 0;
      if (serialized) {
        if (serialized instanceof Transaction) {
          return Transaction.shallowCopy(serialized);
        } else if (JSUtil.isHexa(serialized)) {
          this.fromString(serialized);
        } else if (BufferUtil.isBuffer(serialized)) {
          this.fromBuffer(serialized);
        } else if (_.isObject(serialized)) {
          this.fromObject(serialized);
        } else {
          throw new errors.InvalidArgument("Must provide an object or string to deserialize a transaction");
        }
      } else {
        this._newTransaction();
      }
    }
    var CURRENT_VERSION = 2;
    var DEFAULT_NLOCKTIME = 0;
    var MAX_BLOCK_SIZE = 1e6;
    Transaction.DUST_AMOUNT = 546;
    Transaction.FEE_SECURITY_MARGIN = 150;
    Transaction.MAX_MONEY = 21e6 * 1e8;
    Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT = 5e8;
    Transaction.NLOCKTIME_MAX_VALUE = 4294967295;
    Transaction.FEE_PER_KB = 1e5;
    Transaction.CHANGE_OUTPUT_MAX_SIZE = 20 + 4 + 34 + 4;
    Transaction.MAXIMUM_EXTRA_SIZE = 4 + 9 + 9 + 4;
    Transaction.shallowCopy = function(transaction) {
      var copy = new Transaction(transaction.toBuffer());
      return copy;
    };
    var hashProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        this._hash = new BufferReader(this._getHash()).readReverse().toString("hex");
        return this._hash;
      }
    };
    Object.defineProperty(Transaction.prototype, "hash", hashProperty);
    Object.defineProperty(Transaction.prototype, "id", hashProperty);
    var ioProperty = {
      configurable: false,
      enumerable: true,
      get: function() {
        return this._getInputAmount();
      }
    };
    Object.defineProperty(Transaction.prototype, "inputAmount", ioProperty);
    ioProperty.get = function() {
      return this._getOutputAmount();
    };
    Object.defineProperty(Transaction.prototype, "outputAmount", ioProperty);
    Transaction.prototype._getHash = function() {
      return Hash.sha256sha256(this.toBuffer());
    };
    Transaction.prototype.serialize = function(unsafe) {
      if (true === unsafe || unsafe && unsafe.disableAll) {
        return this.uncheckedSerialize();
      } else {
        return this.checkedSerialize(unsafe);
      }
    };
    Transaction.prototype.uncheckedSerialize = Transaction.prototype.toString = function() {
      return this.toBuffer().toString("hex");
    };
    Transaction.prototype.checkedSerialize = function(opts) {
      var serializationError = this.getSerializationError(opts);
      if (serializationError) {
        serializationError.message += " - For more information please see: https://bitcore.io/api/lib/transaction#serialization-checks";
        throw serializationError;
      }
      return this.uncheckedSerialize();
    };
    Transaction.prototype.invalidSatoshis = function() {
      var invalid = false;
      for (var i = 0; i < this.outputs.length; i++) {
        if (this.outputs[i].invalidSatoshis()) {
          invalid = true;
        }
      }
      return invalid;
    };
    Transaction.prototype.getSerializationError = function(opts) {
      opts = opts || {};
      if (this.invalidSatoshis()) {
        return new errors.Transaction.InvalidSatoshis();
      }
      var unspent = this._getUnspentValue();
      var unspentError;
      if (unspent < 0) {
        if (!opts.disableMoreOutputThanInput) {
          unspentError = new errors.Transaction.InvalidOutputAmountSum();
        }
      } else {
        unspentError = this._hasFeeError(opts, unspent);
      }
      return unspentError || this._hasDustOutputs(opts) || this._isMissingSignatures(opts);
    };
    Transaction.prototype._hasFeeError = function(opts, unspent) {
      if (!_.isUndefined(this._fee) && this._fee !== unspent) {
        return new errors.Transaction.FeeError.Different(
          "Unspent value is " + unspent + " but specified fee is " + this._fee
        );
      }
      if (!opts.disableLargeFees) {
        var maximumFee = Math.floor(Transaction.FEE_SECURITY_MARGIN * this._estimateFee());
        if (unspent > maximumFee) {
          if (this._missingChange()) {
            return new errors.Transaction.ChangeAddressMissing(
              "Fee is too large and no change address was provided"
            );
          }
          return new errors.Transaction.FeeError.TooLarge(
            "expected less than " + maximumFee + " but got " + unspent
          );
        }
      }
      if (!opts.disableSmallFees) {
        var minimumFee = Math.ceil(this._estimateFee() / Transaction.FEE_SECURITY_MARGIN);
        if (unspent < minimumFee) {
          return new errors.Transaction.FeeError.TooSmall(
            "expected more than " + minimumFee + " but got " + unspent
          );
        }
      }
    };
    Transaction.prototype._missingChange = function() {
      return !this._changeScript;
    };
    Transaction.prototype._hasDustOutputs = function(opts) {
      if (opts.disableDustOutputs) {
        return;
      }
      var index, output;
      for (index in this.outputs) {
        output = this.outputs[index];
        if (output.satoshis < Transaction.DUST_AMOUNT && !output.script.isDataOut()) {
          return new errors.Transaction.DustOutputs();
        }
      }
    };
    Transaction.prototype._isMissingSignatures = function(opts) {
      if (opts.disableIsFullySigned) {
        return;
      }
      if (!this.isFullySigned()) {
        return new errors.Transaction.MissingSignatures();
      }
    };
    Transaction.prototype.inspect = function() {
      return "<Transaction: " + this.uncheckedSerialize() + ">";
    };
    Transaction.prototype.toBuffer = function() {
      var writer = new BufferWriter();
      return this.toBufferWriter(writer).toBuffer();
    };
    Transaction.prototype.toBufferWriter = function(writer) {
      writer.writeInt32LE(this.version);
      writer.writeVarintNum(this.inputs.length);
      _.each(this.inputs, function(input) {
        input.toBufferWriter(writer);
      });
      writer.writeVarintNum(this.outputs.length);
      _.each(this.outputs, function(output) {
        output.toBufferWriter(writer);
      });
      writer.writeUInt32LE(this.nLockTime);
      return writer;
    };
    Transaction.prototype.fromBuffer = function(buffer2) {
      var reader = new BufferReader(buffer2);
      return this.fromBufferReader(reader);
    };
    Transaction.prototype.fromBufferReader = function(reader) {
      $.checkArgument(!reader.finished(), "No transaction data received");
      var i, sizeTxIns, sizeTxOuts;
      this.version = reader.readInt32LE();
      sizeTxIns = reader.readVarintNum();
      for (i = 0; i < sizeTxIns; i++) {
        var input = Input.fromBufferReader(reader);
        this.inputs.push(input);
      }
      sizeTxOuts = reader.readVarintNum();
      for (i = 0; i < sizeTxOuts; i++) {
        this.outputs.push(Output.fromBufferReader(reader));
      }
      this.nLockTime = reader.readUInt32LE();
      return this;
    };
    Transaction.prototype.toObject = Transaction.prototype.toJSON = function toObject() {
      var inputs = [];
      this.inputs.forEach(function(input) {
        inputs.push(input.toObject());
      });
      var outputs = [];
      this.outputs.forEach(function(output) {
        outputs.push(output.toObject());
      });
      var obj = {
        hash: this.hash,
        version: this.version,
        inputs,
        outputs,
        nLockTime: this.nLockTime
      };
      if (this._changeScript) {
        obj.changeScript = this._changeScript.toString();
      }
      if (!_.isUndefined(this._changeIndex)) {
        obj.changeIndex = this._changeIndex;
      }
      if (!_.isUndefined(this._fee)) {
        obj.fee = this._fee;
      }
      return obj;
    };
    Transaction.prototype.fromObject = function fromObject(arg) {
      $.checkArgument(_.isObject(arg) || arg instanceof Transaction);
      var self2 = this;
      var transaction;
      if (arg instanceof Transaction) {
        transaction = transaction.toObject();
      } else {
        transaction = arg;
      }
      _.each(transaction.inputs, function(input) {
        if (!input.output || !input.output.script) {
          self2.uncheckedAddInput(new Input(input));
          return;
        }
        var script = new Script(input.output.script);
        var txin;
        if (script.isPublicKeyHashOut()) {
          txin = new Input.PublicKeyHash(input);
        } else if (script.isScriptHashOut() && input.publicKeys && input.threshold) {
          txin = new Input.MultiSigScriptHash(
            input,
            input.publicKeys,
            input.threshold,
            input.signatures
          );
        } else if (script.isPublicKeyOut()) {
          txin = new Input.PublicKey(input);
        } else {
          throw new errors.Transaction.Input.UnsupportedScript(input.output.script);
        }
        self2.addInput(txin);
      });
      _.each(transaction.outputs, function(output) {
        self2.addOutput(new Output(output));
      });
      if (transaction.changeIndex) {
        this._changeIndex = transaction.changeIndex;
      }
      if (transaction.changeScript) {
        this._changeScript = new Script(transaction.changeScript);
      }
      if (transaction.fee) {
        this._fee = transaction.fee;
      }
      this.nLockTime = transaction.nLockTime;
      this.version = transaction.version;
      this._checkConsistency(arg);
      return this;
    };
    Transaction.prototype._checkConsistency = function(arg) {
      if (!_.isUndefined(this._changeIndex)) {
        $.checkState(this._changeScript, "Change script is expected.");
        $.checkState(this.outputs[this._changeIndex], "Change index points to undefined output.");
        $.checkState(this.outputs[this._changeIndex].script.toString() === this._changeScript.toString(), "Change output has an unexpected script.");
      }
      if (arg && arg.hash) {
        $.checkState(arg.hash === this.hash, "Hash in object does not match transaction hash.");
      }
    };
    Transaction.prototype.lockUntilDate = function(time) {
      $.checkArgument(time);
      if (_.isNumber(time) && time < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        throw new errors.Transaction.LockTimeTooEarly();
      }
      if (_.isDate(time)) {
        time = time.getTime() / 1e3;
      }
      for (var i = 0; i < this.inputs.length; i++) {
        if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
          this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
        }
      }
      this.nLockTime = time;
      return this;
    };
    Transaction.prototype.lockUntilBlockHeight = function(height) {
      $.checkArgument(_.isNumber(height));
      if (height >= Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        throw new errors.Transaction.BlockHeightTooHigh();
      }
      if (height < 0) {
        throw new errors.Transaction.NLockTimeOutOfRange();
      }
      for (var i = 0; i < this.inputs.length; i++) {
        if (this.inputs[i].sequenceNumber === Input.DEFAULT_SEQNUMBER) {
          this.inputs[i].sequenceNumber = Input.DEFAULT_LOCKTIME_SEQNUMBER;
        }
      }
      this.nLockTime = height;
      return this;
    };
    Transaction.prototype.getLockTime = function() {
      if (!this.nLockTime) {
        return null;
      }
      if (this.nLockTime < Transaction.NLOCKTIME_BLOCKHEIGHT_LIMIT) {
        return this.nLockTime;
      }
      return new Date(1e3 * this.nLockTime);
    };
    Transaction.prototype.fromString = function(string) {
      this.fromBuffer(buffer.Buffer.from(string, "hex"));
    };
    Transaction.prototype._newTransaction = function() {
      this.version = CURRENT_VERSION;
      this.nLockTime = DEFAULT_NLOCKTIME;
    };
    Transaction.prototype.from = function(utxo, pubkeys, threshold, opts) {
      if (_.isArray(utxo)) {
        var self2 = this;
        _.each(utxo, function(utxo2) {
          self2.from(utxo2, pubkeys, threshold, opts);
        });
        return this;
      }
      var exists = _.some(this.inputs, function(input) {
        return input.prevTxId.toString("hex") === utxo.txId && input.outputIndex === utxo.outputIndex;
      });
      if (exists) {
        return this;
      }
      if (pubkeys && threshold) {
        this._fromMultisigUtxo(utxo, pubkeys, threshold, opts);
      } else if (utxo.publicKeys && utxo.publicKeys.length > 1) {
        this._fromEscrowUtxo(utxo, utxo.publicKeys);
      } else {
        this._fromNonP2SH(utxo);
      }
      return this;
    };
    Transaction.prototype.associateInputs = function(utxos, pubkeys, threshold, opts) {
      let indexes = [];
      for (let utxo of utxos) {
        const index = this.inputs.findIndex((i) => i.prevTxId.toString("hex") === utxo.txId && i.outputIndex === utxo.outputIndex);
        indexes.push(index);
        if (index >= 0) {
          this.inputs[index] = this._getInputFrom(utxo, pubkeys, threshold, opts);
        }
      }
      return indexes;
    };
    Transaction.prototype._selectInputType = function(utxo, pubkeys, threshold) {
      var clazz;
      utxo = new UnspentOutput(utxo);
      if (pubkeys && threshold) {
        if (utxo.script.isMultisigOut()) {
          clazz = MultiSigInput;
        } else if (utxo.script.isScriptHashOut() || utxo.script.isWitnessScriptHashOut()) {
          clazz = MultiSigScriptHashInput;
        }
      } else if (utxo.script.isPublicKeyHashOut() || utxo.script.isWitnessPublicKeyHashOut() || utxo.script.isScriptHashOut()) {
        clazz = PublicKeyHashInput;
      } else if (utxo.script.isPublicKeyOut()) {
        clazz = PublicKeyInput;
      } else {
        clazz = Input;
      }
      return clazz;
    };
    Transaction.prototype._getInputFrom = function(utxo, pubkeys, threshold, opts) {
      utxo = new UnspentOutput(utxo);
      const InputClass = this._selectInputType(utxo, pubkeys, threshold);
      const input = {
        output: new Output({
          script: utxo.script,
          satoshis: utxo.satoshis
        }),
        prevTxId: utxo.txId,
        outputIndex: utxo.outputIndex,
        sequenceNumber: utxo.sequenceNumber,
        script: Script.empty()
      };
      let args = pubkeys && threshold ? [pubkeys, threshold, false, opts] : [];
      return new InputClass(input, ...args);
    };
    Transaction.prototype._fromEscrowUtxo = function(utxo, pubkeys) {
      const publicKeys = pubkeys.map((pubkey) => new PublicKey(pubkey));
      const inputPublicKeys = publicKeys.slice(1);
      const reclaimPublicKey = publicKeys[0];
      utxo = new UnspentOutput(utxo);
      this.addInput(
        new EscrowInput(
          {
            output: new Output({
              script: utxo.script,
              satoshis: utxo.satoshis
            }),
            prevTxId: utxo.txId,
            outputIndex: utxo.outputIndex,
            script: Script.empty()
          },
          inputPublicKeys,
          reclaimPublicKey
        )
      );
    };
    Transaction.prototype._fromNonP2SH = function(utxo) {
      var clazz;
      utxo = new UnspentOutput(utxo);
      if (utxo.script.isPublicKeyHashOut()) {
        clazz = PublicKeyHashInput;
      } else if (utxo.script.isPublicKeyOut()) {
        clazz = PublicKeyInput;
      } else {
        clazz = Input;
      }
      this.addInput(new clazz({
        output: new Output({
          script: utxo.script,
          satoshis: utxo.satoshis
        }),
        prevTxId: utxo.txId,
        outputIndex: utxo.outputIndex,
        script: Script.empty()
      }));
    };
    Transaction.prototype._fromMultisigUtxo = function(utxo, pubkeys, threshold, opts) {
      $.checkArgument(
        threshold <= pubkeys.length,
        "Number of required signatures must be greater than the number of public keys"
      );
      var clazz;
      utxo = new UnspentOutput(utxo);
      if (utxo.script.isMultisigOut()) {
        clazz = MultiSigInput;
      } else if (utxo.script.isScriptHashOut()) {
        clazz = MultiSigScriptHashInput;
      } else {
        throw new Error("@TODO");
      }
      this.addInput(new clazz({
        output: new Output({
          script: utxo.script,
          satoshis: utxo.satoshis
        }),
        prevTxId: utxo.txId,
        outputIndex: utxo.outputIndex,
        script: Script.empty()
      }, pubkeys, threshold, void 0, opts));
    };
    Transaction.prototype.addInput = function(input, outputScript, satoshis) {
      $.checkArgumentType(input, Input, "input");
      if (!input.output && (_.isUndefined(outputScript) || _.isUndefined(satoshis))) {
        throw new errors.Transaction.NeedMoreInfo("Need information about the UTXO script and satoshis");
      }
      if (!input.output && outputScript && !_.isUndefined(satoshis)) {
        outputScript = outputScript instanceof Script ? outputScript : new Script(outputScript);
        $.checkArgumentType(satoshis, "number", "satoshis");
        input.output = new Output({
          script: outputScript,
          satoshis
        });
      }
      return this.uncheckedAddInput(input);
    };
    Transaction.prototype.uncheckedAddInput = function(input) {
      $.checkArgumentType(input, Input, "input");
      this.inputs.push(input);
      this._inputAmount = void 0;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.hasAllUtxoInfo = function() {
      return _.every(this.inputs.map(function(input) {
        return !!input.output;
      }));
    };
    Transaction.prototype.fee = function(amount) {
      $.checkArgument(_.isNumber(amount), "amount must be a number");
      this._fee = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.feePerKb = function(amount) {
      $.checkArgument(_.isNumber(amount), "amount must be a number");
      this._feePerKb = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.feePerByte = function(amount) {
      $.checkArgument(_.isNumber(amount), "amount must be a number");
      this._feePerByte = amount;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.change = function(address) {
      $.checkArgument(address, "address is required");
      this._changeScript = Script.fromAddress(address);
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.escrow = function(address, amount) {
      $.checkArgument(this.inputs.length > 0, "inputs must have already been set when setting escrow");
      $.checkArgument(this.outputs.length > 0, "non-change outputs must have already been set when setting escrow");
      $.checkArgument(!this.getChangeOutput(), "change must still be unset when setting escrow");
      $.checkArgument(address, "address is required");
      $.checkArgument(amount, "amount is required");
      const totalSendAmountWithoutChange = this._getOutputAmount() + this.getFee() + amount;
      const hasChange = this._getInputAmount() - totalSendAmountWithoutChange > Transaction.DUST_AMOUNT;
      this.to(address, amount);
      if (!hasChange) {
        this._fee = void 0;
      }
      return this;
    };
    Transaction.prototype.getChangeOutput = function() {
      if (!_.isUndefined(this._changeIndex)) {
        return this.outputs[this._changeIndex];
      }
      return null;
    };
    Transaction.prototype.to = function(address, amount) {
      if (_.isArray(address)) {
        var self2 = this;
        _.each(address, function(to) {
          self2.to(to.address, to.satoshis);
        });
        return this;
      }
      $.checkArgument(
        JSUtil.isNaturalNumber(amount),
        "Amount is expected to be a positive integer"
      );
      this.addOutput(new Output({
        script: Script(new Address(address)),
        satoshis: amount
      }));
      return this;
    };
    Transaction.prototype.addData = function(value) {
      this.addOutput(new Output({
        script: Script.buildDataOut(value),
        satoshis: 0
      }));
      return this;
    };
    Transaction.prototype.addOutput = function(output) {
      $.checkArgumentType(output, Output, "output");
      this._addOutput(output);
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype.clearOutputs = function() {
      this.outputs = [];
      this._clearSignatures();
      this._outputAmount = void 0;
      this._changeIndex = void 0;
      this._updateChangeOutput();
      return this;
    };
    Transaction.prototype._addOutput = function(output) {
      this.outputs.push(output);
      this._outputAmount = void 0;
    };
    Transaction.prototype._getOutputAmount = function() {
      if (_.isUndefined(this._outputAmount)) {
        var self2 = this;
        this._outputAmount = 0;
        _.each(this.outputs, function(output) {
          self2._outputAmount += output.satoshis;
        });
      }
      return this._outputAmount;
    };
    Transaction.prototype._getInputAmount = function() {
      if (_.isUndefined(this._inputAmount)) {
        this._inputAmount = _.sumBy(this.inputs, function(input) {
          if (_.isUndefined(input.output)) {
            throw new errors.Transaction.Input.MissingPreviousOutput();
          }
          return input.output.satoshis;
        });
      }
      return this._inputAmount;
    };
    Transaction.prototype._updateChangeOutput = function() {
      if (!this._changeScript) {
        return;
      }
      this._clearSignatures();
      if (!_.isUndefined(this._changeIndex)) {
        this._removeOutput(this._changeIndex);
      }
      var available = this._getUnspentValue();
      var fee = this.getFee();
      var changeAmount = available - fee;
      if (changeAmount >= Transaction.DUST_AMOUNT) {
        this._changeIndex = this.outputs.length;
        this._addOutput(new Output({
          script: this._changeScript,
          satoshis: changeAmount
        }));
      } else {
        this._changeIndex = void 0;
      }
    };
    Transaction.prototype.getFee = function() {
      if (this.isCoinbase()) {
        return 0;
      }
      if (!_.isUndefined(this._fee)) {
        return this._fee;
      }
      if (!this._changeScript) {
        return this._getUnspentValue();
      }
      return this._estimateFee();
    };
    Transaction.prototype._estimateFee = function() {
      var estimatedSize = this._estimateSize();
      var available = this._getUnspentValue();
      var feeRate = this._feePerByte || (this._feePerKb || Transaction.FEE_PER_KB) / 1e3;
      function getFee(size) {
        return size * feeRate;
      }
      var fee = Math.ceil(getFee(estimatedSize));
      var feeWithChange = Math.ceil(getFee(estimatedSize) + getFee(Transaction.CHANGE_OUTPUT_MAX_SIZE));
      if (!this._changeScript || available <= feeWithChange) {
        return fee;
      }
      return feeWithChange;
    };
    Transaction.prototype._getUnspentValue = function() {
      return this._getInputAmount() - this._getOutputAmount();
    };
    Transaction.prototype._clearSignatures = function() {
      _.each(this.inputs, function(input) {
        input.clearSignatures();
      });
    };
    Transaction.prototype._estimateSize = function() {
      var result = Transaction.MAXIMUM_EXTRA_SIZE;
      _.each(this.inputs, function(input) {
        let scriptSigLen = input._estimateSize();
        let varintLen = BufferWriter.varintBufNum(scriptSigLen).length;
        result += 36 + varintLen + scriptSigLen;
      });
      _.each(this.outputs, function(output) {
        result += output.script.toBuffer().length + 9;
      });
      return result;
    };
    Transaction.prototype._removeOutput = function(index) {
      var output = this.outputs[index];
      this.outputs = _.without(this.outputs, output);
      this._outputAmount = void 0;
    };
    Transaction.prototype.removeOutput = function(index) {
      this._removeOutput(index);
      this._updateChangeOutput();
    };
    Transaction.prototype.sort = function() {
      this.sortInputs(function(inputs) {
        var copy = Array.prototype.concat.apply([], inputs);
        let i = 0;
        copy.forEach((x) => {
          x.i = i++;
        });
        copy.sort(function(first, second) {
          return compare(first.prevTxId, second.prevTxId) || first.outputIndex - second.outputIndex || first.i - second.i;
        });
        return copy;
      });
      this.sortOutputs(function(outputs) {
        var copy = Array.prototype.concat.apply([], outputs);
        let i = 0;
        copy.forEach((x) => {
          x.i = i++;
        });
        copy.sort(function(first, second) {
          return first.satoshis - second.satoshis || compare(first.script.toBuffer(), second.script.toBuffer()) || first.i - second.i;
        });
        return copy;
      });
      return this;
    };
    Transaction.prototype.shuffleOutputs = function() {
      return this.sortOutputs(_.shuffle);
    };
    Transaction.prototype.sortOutputs = function(sortingFunction) {
      var outs = sortingFunction(this.outputs);
      return this._newOutputOrder(outs);
    };
    Transaction.prototype.sortInputs = function(sortingFunction) {
      this.inputs = sortingFunction(this.inputs);
      this._clearSignatures();
      return this;
    };
    Transaction.prototype._newOutputOrder = function(newOutputs) {
      var isInvalidSorting = this.outputs.length !== newOutputs.length || _.difference(this.outputs, newOutputs).length !== 0;
      if (isInvalidSorting) {
        throw new errors.Transaction.InvalidSorting();
      }
      if (!_.isUndefined(this._changeIndex)) {
        var changeOutput = this.outputs[this._changeIndex];
        this._changeIndex = _.findIndex(newOutputs, changeOutput);
      }
      this.outputs = newOutputs;
      return this;
    };
    Transaction.prototype.removeInput = function(txId, outputIndex) {
      var index;
      if (!outputIndex && _.isNumber(txId)) {
        index = txId;
      } else {
        index = _.findIndex(this.inputs, function(input2) {
          return input2.prevTxId.toString("hex") === txId && input2.outputIndex === outputIndex;
        });
      }
      if (index < 0 || index >= this.inputs.length) {
        throw new errors.Transaction.InvalidIndex(index, this.inputs.length);
      }
      var input = this.inputs[index];
      this.inputs = _.without(this.inputs, input);
      this._inputAmount = void 0;
      this._updateChangeOutput();
    };
    Transaction.prototype.sign = function(privateKey, sigtype, signingMethod) {
      signingMethod = signingMethod || "ecdsa";
      $.checkState(this.hasAllUtxoInfo(), "Not all utxo information is available to sign the transaction.");
      var self2 = this;
      if (_.isArray(privateKey)) {
        _.each(privateKey, function(privateKey2) {
          self2.sign(privateKey2, sigtype, signingMethod);
        });
        return this;
      }
      _.each(this.getSignatures(privateKey, sigtype, signingMethod), function(signature) {
        self2.applySignature(signature, signingMethod);
      });
      return this;
    };
    Transaction.prototype.getSignatures = function(privKey, sigtype, signingMethod) {
      privKey = new PrivateKey(privKey);
      sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      var transaction = this;
      var results = [];
      var hashData = Hash.sha256ripemd160(privKey.publicKey.toBuffer());
      for (let index = 0; index < this.inputs.length; index++) {
        var input = this.inputs[index];
        var signatures = input.getSignatures(transaction, privKey, index, sigtype, hashData, signingMethod);
        for (let signature of signatures) {
          results.push(signature);
        }
      }
      return results;
    };
    Transaction.prototype.applySignature = function(signature, signingMethod) {
      this.inputs[signature.inputIndex].addSignature(this, signature, signingMethod);
      return this;
    };
    Transaction.prototype.isFullySigned = function() {
      _.each(this.inputs, function(input) {
        if (input.isFullySigned === Input.prototype.isFullySigned) {
          throw new errors.Transaction.UnableToVerifySignature(
            "Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction"
          );
        }
      });
      return _.every(_.map(this.inputs, function(input) {
        return input.isFullySigned();
      }));
    };
    Transaction.prototype.isValidSignature = function(signature) {
      var self2 = this;
      if (this.inputs[signature.inputIndex].isValidSignature === Input.prototype.isValidSignature) {
        throw new errors.Transaction.UnableToVerifySignature(
          "Unrecognized script kind, or not enough information to execute script.This usually happens when creating a transaction from a serialized transaction"
        );
      }
      return this.inputs[signature.inputIndex].isValidSignature(self2, signature);
    };
    Transaction.prototype.verifySignature = function(sig, pubkey, nin, subscript, satoshisBN, flags, signingMethod) {
      return Sighash.verify(this, sig, pubkey, nin, subscript, satoshisBN, flags, signingMethod);
    };
    Transaction.prototype.validateTokens = function() {
      const tokenInputs = this.inputs.filter((input) => input.output.tokenData);
      const tokenOutputs = this.outputs.filter((output) => output.tokenData);
      const outputsGroupedByCategory = _.groupBy(tokenOutputs, (output) => output.tokenData.category);
      Object.values(outputsGroupedByCategory).forEach((categoryOutputs) => {
        const category = categoryOutputs[0].tokenData.category;
        let unusedCategoryInputs = tokenInputs.filter((input) => input.output.tokenData.category === category);
        const inputFungibleAmount = unusedCategoryInputs.reduce((sum, input) => {
          const tokenAmount = input.output.tokenData.amount;
          return tokenAmount ? sum.add(tokenAmount) : sum;
        }, new BN(0));
        let mintedAmount = new BN(0);
        let sentAmount = new BN(0);
        categoryOutputs.forEach((output) => {
          const mintingUtxo = this.inputs.find((input) => input.prevTxId.toString("hex") === output.tokenData.category);
          const tokenAmount = output.tokenData.amount;
          if (mintingUtxo) {
            if (mintingUtxo.outputIndex !== 0) {
              throw new Error("the transaction creates an immutable token for a category without a matching minting token or sufficient mutable tokens.");
            }
            mintedAmount = mintedAmount.add(tokenAmount);
          } else {
            if (output.tokenData.nft) {
              const parentUtxo = unusedCategoryInputs.filter((input) => input.output.tokenData.nft).find((input) => {
                if (output.tokenData.nft.capability === "none") {
                  if (input.output.tokenData.nft.commitment === output.tokenData.nft.commitment) {
                    return true;
                  }
                  return input.output.tokenData.nft.capability !== "none";
                }
                return input.output.tokenData.nft.capability !== "none";
              });
              if (!parentUtxo) {
                throw new Error("the transaction creates an immutable token for a category without a matching minting token or sufficient mutable tokens.");
              }
              if (parentUtxo.output.tokenData.nft.capability !== "minting") {
                unusedCategoryInputs = unusedCategoryInputs.filter((input) => !(input.prevTxId === parentUtxo.prevTxId && input.outputIndex === parentUtxo.outputIndex));
              }
            }
            sentAmount = sentAmount.add(tokenAmount);
          }
        });
        if (mintedAmount.gt(new BN("9223372036854775807"))) {
          throw new Error("the transaction outputs include a sum of fungible tokens for a category exceeding the maximum supply (9223372036854775807)");
        }
        if (sentAmount.gt(inputFungibleAmount)) {
          throw new Error("the sum of fungible tokens in the transaction's outputs exceed that of the transactions inputs for a category");
        }
      });
      return true;
    };
    Transaction.prototype.verify = function() {
      if (this.inputs.length === 0) {
        return "transaction txins empty";
      }
      if (this.outputs.length === 0) {
        return "transaction txouts empty";
      }
      var valueoutbn = new BN(0);
      for (var i = 0; i < this.outputs.length; i++) {
        var txout = this.outputs[i];
        if (txout.invalidSatoshis()) {
          return "transaction txout " + i + " satoshis is invalid";
        }
        if (txout._satoshisBN.gt(new BN(Transaction.MAX_MONEY, 10))) {
          return "transaction txout " + i + " greater than MAX_MONEY";
        }
        valueoutbn = valueoutbn.add(txout._satoshisBN);
        if (valueoutbn.gt(new BN(Transaction.MAX_MONEY))) {
          return "transaction txout " + i + " total output greater than MAX_MONEY";
        }
      }
      if (this.toBuffer().length > MAX_BLOCK_SIZE) {
        return "transaction over the maximum block size";
      }
      var txinmap = {};
      for (i = 0; i < this.inputs.length; i++) {
        var txin = this.inputs[i];
        var inputid = txin.prevTxId + ":" + txin.outputIndex;
        if (!_.isUndefined(txinmap[inputid])) {
          return "transaction input " + i + " duplicate input";
        }
        txinmap[inputid] = true;
      }
      var isCoinbase = this.isCoinbase();
      if (isCoinbase) {
        var buf = this.inputs[0]._scriptBuffer;
        if (buf.length < 2 || buf.length > 100) {
          return "coinbase transaction script size invalid";
        }
      } else {
        for (i = 0; i < this.inputs.length; i++) {
          if (this.inputs[i].isNull()) {
            return "transaction input " + i + " has null input";
          }
        }
      }
      return true;
    };
    Transaction.prototype.isZceSecured = function(escrowReclaimTx, instantAcceptanceEscrow, requiredFeeRate) {
      if (this.inputs.length > 65536) {
        return false;
      }
      const allInputsAreP2pkh = this.inputs.every((input) => input.script.isPublicKeyHashIn());
      if (!allInputsAreP2pkh) {
        return false;
      }
      const escrowInputIndex = 0;
      let reclaimTx;
      try {
        reclaimTx = new Transaction(escrowReclaimTx);
      } catch (e) {
        return false;
      }
      const escrowInput = reclaimTx.inputs[escrowInputIndex];
      if (escrowInput.prevTxId.toString("hex") !== this.id) {
        return false;
      }
      const escrowUtxo = this.outputs[escrowInput.outputIndex];
      if (!escrowUtxo) {
        return false;
      }
      const zceRawTx = this.uncheckedSerialize();
      const zceTxSize = zceRawTx.length / 2;
      const minFee = zceTxSize * requiredFeeRate;
      if (escrowUtxo.toObject().satoshis < instantAcceptanceEscrow + minFee) {
        return false;
      }
      escrowInput.output = escrowUtxo;
      const reclaimTxSize = escrowReclaimTx.length / 2;
      const reclaimTxFeeRate = reclaimTx.getFee() / reclaimTxSize;
      if (reclaimTxFeeRate < requiredFeeRate) {
        return false;
      }
      const escrowUnlockingScriptParts = escrowInput.script.toASM().split(" ");
      if (escrowUnlockingScriptParts.length !== 3) {
        return false;
      }
      const [reclaimSignatureString, reclaimPublicKeyString, redeemScriptString] = escrowUnlockingScriptParts;
      const reclaimPublicKey = new PublicKey(reclaimPublicKeyString);
      const inputPublicKeys = this.inputs.map((input) => new PublicKey(input.script.getPublicKey()));
      const inputSignatureStrings = this.inputs.map((input) => input.script.toASM().split(" ")[0]);
      const sighashAll = Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;
      const allSignaturesSighashAll = [reclaimSignatureString, ...inputSignatureStrings].every(
        (signatureString) => signatureString.endsWith(sighashAll.toString(16))
      );
      if (!allSignaturesSighashAll) {
        return false;
      }
      const correctEscrowRedeemScript = Script.buildEscrowOut(inputPublicKeys, reclaimPublicKey);
      const correctEscrowRedeemScriptHash = Hash.sha256ripemd160(correctEscrowRedeemScript.toBuffer());
      const escrowUtxoRedeemScriptHash = escrowUtxo.script.getData();
      const escrowInputRedeemScript = new Script(redeemScriptString);
      const escrowInputRedeemScriptHash = Hash.sha256ripemd160(escrowInputRedeemScript.toBuffer());
      const allRedeemScriptHashes = [
        correctEscrowRedeemScriptHash,
        escrowInputRedeemScriptHash,
        escrowUtxoRedeemScriptHash
      ].map((hash) => hash.toString("hex"));
      if (!allRedeemScriptHashes.every((hash) => hash === allRedeemScriptHashes[0])) {
        return false;
      }
      const reclaimSignature = Signature.fromTxString(reclaimSignatureString);
      reclaimSignature.nhashtype = sighashAll;
      const reclaimSigValid = reclaimTx.verifySignature(
        reclaimSignature,
        reclaimPublicKey,
        escrowInputIndex,
        escrowInputRedeemScript,
        escrowUtxo.satoshisBN,
        void 0,
        reclaimSignature.isSchnorr ? "schnorr" : "ecdsa"
      );
      if (!reclaimSigValid) {
        return false;
      }
      return true;
    };
    Transaction.prototype.isCoinbase = function() {
      return this.inputs.length === 1 && this.inputs[0].isNull();
    };
    Transaction.prototype.setVersion = function(version) {
      $.checkArgument(
        JSUtil.isNaturalNumber(version) && version <= CURRENT_VERSION,
        "Wrong version number"
      );
      this.version = version;
      return this;
    };
    module.exports = Transaction;
  }
});

// node_modules/bitcore-lib-cash/lib/transaction/index.js
var require_transaction2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/transaction/index.js"(exports, module) {
    module.exports = require_transaction();
    module.exports.Input = require_input2();
    module.exports.Output = require_output();
    module.exports.UnspentOutput = require_unspentoutput();
    module.exports.Signature = require_signature4();
    module.exports.Sighash = require_sighash();
  }
});

// node_modules/bitcore-lib-cash/lib/script/interpreter.js
var require_interpreter = __commonJS({
  "node_modules/bitcore-lib-cash/lib/script/interpreter.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var Script = require_script();
    var Opcode = require_opcode();
    var BN = require_bn2();
    var Hash = require_hash2();
    var Signature = require_signature3();
    var PublicKey = require_publickey2();
    var ECDSA = require_ecdsa();
    var Schnorr = require_schnorr();
    var BufferWriter = require_bufferwriter();
    var Interpreter = function Interpreter2(obj) {
      if (!(this instanceof Interpreter2)) {
        return new Interpreter2(obj);
      }
      if (obj) {
        this.initialize();
        this.set(obj);
      } else {
        this.initialize();
      }
    };
    Interpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags, satoshisBN) {
      var Transaction = require_transaction2();
      this.nSigChecks = 0;
      if (_.isUndefined(tx)) {
        tx = new Transaction();
      }
      if (_.isUndefined(nin)) {
        nin = 0;
      }
      if (_.isUndefined(flags)) {
        flags = 0;
      }
      if (flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {
        flags |= Interpreter.SCRIPT_VERIFY_STRICTENC;
        if (!satoshisBN) {
          throw new Error("internal error - need satoshisBN to verify FORKID transactions");
        }
        if (tx.toBuffer().length < 65) {
          throw new Error("bad-txns-undersize");
        }
      }
      this.set({
        script: scriptSig,
        tx,
        nin,
        flags,
        satoshisBN
      });
      var stackCopy;
      if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {
        this.errstr = "SCRIPT_ERR_SIG_PUSHONLY";
        return false;
      }
      if (!this.evaluate()) {
        return false;
      }
      if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {
        stackCopy = this.stack.slice();
      }
      var stack = this.stack;
      this.initialize();
      this.set({
        script: scriptPubkey,
        stack,
        tx,
        nin,
        flags,
        satoshisBN
      });
      if (!this.evaluate()) {
        return false;
      }
      if (this.stack.length === 0) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_RESULT";
        return false;
      }
      var buf = this.stack[this.stack.length - 1];
      if (!Interpreter.castToBool(buf)) {
        this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_STACK";
        return false;
      }
      const fEnableP2SH32 = (flags & Interpreter.SCRIPT_ENABLE_P2SH_32) !== 0;
      if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut(fEnableP2SH32)) {
        if (!scriptSig.isPushOnly()) {
          this.errstr = "SCRIPT_ERR_SIG_PUSHONLY";
          return false;
        }
        if (stackCopy.length === 0) {
          throw new Error("internal error - stack copy empty");
        }
        var redeemScriptSerialized = stackCopy[stackCopy.length - 1];
        var redeemScript = Script.fromBuffer(redeemScriptSerialized);
        stackCopy.pop();
        this.initialize();
        this.set({
          script: redeemScript,
          stack: stackCopy,
          tx,
          nin,
          flags,
          satoshisBN
        });
        if ((flags & Interpreter.SCRIPT_DISALLOW_SEGWIT_RECOVERY) == 0 && stackCopy.length === 0 && redeemScript.isWitnessProgram()) {
          return true;
        }
        if (!this.evaluate()) {
          return false;
        }
        if (stackCopy.length === 0) {
          this.errstr = "SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK";
          return false;
        }
        if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {
          this.errstr = "SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK";
          return false;
        }
      }
      if ((flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {
        if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0) {
          throw new Error("internal error - CLEANSTACK without P2SH");
        }
        if (this.stack.length != 1) {
          this.errstr = "SCRIPT_ERR_CLEANSTACK";
          return false;
        }
      }
      if (flags & Interpreter.SCRIPT_VERIFY_INPUT_SIGCHECKS) {
        if (scriptSig.toBuffer().length < this.nSigChecks * 43 - 60) {
          return false;
        }
      }
      return true;
    };
    module.exports = Interpreter;
    Interpreter.prototype.initialize = function(obj) {
      this.stack = [];
      this.altstack = [];
      this.pc = 0;
      this.pbegincodehash = 0;
      this.nOpCount = 0;
      this.vfExec = [];
      this.errstr = "";
      this.flags = 0;
    };
    Interpreter.prototype.set = function(obj) {
      this.script = obj.script || this.script;
      this.tx = obj.tx || this.tx;
      this.nin = typeof obj.nin !== "undefined" ? obj.nin : this.nin;
      this.satoshisBN = obj.satoshisBN || this.satoshisBN;
      this.stack = obj.stack || this.stack;
      this.altstack = obj.altack || this.altstack;
      this.pc = typeof obj.pc !== "undefined" ? obj.pc : this.pc;
      this.pbegincodehash = typeof obj.pbegincodehash !== "undefined" ? obj.pbegincodehash : this.pbegincodehash;
      this.nOpCount = typeof obj.nOpCount !== "undefined" ? obj.nOpCount : this.nOpCount;
      this.vfExec = obj.vfExec || this.vfExec;
      this.errstr = obj.errstr || this.errstr;
      this.flags = typeof obj.flags !== "undefined" ? obj.flags : this.flags;
    };
    Interpreter.true = Buffer.from([1]);
    Interpreter.false = Buffer.from([]);
    Interpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;
    Interpreter.MAXIMUM_ELEMENT_SIZE = 4;
    Interpreter.LOCKTIME_THRESHOLD = 5e8;
    Interpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);
    Interpreter.SCRIPT_VERIFY_NONE = 0;
    Interpreter.SCRIPT_VERIFY_P2SH = 1 << 0;
    Interpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1;
    Interpreter.SCRIPT_VERIFY_DERSIG = 1 << 2;
    Interpreter.SCRIPT_VERIFY_LOW_S = 1 << 3;
    Interpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4;
    Interpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5;
    Interpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6;
    Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7;
    Interpreter.SCRIPT_VERIFY_CLEANSTACK = 1 << 8;
    Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;
    Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1 << 10;
    Interpreter.SCRIPT_VERIFY_MINIMALIF = 1 << 13;
    Interpreter.SCRIPT_VERIFY_NULLFAIL = 1 << 14;
    Interpreter.SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE = 1 << 15;
    Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16;
    Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = 1 << 17;
    Interpreter.SCRIPT_ENABLE_CHECKDATASIG = 1 << 18;
    Interpreter.SCRIPT_DISALLOW_SEGWIT_RECOVERY = 1 << 20;
    Interpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG = 1 << 21;
    Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31;
    Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22;
    Interpreter.SEQUENCE_LOCKTIME_MASK = 65535;
    Interpreter.SCRIPT_VERIFY_INPUT_SIGCHECKS = 1 << 22;
    Interpreter.SCRIPT_ENFORCE_SIGCHECKS = 1 << 23;
    Interpreter.SCRIPT_64_BIT_INTEGERS = 1 << 24;
    Interpreter.SCRIPT_NATIVE_INTROSPECTION = 1 << 25;
    Interpreter.SCRIPT_ENABLE_P2SH_32 = 1 << 26;
    Interpreter.SCRIPT_ENABLE_TOKENS = 1 << 27;
    Interpreter.castToBool = function(buf) {
      for (var i = 0; i < buf.length; i++) {
        if (buf[i] !== 0) {
          if (i === buf.length - 1 && buf[i] === 128) {
            return false;
          }
          return true;
        }
      }
      return false;
    };
    Interpreter.isSchnorrSig = function(buf) {
      return (buf.length === 64 || buf.length === 65) && buf[0] !== 48;
    };
    Interpreter.prototype.checkRawSignatureEncoding = function(buf) {
      var sig;
      if (Interpreter.isSchnorrSig(buf)) {
        return true;
      }
      if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isDER(buf)) {
        this.errstr = "SCRIPT_ERR_SIG_DER_INVALID_FORMAT";
        return false;
      } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {
        sig = Signature.fromTxFormat(buf);
        if (!sig.hasLowS()) {
          this.errstr = "SCRIPT_ERR_SIG_DER_HIGH_S";
          return false;
        }
      }
      return true;
    };
    Interpreter.prototype.checkSignatureEncoding = Interpreter.prototype.checkTxSignatureEncoding = function(buf) {
      if (buf.length == 0) {
        return true;
      }
      if (!this.checkRawSignatureEncoding(buf.slice(0, buf.length - 1))) {
        return false;
      }
      if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {
        var sig = Signature.fromTxFormat(buf);
        if (!sig.hasDefinedHashtype()) {
          this.errstr = "SCRIPT_ERR_SIG_HASHTYPE";
          return false;
        }
        if (!(this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) && sig.nhashtype & Signature.SIGHASH_FORKID) {
          this.errstr = "SCRIPT_ERR_ILLEGAL_FORKID";
          return false;
        }
        if (this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID && !(sig.nhashtype & Signature.SIGHASH_FORKID)) {
          this.errstr = "SCRIPT_ERR_MUST_USE_FORKID";
          return false;
        }
      }
      return true;
    };
    Interpreter.prototype.checkDataSignatureEncoding = function(buf) {
      if (buf.length == 0) {
        return true;
      }
      return this.checkRawSignatureEncoding(buf);
    };
    Interpreter.prototype.checkPubkeyEncoding = function(buf) {
      if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !(PublicKey.isValid(buf) || IsCompressedOrUncompressedPubkey(buf))) {
        this.errstr = "SCRIPT_ERR_PUBKEYTYPE";
        return false;
      }
      return true;
    };
    function IsCompressedOrUncompressedPubkey(bufPubkey) {
      switch (bufPubkey.length) {
        case 33:
          return bufPubkey[0] === 2 || bufPubkey[0] === 3;
        case 64:
          return bufPubkey[0] === 4;
        default:
          return false;
      }
    }
    Interpreter._isMinimallyEncoded = function(buf, nMaxNumSize) {
      nMaxNumSize = nMaxNumSize || Interpreter.MAXIMUM_ELEMENT_SIZE;
      if (buf.length > nMaxNumSize) {
        return false;
      }
      if (buf.length > 0) {
        if ((buf[buf.length - 1] & 127) == 0) {
          if (buf.length <= 1 || (buf[buf.length - 2] & 128) == 0) {
            return false;
          }
        }
      }
      return true;
    };
    Interpreter._minimallyEncode = function(buf) {
      if (buf.length == 0) {
        return buf;
      }
      var last = buf[buf.length - 1];
      if (last & 127) {
        return buf;
      }
      if (buf.length == 1) {
        return Buffer.from("");
      }
      if (buf[buf.length - 2] & 128) {
        return buf;
      }
      for (var i = buf.length - 1; i > 0; i--) {
        if (buf[i - 1] != 0) {
          if (buf[i - 1] & 128) {
            buf[i++] = last;
          } else {
            buf[i - 1] |= last;
          }
          return buf.slice(0, i);
        }
      }
      return Buffer.from("");
    };
    Interpreter.prototype.evaluate = function() {
      if (this.script.toBuffer().length > 1e4) {
        this.errstr = "SCRIPT_ERR_SCRIPT_SIZE";
        return false;
      }
      try {
        while (this.pc < this.script.chunks.length) {
          var fSuccess = this.step();
          if (!fSuccess) {
            return false;
          }
        }
        if (this.stack.length + this.altstack.length > 1e3) {
          this.errstr = "SCRIPT_ERR_STACK_SIZE";
          return false;
        }
      } catch (e) {
        this.errstr = "SCRIPT_ERR_UNKNOWN_ERROR: " + e;
        return false;
      }
      if (this.vfExec.length > 0) {
        this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
        return false;
      }
      return true;
    };
    Interpreter.prototype.checkLockTime = function(nLockTime) {
      if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {
        return false;
      }
      if (nLockTime.gt(new BN(this.tx.nLockTime))) {
        return false;
      }
      if (!this.tx.inputs[this.nin].isFinal()) {
        return false;
      }
      return true;
    };
    Interpreter.prototype.checkSequence = function(nSequence) {
      var txToSequence = this.tx.inputs[this.nin].sequenceNumber;
      if (this.tx.version < 2) {
        return false;
      }
      if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {
        return false;
      }
      var nLockTimeMask = Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;
      var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);
      var nSequenceMasked = nSequence.and(nLockTimeMask);
      var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);
      if (!(txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) || txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN))) {
        return false;
      }
      if (nSequenceMasked.gt(txToSequenceMasked)) {
        return false;
      }
      return true;
    };
    function DecodeBitfield(dummy, size) {
      if (size > 32) {
        this.errstr = "INVALID_BITFIELD_SIZE";
        return { result: false };
      }
      let bitfieldSize = Math.floor((size + 7) / 8);
      let dummyBitlength = dummy.length;
      if (dummyBitlength !== bitfieldSize) {
        this.errstr = "INVALID_BITFIELD_SIZE";
        return { result: false };
      }
      let bitfield = 0;
      let dummyAs32Bit = Uint32Array.from(dummy);
      for (let i = 0; i < bitfieldSize; i++) {
        bitfield = bitfield | dummyAs32Bit[i] << 8 * i;
      }
      let mask = (1 << size) - 1;
      if ((bitfield & mask) != bitfield) {
        this.errstr = "INVALID_BIT_RANGE";
        return { result: false };
      }
      return { result: true, bitfield };
    }
    function countBits(v) {
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    Interpreter.prototype.step = function() {
      var self2 = this;
      function stacktop(i2) {
        return self2.stack[self2.stack.length + i2];
      }
      function isOpcodeDisabled(opcode, f64BitIntegers2) {
        switch (opcode) {
          case Opcode.OP_INVERT:
          case Opcode.OP_2MUL:
          case Opcode.OP_2DIV:
          case Opcode.OP_LSHIFT:
          case Opcode.OP_RSHIFT:
            return true;
          case Opcode.OP_DIV:
          case Opcode.OP_MOD:
          case Opcode.OP_SPLIT:
          case Opcode.OP_CAT:
          case Opcode.OP_AND:
          case Opcode.OP_OR:
          case Opcode.OP_XOR:
          case Opcode.OP_BIN2NUM:
          case Opcode.OP_NUM2BIN:
            return false;
          case Opcode.OP_MUL:
            return !f64BitIntegers2;
          default:
            break;
        }
        return false;
      }
      const fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;
      const f64BitIntegers = (this.flags & Interpreter.SCRIPT_64_BIT_INTEGERS) !== 0;
      const fNativeIntrospection = (this.flags & Interpreter.SCRIPT_NATIVE_INTROSPECTION) !== 0;
      const fNativeTokens = (this.flags & Interpreter.SCRIPT_ENABLE_TOKENS) !== 0;
      const maxScriptIntegerSize = f64BitIntegers ? 8 : 4;
      var fExec = this.vfExec.indexOf(false) === -1;
      var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, bufMessage, subscript;
      var sig, pubkey;
      var fValue, fSuccess;
      var chunk = this.script.chunks[this.pc];
      this.pc++;
      var opcodenum = chunk.opcodenum;
      if (_.isUndefined(opcodenum)) {
        this.errstr = "SCRIPT_ERR_UNDEFINED_OPCODE";
        return false;
      }
      if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
        this.errstr = "SCRIPT_ERR_PUSH_SIZE";
        return false;
      }
      if (opcodenum > Opcode.OP_16 && ++this.nOpCount > 201) {
        this.errstr = "SCRIPT_ERR_OP_COUNT";
        return false;
      }
      if (isOpcodeDisabled(opcodenum, f64BitIntegers)) {
        this.errstr = "SCRIPT_ERR_DISABLED_OPCODE";
        return false;
      }
      if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {
        if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {
          this.errstr = "SCRIPT_ERR_MINIMALDATA";
          return false;
        }
        if (!chunk.buf) {
          this.stack.push(Interpreter.false);
        } else if (chunk.len !== chunk.buf.length) {
          throw new Error("Length of push value not equal to length of data");
        } else {
          this.stack.push(chunk.buf);
        }
      } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {
        switch (opcodenum) {
          case Opcode.OP_1NEGATE:
          case Opcode.OP_1:
          case Opcode.OP_2:
          case Opcode.OP_3:
          case Opcode.OP_4:
          case Opcode.OP_5:
          case Opcode.OP_6:
          case Opcode.OP_7:
          case Opcode.OP_8:
          case Opcode.OP_9:
          case Opcode.OP_10:
          case Opcode.OP_11:
          case Opcode.OP_12:
          case Opcode.OP_13:
          case Opcode.OP_14:
          case Opcode.OP_15:
          case Opcode.OP_16:
            {
              n = opcodenum - (Opcode.OP_1 - 1);
              buf = new BN(n).toScriptNumBuffer();
              this.stack.push(buf);
            }
            break;
          case Opcode.OP_NOP:
            break;
          case Opcode.OP_NOP2:
          case Opcode.OP_CHECKLOCKTIMEVERIFY:
            if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
              break;
            }
            if (this.stack.length < 1) {
              this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
              return false;
            }
            var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);
            if (nLockTime.lt(new BN(0))) {
              this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
              return false;
            }
            if (!this.checkLockTime(nLockTime)) {
              this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
              return false;
            }
            break;
          case Opcode.OP_NOP3:
          case Opcode.OP_CHECKSEQUENCEVERIFY:
            if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
              break;
            }
            if (this.stack.length < 1) {
              this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
              return false;
            }
            var nSequence = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, 5);
            if (nSequence.lt(new BN(0))) {
              this.errstr = "SCRIPT_ERR_NEGATIVE_LOCKTIME";
              return false;
            }
            if ((nSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {
              break;
            }
            if (!this.checkSequence(nSequence)) {
              this.errstr = "SCRIPT_ERR_UNSATISFIED_LOCKTIME";
              return false;
            }
            break;
          case Opcode.OP_NOP1:
          case Opcode.OP_NOP4:
          case Opcode.OP_NOP5:
          case Opcode.OP_NOP6:
          case Opcode.OP_NOP7:
          case Opcode.OP_NOP8:
          case Opcode.OP_NOP9:
          case Opcode.OP_NOP10:
            {
              if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {
                this.errstr = "SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS";
                return false;
              }
            }
            break;
          case Opcode.OP_IF:
          case Opcode.OP_NOTIF:
            {
              fValue = false;
              if (fExec) {
                if (this.stack.length < 1) {
                  this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                  return false;
                }
                buf = stacktop(-1);
                if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {
                  if (buf.length > 1) {
                    this.errstr = "SCRIPT_ERR_MINIMALIF";
                    return false;
                  }
                  if (buf.length == 1 && buf[0] != 1) {
                    this.errstr = "SCRIPT_ERR_MINIMALIF";
                    return false;
                  }
                }
                fValue = Interpreter.castToBool(buf);
                if (opcodenum === Opcode.OP_NOTIF) {
                  fValue = !fValue;
                }
                this.stack.pop();
              }
              this.vfExec.push(fValue);
            }
            break;
          case Opcode.OP_ELSE:
            {
              if (this.vfExec.length === 0) {
                this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                return false;
              }
              this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];
            }
            break;
          case Opcode.OP_ENDIF:
            {
              if (this.vfExec.length === 0) {
                this.errstr = "SCRIPT_ERR_UNBALANCED_CONDITIONAL";
                return false;
              }
              this.vfExec.pop();
            }
            break;
          case Opcode.OP_VERIFY:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = stacktop(-1);
              fValue = Interpreter.castToBool(buf);
              if (fValue) {
                this.stack.pop();
              } else {
                this.errstr = "SCRIPT_ERR_VERIFY";
                return false;
              }
            }
            break;
          case Opcode.OP_RETURN:
            {
              this.errstr = "SCRIPT_ERR_OP_RETURN";
              return false;
            }
            break;
          case Opcode.OP_TOALTSTACK:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.altstack.push(this.stack.pop());
            }
            break;
          case Opcode.OP_FROMALTSTACK:
            {
              if (this.altstack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_ALTSTACK_OPERATION";
                return false;
              }
              this.stack.push(this.altstack.pop());
            }
            break;
          case Opcode.OP_2DROP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.pop();
              this.stack.pop();
            }
            break;
          case Opcode.OP_2DUP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-2);
              buf2 = stacktop(-1);
              this.stack.push(buf1);
              this.stack.push(buf2);
            }
            break;
          case Opcode.OP_3DUP:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-3);
              buf2 = stacktop(-2);
              var buf3 = stacktop(-1);
              this.stack.push(buf1);
              this.stack.push(buf2);
              this.stack.push(buf3);
            }
            break;
          case Opcode.OP_2OVER:
            {
              if (this.stack.length < 4) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-4);
              buf2 = stacktop(-3);
              this.stack.push(buf1);
              this.stack.push(buf2);
            }
            break;
          case Opcode.OP_2ROT:
            {
              if (this.stack.length < 6) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              spliced = this.stack.splice(this.stack.length - 6, 2);
              this.stack.push(spliced[0]);
              this.stack.push(spliced[1]);
            }
            break;
          case Opcode.OP_2SWAP:
            {
              if (this.stack.length < 4) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              spliced = this.stack.splice(this.stack.length - 4, 2);
              this.stack.push(spliced[0]);
              this.stack.push(spliced[1]);
            }
            break;
          case Opcode.OP_IFDUP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = stacktop(-1);
              fValue = Interpreter.castToBool(buf);
              if (fValue) {
                this.stack.push(buf);
              }
            }
            break;
          case Opcode.OP_DEPTH:
            {
              buf = new BN(this.stack.length).toScriptNumBuffer();
              this.stack.push(buf);
            }
            break;
          case Opcode.OP_DROP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.pop();
            }
            break;
          case Opcode.OP_DUP:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.push(stacktop(-1));
            }
            break;
          case Opcode.OP_NIP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.splice(this.stack.length - 2, 1);
            }
            break;
          case Opcode.OP_OVER:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.push(stacktop(-2));
            }
            break;
          case Opcode.OP_PICK:
          case Opcode.OP_ROLL:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = stacktop(-1);
              bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);
              n = bn.toNumber();
              this.stack.pop();
              if (n < 0 || n >= this.stack.length) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = stacktop(-n - 1);
              if (opcodenum === Opcode.OP_ROLL) {
                this.stack.splice(this.stack.length - n - 1, 1);
              }
              this.stack.push(buf);
            }
            break;
          case Opcode.OP_ROT:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              x1 = stacktop(-3);
              x2 = stacktop(-2);
              var x3 = stacktop(-1);
              this.stack[this.stack.length - 3] = x2;
              this.stack[this.stack.length - 2] = x3;
              this.stack[this.stack.length - 1] = x1;
            }
            break;
          case Opcode.OP_SWAP:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              x1 = stacktop(-2);
              x2 = stacktop(-1);
              this.stack[this.stack.length - 2] = x2;
              this.stack[this.stack.length - 1] = x1;
            }
            break;
          case Opcode.OP_TUCK:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              this.stack.splice(this.stack.length - 2, 0, stacktop(-1));
            }
            break;
          case Opcode.OP_SIZE:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn = new BN(stacktop(-1).length);
              this.stack.push(bn.toScriptNumBuffer());
            }
            break;
          case Opcode.OP_AND:
          case Opcode.OP_OR:
          case Opcode.OP_XOR:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-2);
              buf2 = stacktop(-1);
              if (buf1.length !== buf2.length) {
                this.errstr = "SCRIPT_ERR_INVALID_OPERAND_SIZE";
                return false;
              }
              switch (opcodenum) {
                case Opcode.OP_AND:
                  for (var i = 0; i < buf1.length; i++) {
                    buf1[i] &= buf2[i];
                  }
                  break;
                case Opcode.OP_OR:
                  for (var i = 0; i < buf1.length; i++) {
                    buf1[i] |= buf2[i];
                  }
                  break;
                case Opcode.OP_XOR:
                  for (var i = 0; i < buf1.length; i++) {
                    buf1[i] ^= buf2[i];
                  }
                  break;
                default:
                  break;
              }
              this.stack.pop();
            }
            break;
          case Opcode.OP_EQUAL:
          case Opcode.OP_EQUALVERIFY:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-2);
              buf2 = stacktop(-1);
              var fEqual = buf1.toString("hex") === buf2.toString("hex");
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fEqual ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode.OP_EQUALVERIFY) {
                if (fEqual) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_EQUALVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_1ADD:
          case Opcode.OP_1SUB:
          case Opcode.OP_NEGATE:
          case Opcode.OP_ABS:
          case Opcode.OP_NOT:
          case Opcode.OP_0NOTEQUAL:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = stacktop(-1);
              bn = BN.fromScriptNumBuffer(buf, fRequireMinimal, maxScriptIntegerSize);
              switch (opcodenum) {
                case Opcode.OP_1ADD:
                  bn = bn.safeAdd(BN.One, maxScriptIntegerSize);
                  break;
                case Opcode.OP_1SUB:
                  bn = bn.safeSub(BN.One, maxScriptIntegerSize);
                  break;
                case Opcode.OP_NEGATE:
                  bn = bn.neg();
                  break;
                case Opcode.OP_ABS:
                  if (bn.cmp(BN.Zero) < 0) {
                    bn = bn.neg();
                  }
                  break;
                case Opcode.OP_NOT:
                  bn = new BN((bn.cmp(BN.Zero) === 0) + 0);
                  break;
                case Opcode.OP_0NOTEQUAL:
                  bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);
                  break;
              }
              this.stack.pop();
              this.stack.push(bn.toScriptNumBuffer());
            }
            break;
          case Opcode.OP_ADD:
          case Opcode.OP_SUB:
          case Opcode.OP_MOD:
          case Opcode.OP_MUL:
          case Opcode.OP_DIV:
          case Opcode.OP_BOOLAND:
          case Opcode.OP_BOOLOR:
          case Opcode.OP_NUMEQUAL:
          case Opcode.OP_NUMEQUALVERIFY:
          case Opcode.OP_NUMNOTEQUAL:
          case Opcode.OP_LESSTHAN:
          case Opcode.OP_GREATERTHAN:
          case Opcode.OP_LESSTHANOREQUAL:
          case Opcode.OP_GREATERTHANOREQUAL:
          case Opcode.OP_MIN:
          case Opcode.OP_MAX:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn1 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal, maxScriptIntegerSize);
              bn2 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, maxScriptIntegerSize);
              bn = new BN(0);
              switch (opcodenum) {
                case Opcode.OP_ADD:
                  bn = bn1.safeAdd(bn2, maxScriptIntegerSize);
                  break;
                case Opcode.OP_SUB:
                  bn = bn1.safeSub(bn2, maxScriptIntegerSize);
                  break;
                case Opcode.OP_DIV:
                  if (bn2 == 0) {
                    this.errstr = "SCRIPT_ERR_DIV_BY_ZERO";
                    return false;
                  }
                  bn = bn1.div(bn2);
                  break;
                case Opcode.OP_MUL:
                  bn = bn1.safeMul(bn2, maxScriptIntegerSize);
                  break;
                case Opcode.OP_MOD:
                  if (bn2 == 0) {
                    this.errstr = "SCRIPT_ERR_DIV_BY_ZERO";
                    return false;
                  }
                  bn = bn1.mod(bn2);
                  break;
                case Opcode.OP_BOOLAND:
                  bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);
                  break;
                case Opcode.OP_BOOLOR:
                  bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);
                  break;
                case Opcode.OP_NUMEQUAL:
                  bn = new BN((bn1.cmp(bn2) === 0) + 0);
                  break;
                case Opcode.OP_NUMEQUALVERIFY:
                  bn = new BN((bn1.cmp(bn2) === 0) + 0);
                  break;
                case Opcode.OP_NUMNOTEQUAL:
                  bn = new BN((bn1.cmp(bn2) !== 0) + 0);
                  break;
                case Opcode.OP_LESSTHAN:
                  bn = new BN((bn1.cmp(bn2) < 0) + 0);
                  break;
                case Opcode.OP_GREATERTHAN:
                  bn = new BN((bn1.cmp(bn2) > 0) + 0);
                  break;
                case Opcode.OP_LESSTHANOREQUAL:
                  bn = new BN((bn1.cmp(bn2) <= 0) + 0);
                  break;
                case Opcode.OP_GREATERTHANOREQUAL:
                  bn = new BN((bn1.cmp(bn2) >= 0) + 0);
                  break;
                case Opcode.OP_MIN:
                  bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;
                  break;
                case Opcode.OP_MAX:
                  bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;
                  break;
              }
              this.stack.pop();
              this.stack.pop();
              this.stack.push(bn.toScriptNumBuffer());
              if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {
                if (Interpreter.castToBool(stacktop(-1))) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_NUMEQUALVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_WITHIN:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bn1 = BN.fromScriptNumBuffer(stacktop(-3), fRequireMinimal, maxScriptIntegerSize);
              bn2 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal, maxScriptIntegerSize);
              var bn3 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, maxScriptIntegerSize);
              fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;
              this.stack.pop();
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fValue ? Interpreter.true : Interpreter.false);
            }
            break;
          case Opcode.OP_RIPEMD160:
          case Opcode.OP_SHA1:
          case Opcode.OP_SHA256:
          case Opcode.OP_HASH160:
          case Opcode.OP_HASH256:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf = stacktop(-1);
              var bufHash;
              if (opcodenum === Opcode.OP_RIPEMD160) {
                bufHash = Hash.ripemd160(buf);
              } else if (opcodenum === Opcode.OP_SHA1) {
                bufHash = Hash.sha1(buf);
              } else if (opcodenum === Opcode.OP_SHA256) {
                bufHash = Hash.sha256(buf);
              } else if (opcodenum === Opcode.OP_HASH160) {
                bufHash = Hash.sha256ripemd160(buf);
              } else if (opcodenum === Opcode.OP_HASH256) {
                bufHash = Hash.sha256sha256(buf);
              }
              this.stack.pop();
              this.stack.push(bufHash);
            }
            break;
          case Opcode.OP_CODESEPARATOR:
            {
              this.pbegincodehash = this.pc;
            }
            break;
          case Opcode.OP_CHECKSIG:
          case Opcode.OP_CHECKSIGVERIFY:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bufSig = stacktop(-2);
              bufPubkey = stacktop(-1);
              if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
                return false;
              }
              subscript = new Script().set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
              });
              var tmpScript = new Script().add(bufSig);
              subscript.findAndDelete(tmpScript);
              try {
                sig = Signature.fromTxFormat(bufSig);
                pubkey = PublicKey.fromBuffer(bufPubkey, false);
                if (!sig.isSchnorr) {
                  fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);
                } else {
                  fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags, "schnorr");
                }
              } catch (e) {
                fSuccess = false;
              }
              if (bufSig.length) {
                this.nSigChecks += 1;
              }
              if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {
                this.errstr = "SCRIPT_ERR_NULLFAIL";
                return false;
              }
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {
                if (fSuccess) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_CHECKSIGVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_CHECKDATASIG:
          case Opcode.OP_CHECKDATASIGVERIFY:
            {
              if (this.stack.length < 3) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              bufSig = stacktop(-3);
              bufMessage = stacktop(-2);
              bufPubkey = stacktop(-1);
              if (!this.checkDataSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
                return false;
              }
              fSuccess = false;
              try {
                sig = Signature.fromDataFormat(bufSig);
                pubkey = PublicKey.fromBuffer(bufPubkey, false);
                bufHash = Hash.sha256(bufMessage);
                if (!sig.isSchnorr) {
                  fSuccess = ECDSA.verify(bufHash, sig, pubkey, "big");
                } else {
                  fSuccess = Schnorr.verify(bufHash, sig, pubkey, "big");
                }
              } catch (e) {
                fSuccess = false;
              }
              if (bufSig.length) {
                this.nSigChecks += 1;
              }
              if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {
                this.errstr = "SCRIPT_ERR_NULLFAIL";
                return false;
              }
              this.stack.pop();
              this.stack.pop();
              this.stack.pop();
              this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode.OP_CHECKDATASIGVERIFY) {
                if (fSuccess) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_CHECKDATASIGVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_REVERSEBYTES:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-1);
              var reversedBuf = Buffer.from(buf1).reverse();
              this.stack.pop();
              this.stack.push(reversedBuf);
            }
            break;
          case Opcode.OP_CHECKMULTISIG:
          case Opcode.OP_CHECKMULTISIGVERIFY:
            {
              var i = 1;
              let idxTopKey = i + 1;
              if (this.stack.length < i) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              var nKeysCount = BN.fromScriptNumBuffer(stacktop(-i), fRequireMinimal).toNumber();
              var idxSigCount = idxTopKey + nKeysCount;
              if (nKeysCount < 0 || nKeysCount > 20) {
                this.errstr = "SCRIPT_ERR_PUBKEY_COUNT";
                return false;
              }
              this.nOpCount += nKeysCount;
              if (this.nOpCount > 201) {
                this.errstr = "SCRIPT_ERR_OP_COUNT";
                return false;
              }
              var ikey = ++i;
              var idxTopSig = idxSigCount + 1;
              i += nKeysCount;
              var ikey2 = nKeysCount + 2;
              if (this.stack.length < i) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              var nSigsCount = BN.fromScriptNumBuffer(stacktop(-idxSigCount), fRequireMinimal).toNumber();
              var idxDummy = idxTopSig + nSigsCount;
              if (nSigsCount < 0 || nSigsCount > nKeysCount) {
                this.errstr = "SCRIPT_ERR_SIG_COUNT";
                return false;
              }
              var isig = ++i;
              i += nSigsCount;
              if (this.stack.length < idxDummy) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              subscript = new Script().set({
                chunks: this.script.chunks.slice(this.pbegincodehash)
              });
              fSuccess = true;
              if (this.flags & Interpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG && stacktop(-idxDummy).length !== 0) {
                let dummy = stacktop(-idxDummy);
                let bitfieldObj = DecodeBitfield(dummy, nKeysCount);
                if (!bitfieldObj["result"]) {
                  fSuccess = false;
                }
                let nSigs8bit = new Uint8Array([nSigsCount]);
                let nSigs32 = Uint32Array.from(nSigs8bit);
                if (countBits(bitfieldObj["bitfield"]) !== nSigs32[0]) {
                  this.errstr = "INVALID_BIT_COUNT";
                  fSuccess = false;
                }
                var bottomKey = idxTopKey + nKeysCount - 1;
                var bottomSig = idxTopSig + nSigsCount - 1;
                let iKey = 0;
                for (let iSig = 0; iSig < nSigsCount; iSig++, iKey++) {
                  if (bitfieldObj["bitfield"] >> iKey === 0) {
                    this.errstr = "INVALID_BIT_RANGE";
                    fSuccess = false;
                  }
                  while ((bitfieldObj["bitfield"] >> iKey & 1) == 0) {
                    if (iKey >= nKeysCount) {
                      this.errstr = "wrong";
                      fSuccess = false;
                      break;
                    }
                    iKey++;
                  }
                  if (iKey >= nKeysCount) {
                    this.errstr = "PUBKEY_COUNT";
                    fSuccess = false;
                  }
                  let bufsig = stacktop(-bottomSig + iSig);
                  let bufPubkey2 = stacktop(-bottomKey + iKey);
                  if (!this.checkRawSignatureEncoding(bufsig) || !this.checkPubkeyEncoding(bufPubkey2)) {
                    fSuccess = false;
                  }
                  let sig2 = Signature.fromTxFormat(bufsig);
                  let pubkey2 = PublicKey.fromBuffer(bufPubkey2, false);
                  let fOk2 = this.tx.verifySignature(sig2, pubkey2, this.nin, subscript, this.satoshisBN, this.flags, "schnorr");
                  if (!fOk2) {
                    this.errstr = "SIG_NULLFAIL";
                    fSuccess = false;
                  }
                  if (bufsig.length) {
                    this.nSigChecks += 1;
                  }
                }
                if (bitfieldObj["bitfield"] >> iKey != 0) {
                  this.errstr = "INVALID_BIT_COUNT";
                  fSuccess = false;
                }
              } else {
                for (var k = 0; k < nSigsCount; k++) {
                  bufSig = stacktop(-isig - k);
                  subscript.findAndDelete(new Script().add(bufSig));
                }
                let nSigsRemaining = nSigsCount;
                let nKeysRemaining = nKeysCount;
                while (fSuccess && nSigsRemaining > 0) {
                  bufSig = stacktop(-isig - (nSigsCount - nSigsRemaining));
                  if (bufSig.length === 65) {
                    return false;
                  }
                  bufPubkey = stacktop(-ikey - (nKeysCount - nKeysRemaining));
                  if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {
                    return false;
                  }
                  var fOk;
                  try {
                    sig = Signature.fromTxFormat(bufSig);
                    pubkey = PublicKey.fromBuffer(bufPubkey, false);
                    fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);
                  } catch (e) {
                    fOk = false;
                  }
                  if (fOk) {
                    nSigsRemaining--;
                  }
                  nKeysRemaining--;
                  if (nSigsRemaining > nKeysRemaining) {
                    fSuccess = false;
                  }
                }
                let areAllSignaturesNull = true;
                for (let l2 = 0; l2 < nSigsCount; l2++) {
                  if (stacktop(-isig - l2) && stacktop(-isig - l2).length) {
                    areAllSignaturesNull = false;
                    break;
                  }
                }
                if (!areAllSignaturesNull) {
                  this.nSigChecks += nKeysCount;
                }
              }
              while (i-- > 1) {
                if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && !ikey2 && stacktop(-1).length) {
                  this.errstr = "SCRIPT_ERR_NULLFAIL";
                  return false;
                }
                if (ikey2 > 0) {
                  ikey2--;
                }
                this.stack.pop();
              }
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && stacktop(-1).length) {
                this.errstr = "SCRIPT_ERR_SIG_NULLDUMMY";
                return false;
              }
              this.stack.pop();
              this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);
              if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {
                if (fSuccess) {
                  this.stack.pop();
                } else {
                  this.errstr = "SCRIPT_ERR_CHECKMULTISIGVERIFY";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_CAT:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-2);
              buf2 = stacktop(-1);
              if (buf1.length + buf2.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
                this.errstr = "SCRIPT_ERR_PUSH_SIZE";
                return false;
              }
              this.stack[this.stack.length - 2] = Buffer.concat([buf1, buf2]);
              this.stack.pop();
            }
            break;
          case Opcode.OP_SPLIT:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-2);
              var position = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();
              if (position < 0 || position > buf1.length) {
                this.errstr = "SCRIPT_ERR_INVALID_SPLIT_RANGE";
                return false;
              }
              var n1 = Buffer.from(buf1);
              this.stack[this.stack.length - 2] = n1.slice(0, position);
              this.stack[this.stack.length - 1] = n1.slice(position);
            }
            break;
          case Opcode.OP_NUM2BIN:
            {
              if (this.stack.length < 2) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              var size = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();
              if (size > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
                this.errstr = "SCRIPT_ERR_PUSH_SIZE";
                return false;
              }
              this.stack.pop();
              var rawnum = stacktop(-1);
              rawnum = Interpreter._minimallyEncode(rawnum);
              if (rawnum.length > size) {
                this.errstr = "SCRIPT_ERR_IMPOSSIBLE_ENCODING";
                return false;
              }
              if (rawnum.length == size) {
                this.stack[this.stack.length - 1] = rawnum;
                break;
              }
              var signbit = 0;
              if (rawnum.length > 0) {
                signbit = rawnum[rawnum.length - 1] & 128;
                rawnum[rawnum.length - 1] &= 127;
              }
              var num = Buffer.alloc(size);
              rawnum.copy(num, 0);
              var l = rawnum.length - 1;
              while (l++ < size - 2) {
                num[l] = 0;
              }
              num[l] = signbit;
              this.stack[this.stack.length - 1] = num;
            }
            break;
          case Opcode.OP_BIN2NUM:
            {
              if (this.stack.length < 1) {
                this.errstr = "SCRIPT_ERR_INVALID_STACK_OPERATION";
                return false;
              }
              buf1 = stacktop(-1);
              buf2 = Interpreter._minimallyEncode(buf1);
              this.stack[this.stack.length - 1] = buf2;
              if (!Interpreter._isMinimallyEncoded(buf2, maxScriptIntegerSize)) {
                this.errstr = "SCRIPT_ERR_INVALID_NUMBER_RANGE";
                return false;
              }
            }
            break;
          case Opcode.OP_INPUTINDEX:
          case Opcode.OP_ACTIVEBYTECODE:
          case Opcode.OP_TXVERSION:
          case Opcode.OP_TXINPUTCOUNT:
          case Opcode.OP_TXOUTPUTCOUNT:
          case Opcode.OP_TXLOCKTIME:
            {
              if (!fNativeIntrospection) {
                this.errstr = "SCRIPT_ERR_BAD_OPCODE";
                return false;
              }
              if (!this.tx || !this.tx.inputs.every((input) => input.output)) {
                this.errstr = "SCRIPT_ERR_CONTEXT_NOT_PRESENT";
                return false;
              }
              switch (opcodenum) {
                case Opcode.OP_INPUTINDEX:
                  {
                    const bn4 = BN.fromNumber(this.nin);
                    this.stack.push(bn4.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_ACTIVEBYTECODE:
                  {
                    subscript = new Script().set({
                      chunks: this.script.chunks.slice(this.pbegincodehash)
                    });
                    this.stack.push(subscript.toBuffer());
                  }
                  break;
                case Opcode.OP_TXVERSION:
                  {
                    const bn4 = BN.fromNumber(this.tx.version);
                    this.stack.push(bn4.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_TXINPUTCOUNT:
                  {
                    const bn4 = BN.fromNumber(this.tx.inputs.length);
                    this.stack.push(bn4.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_TXOUTPUTCOUNT:
                  {
                    const bn4 = BN.fromNumber(this.tx.outputs.length);
                    this.stack.push(bn4.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_TXLOCKTIME:
                  {
                    const bn4 = BN.fromNumber(this.tx.nLockTime);
                    this.stack.push(bn4.toScriptNumBuffer());
                  }
                  break;
                default: {
                  this.errstr = "SCRIPT_ERR_BAD_OPCODE";
                  return false;
                }
              }
            }
            break;
          case Opcode.OP_UTXOTOKENCATEGORY:
          case Opcode.OP_UTXOTOKENCOMMITMENT:
          case Opcode.OP_UTXOTOKENAMOUNT:
          case Opcode.OP_OUTPUTTOKENCATEGORY:
          case Opcode.OP_OUTPUTTOKENCOMMITMENT:
          case Opcode.OP_OUTPUTTOKENAMOUNT:
            if (!fNativeTokens) {
              this.errstr = "SCRIPT_ERR_BAD_OPCODE";
              return false;
            }
          case Opcode.OP_UTXOVALUE:
          case Opcode.OP_UTXOBYTECODE:
          case Opcode.OP_OUTPOINTTXHASH:
          case Opcode.OP_OUTPOINTINDEX:
          case Opcode.OP_INPUTBYTECODE:
          case Opcode.OP_INPUTSEQUENCENUMBER:
          case Opcode.OP_OUTPUTVALUE:
          case Opcode.OP_OUTPUTBYTECODE:
            {
              if (!fNativeIntrospection) {
                this.errstr = "SCRIPT_ERR_BAD_OPCODE";
                return false;
              }
              if (!this.tx || !this.tx.inputs.every((input) => input.output)) {
                this.errstr = "SCRIPT_ERR_CONTEXT_NOT_PRESENT";
                return false;
              }
              const bn4 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, maxScriptIntegerSize);
              const index = bn4.toNumber();
              this.stack.pop();
              const indexType = [
                Opcode.OP_OUTPUTVALUE,
                Opcode.OP_OUTPUTBYTECODE,
                Opcode.OP_OUTPUTTOKENCATEGORY,
                Opcode.OP_OUTPUTTOKENCOMMITMENT,
                Opcode.OP_OUTPUTTOKENAMOUNT
              ].includes(opcodenum) ? "OUTPUT" : "INPUT";
              const maxIndex = indexType === "OUTPUT" ? this.tx.outputs.length : this.tx.inputs.length;
              if (index < 0 || index >= maxIndex) {
                this.errstr = `SCRIPT_ERR_INVALID_TX_${indexType}_INDEX`;
                return false;
              }
              const tokenCapabilities = {
                mutable: 1,
                minting: 2
              };
              switch (opcodenum) {
                case Opcode.OP_UTXOVALUE:
                  {
                    const bn5 = this.tx.inputs[index].output.satoshisBN;
                    if (bn5.getSize() > maxScriptIntegerSize) {
                      this.errstr = "SCRIPT_ERR_INTEGER_SIZE";
                      return false;
                    }
                    this.stack.push(bn5.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_UTXOBYTECODE:
                  {
                    const bytecode = this.tx.inputs[index].output.script.toBuffer();
                    if (bytecode.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
                      this.errstr = "SCRIPT_ERR_PUSH_SIZE";
                      return false;
                    }
                    this.stack.push(bytecode);
                  }
                  break;
                case Opcode.OP_OUTPOINTTXHASH:
                  {
                    const writer = new BufferWriter();
                    writer.writeReverse(this.tx.inputs[index].prevTxId);
                    this.stack.push(writer.toBuffer());
                  }
                  break;
                case Opcode.OP_OUTPOINTINDEX:
                  {
                    const bn5 = BN.fromNumber(this.tx.inputs[index].outputIndex);
                    this.stack.push(bn5.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_INPUTBYTECODE:
                  {
                    const bytecode = this.tx.inputs[index].script.toBuffer();
                    if (bytecode.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
                      this.errstr = "SCRIPT_ERR_PUSH_SIZE";
                      return false;
                    }
                    this.stack.push(bytecode);
                  }
                  break;
                case Opcode.OP_INPUTSEQUENCENUMBER:
                  {
                    const bn5 = BN.fromNumber(this.tx.inputs[index].sequenceNumber);
                    this.stack.push(bn5.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_OUTPUTVALUE:
                  {
                    const bn5 = this.tx.outputs[index].satoshisBN;
                    if (bn5.getSize() > maxScriptIntegerSize) {
                      this.errstr = "SCRIPT_ERR_INTEGER_SIZE";
                      return false;
                    }
                    this.stack.push(bn5.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_OUTPUTBYTECODE:
                  {
                    const bytecode = this.tx.outputs[index].script.toBuffer();
                    if (bytecode.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {
                      this.errstr = "SCRIPT_ERR_PUSH_SIZE";
                      return false;
                    }
                    this.stack.push(bytecode);
                  }
                  break;
                case Opcode.OP_UTXOTOKENCATEGORY:
                  {
                    const tokenData = this.tx.inputs[index].output.tokenData;
                    if (!tokenData) {
                      const bn5 = BN.fromNumber(0);
                      this.stack.push(bn5.toScriptNumBuffer());
                      break;
                    }
                    const category = tokenData.category;
                    const capability = tokenData.nft && tokenData.nft.capability && tokenCapabilities[tokenData.nft.capability] || 0;
                    const capabilityBuf = BN.fromNumber(capability).toScriptNumBuffer();
                    const categoryBuf = Buffer.from(category, "hex").reverse();
                    const fullBuffer = Buffer.concat([categoryBuf, capabilityBuf]);
                    this.stack.push(fullBuffer);
                  }
                  break;
                case Opcode.OP_UTXOTOKENCOMMITMENT:
                  {
                    const tokenData = this.tx.inputs[index].output.tokenData;
                    if (!tokenData || !tokenData.nft) {
                      const bn5 = BN.fromNumber(0);
                      this.stack.push(bn5.toScriptNumBuffer());
                      break;
                    }
                    const commitment = tokenData.nft.commitment;
                    this.stack.push(Buffer.from(commitment, "hex"));
                  }
                  break;
                case Opcode.OP_UTXOTOKENAMOUNT:
                  {
                    const tokenData = this.tx.inputs[index].output.tokenData;
                    if (!tokenData || !tokenData.amount) {
                      const bn5 = BN.fromNumber(0);
                      this.stack.push(bn5.toScriptNumBuffer());
                      break;
                    }
                    this.stack.push(tokenData.amount.toScriptNumBuffer());
                  }
                  break;
                case Opcode.OP_OUTPUTTOKENCATEGORY:
                  {
                    const tokenData = this.tx.outputs[index].tokenData;
                    if (!tokenData) {
                      const bn5 = BN.fromNumber(0);
                      this.stack.push(bn5.toScriptNumBuffer());
                      break;
                    }
                    const category = tokenData.category;
                    const capability = tokenData.nft && tokenData.nft.capability && tokenCapabilities[tokenData.nft.capability] || 0;
                    const capabilityBuf = BN.fromNumber(capability).toScriptNumBuffer();
                    const categoryBuf = Buffer.from(category, "hex").reverse();
                    const fullBuffer = Buffer.concat([categoryBuf, capabilityBuf]);
                    this.stack.push(fullBuffer);
                  }
                  break;
                case Opcode.OP_OUTPUTTOKENCOMMITMENT:
                  {
                    const tokenData = this.tx.outputs[index].tokenData;
                    if (!tokenData || !tokenData.nft) {
                      const bn5 = BN.fromNumber(0);
                      this.stack.push(bn5.toScriptNumBuffer());
                      break;
                    }
                    const commitment = tokenData.nft.commitment;
                    this.stack.push(Buffer.from(commitment, "hex"));
                  }
                  break;
                case Opcode.OP_OUTPUTTOKENAMOUNT:
                  {
                    const tokenData = this.tx.outputs[index].tokenData;
                    if (!tokenData || !tokenData.amount) {
                      const bn5 = BN.fromNumber(0);
                      this.stack.push(bn5.toScriptNumBuffer());
                      break;
                    }
                    this.stack.push(tokenData.amount.toScriptNumBuffer());
                  }
                  break;
                default: {
                  this.errstr = "SCRIPT_ERR_BAD_OPCODE";
                  return false;
                }
              }
            }
            break;
          default:
            this.errstr = "SCRIPT_ERR_BAD_OPCODE";
            return false;
        }
      }
      return true;
    };
  }
});

// node_modules/bitcore-lib-cash/lib/script/index.js
var require_script2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/script/index.js"(exports, module) {
    module.exports = require_script();
    module.exports.Interpreter = require_interpreter();
  }
});

// node_modules/bitcore-lib-cash/lib/address.js
var require_address = __commonJS({
  "node_modules/bitcore-lib-cash/lib/address.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var errors = require_errors();
    var Base58Check = require_base58check();
    var Networks = require_networks();
    var Hash = require_hash2();
    var JSUtil = require_js();
    var PublicKey = require_publickey2();
    var BN = require_bn2();
    var base32 = require_base32();
    var convertBits = require_convertBits();
    function Address(data, network, type) {
      if (!(this instanceof Address)) {
        return new Address(data, network, type);
      }
      if (_.isArray(data) && _.isNumber(network)) {
        return Address.createMultisig(data, network, type);
      }
      if (data instanceof Address) {
        return data;
      }
      $.checkArgument(data, "First argument is required, please include address data.", "guide/address.html");
      if (network && !Networks.get(network)) {
        throw new TypeError('Second argument must be "livenet", "testnet", or "regtest".');
      }
      if (type && (type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash)) {
        throw new TypeError('Third argument must be "pubkeyhash" or "scripthash".');
      }
      var info = this._classifyArguments(data, network, type);
      info.network = info.network || Networks.get(network) || Networks.defaultNetwork;
      info.type = info.type || type || Address.PayToPublicKeyHash;
      JSUtil.defineImmutable(this, {
        hashBuffer: info.hashBuffer,
        network: info.network,
        type: info.type
      });
      return this;
    }
    Address.prototype._classifyArguments = function(data, network, type) {
      if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {
        return Address._transformHash(data);
      } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {
        return Address._transformBuffer(data, network, type);
      } else if (data instanceof PublicKey) {
        return Address._transformPublicKey(data, network, type);
      } else if (data instanceof Script) {
        return Address._transformScript(data, network);
      } else if (typeof data === "string") {
        return Address._transformString(data, network, type);
      } else if (_.isObject(data)) {
        return Address._transformObject(data);
      } else {
        throw new TypeError("First argument is an unrecognized data format.");
      }
    };
    Address.PayToPublicKeyHash = "pubkeyhash";
    Address.PayToScriptHash = "scripthash";
    Address._transformHash = function(hash) {
      var info = {};
      if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {
        throw new TypeError("Address supplied is not a buffer.");
      }
      if (hash.length !== 20) {
        throw new TypeError("Address hashbuffers must be exactly 20 bytes.");
      }
      info.hashBuffer = hash;
      return info;
    };
    Address._transformObject = function(data) {
      $.checkArgument(data.hash || data.hashBuffer, "Must provide a `hash` or `hashBuffer` property");
      $.checkArgument(data.type, "Must provide a `type` property");
      return {
        hashBuffer: data.hash ? Buffer.from(data.hash, "hex") : data.hashBuffer,
        network: Networks.get(data.network) || Networks.defaultNetwork,
        type: data.type
      };
    };
    Address._classifyFromVersion = function(buffer) {
      var version = {};
      var pubkeyhashNetwork = Networks.get(buffer[0], "pubkeyhash");
      var scripthashNetwork = Networks.get(buffer[0], "scripthash");
      if (pubkeyhashNetwork) {
        version.network = pubkeyhashNetwork;
        version.type = Address.PayToPublicKeyHash;
      } else if (scripthashNetwork) {
        version.network = scripthashNetwork;
        version.type = Address.PayToScriptHash;
      }
      return version;
    };
    Address._transformBuffer = function(buffer, network, type) {
      var info = {};
      if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {
        throw new TypeError("Address supplied is not a buffer.");
      }
      if (buffer.length !== 1 + 20) {
        throw new TypeError("Address buffers must be exactly 21 bytes.");
      }
      var networkObj = Networks.get(network);
      var bufferVersion = Address._classifyFromVersion(buffer);
      if (network && !networkObj) {
        throw new TypeError("Unknown network");
      }
      if (!bufferVersion.network || networkObj && networkObj !== bufferVersion.network) {
        throw new TypeError("Address has mismatched network type.");
      }
      if (!bufferVersion.type || type && type !== bufferVersion.type) {
        throw new TypeError("Address has mismatched type.");
      }
      info.hashBuffer = buffer.slice(1);
      info.network = bufferVersion.network;
      info.type = bufferVersion.type;
      return info;
    };
    Address._transformPublicKey = function(pubkey, network, type) {
      var info = {};
      if (!(pubkey instanceof PublicKey)) {
        throw new TypeError("Address must be an instance of PublicKey.");
      }
      info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());
      info.type = type || Address.PayToPublicKeyHash;
      return info;
    };
    Address._transformScript = function(script, network) {
      $.checkArgument(script instanceof Script, "script must be a Script instance");
      var info = script.getAddressInfo(network);
      if (!info) {
        throw new errors.Script.CantDeriveAddress(script);
      }
      return info;
    };
    Address.createMultisig = function(publicKeys, threshold, network) {
      network = network || publicKeys[0].network || Networks.defaultNetwork;
      return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);
    };
    Address.createEscrow = function(inputPublicKeys, reclaimPublicKey, network) {
      const zceRedeemScript = Script.buildEscrowOut(inputPublicKeys, reclaimPublicKey);
      network = network || reclaimPublicKey.network || Networks.defaultNetwork;
      return Address.payingTo(zceRedeemScript, network);
    };
    function decodeCashAddress(address) {
      function hasSingleCase(string) {
        var lowerCase = string.toLowerCase();
        var upperCase = string.toUpperCase();
        var hasSingleCase2 = string === lowerCase || string === upperCase;
        return hasSingleCase2;
      }
      function validChecksum(prefix2, payload2) {
        function prefixToArray(prefix3) {
          var result = [];
          for (var i2 = 0; i2 < prefix3.length; i2++) {
            result.push(prefix3.charCodeAt(i2) & 31);
          }
          return result;
        }
        var prefixData = prefixToArray(prefix2).concat([0]);
        return polymod(prefixData.concat(payload2)) === 0;
      }
      $.checkArgument(hasSingleCase(address), "Mixed case");
      address = address.toLowerCase();
      var pieces = address.split(":");
      $.checkArgument(pieces.length <= 2, "Invalid format:" + address);
      var prefix, encodedPayload;
      if (pieces.length === 2) {
        prefix = pieces[0];
        encodedPayload = pieces[1];
      } else {
        prefix = null;
        encodedPayload = pieces[0];
      }
      var payload = base32.decode(encodedPayload.toLowerCase());
      if (prefix) {
        $.checkArgument(validChecksum(prefix, payload), "Invalid checksum:" + address);
      } else {
        var netNames = ["livenet", "testnet", "regtest"];
        var i;
        while (!prefix && (i = netNames.shift())) {
          var p = Networks.get(i).prefix;
          if (validChecksum(p, payload)) {
            prefix = p;
          }
        }
        $.checkArgument(prefix, "Invalid checksum:" + address);
      }
      var convertedBits = convertBits(payload.slice(0, -8), 5, 8, true);
      var versionByte = convertedBits.shift();
      var hash = convertedBits;
      $.checkArgument(getHashSize(versionByte) === hash.length * 8, "Invalid hash size:" + address);
      function getType(versionByte2) {
        switch (versionByte2 & 120) {
          case 0:
            return "pubkeyhash";
          case 8:
            return "scripthash";
          default:
            throw new Error("Invalid address type in version byte:" + versionByte2);
        }
      }
      var type = getType(versionByte);
      var network = Networks.get(prefix);
      var info = {};
      info.hashBuffer = Buffer.from(hash);
      info.network = network;
      info.type = type;
      return info;
    }
    Address._decodeCashAddress = decodeCashAddress;
    Address._transformString = function(data, network, type) {
      if (typeof data !== "string") {
        throw new TypeError("data parameter supplied is not a string.");
      }
      if (data.length < 34) {
        throw new Error("Invalid Address string provided");
      }
      if (data.length > 100) {
        throw new TypeError("address string is too long");
      }
      data = data.trim();
      var networkObj = Networks.get(network);
      if (network && !networkObj) {
        throw new TypeError("Unknown network");
      }
      if (data.length > 35) {
        var info = decodeCashAddress(data);
        if (!info.network || networkObj && networkObj.name !== info.network.name) {
          throw new TypeError("Address has mismatched network type.");
        }
        if (!info.type || type && type !== info.type) {
          throw new TypeError("Address has mismatched type.");
        }
        return info;
      } else {
        var addressBuffer = Base58Check.decode(data);
        return Address._transformBuffer(addressBuffer, network, type);
      }
    };
    Address.fromPublicKey = function(data, network, type) {
      var info = Address._transformPublicKey(data, network, type);
      network = network || Networks.defaultNetwork;
      return new Address(info.hashBuffer, network, info.type);
    };
    Address.fromPublicKeyHash = function(hash, network) {
      var info = Address._transformHash(hash);
      return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);
    };
    Address.fromScriptHash = function(hash, network) {
      $.checkArgument(hash, "hash parameter is required");
      var info = Address._transformHash(hash);
      return new Address(info.hashBuffer, network, Address.PayToScriptHash);
    };
    Address.payingTo = function(script, network) {
      $.checkArgument(script, "script is required");
      $.checkArgument(script instanceof Script, "script must be instance of Script");
      return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);
    };
    Address.fromScript = function(script, network) {
      $.checkArgument(script instanceof Script, "script must be a Script instance");
      var info = Address._transformScript(script, network);
      return new Address(info.hashBuffer, network, info.type);
    };
    Address.fromBuffer = function(buffer, network, type) {
      var info = Address._transformBuffer(buffer, network, type);
      return new Address(info.hashBuffer, info.network, info.type);
    };
    Address.fromString = function(str, network, type) {
      var info = Address._transformString(str, network, type);
      return new Address(info.hashBuffer, info.network, info.type);
    };
    Address.fromObject = function fromObject(obj) {
      $.checkState(
        JSUtil.isHexa(obj.hash),
        'Unexpected hash property, "' + obj.hash + '", expected to be hex.'
      );
      var hashBuffer = Buffer.from(obj.hash, "hex");
      return new Address(hashBuffer, obj.network, obj.type);
    };
    Address.getValidationError = function(data, network, type) {
      var error;
      try {
        new Address(data, network, type);
      } catch (e) {
        error = e;
      }
      return error;
    };
    Address.isValid = function(data, network, type) {
      return !Address.getValidationError(data, network, type);
    };
    Address.prototype.isPayToPublicKeyHash = function() {
      return this.type === Address.PayToPublicKeyHash;
    };
    Address.prototype.isPayToScriptHash = function() {
      return this.type === Address.PayToScriptHash;
    };
    Address.prototype.toBuffer = function() {
      var version = Buffer.from([this.network[this.type]]);
      var buf = Buffer.concat([version, this.hashBuffer]);
      return buf;
    };
    Address.prototype.toObject = Address.prototype.toJSON = function toObject() {
      return {
        hash: this.hashBuffer.toString("hex"),
        type: this.type,
        network: this.network.toString()
      };
    };
    Address.prototype.inspect = function() {
      return "<Address: " + this.toString() + ", type: " + this.type + ", network: " + this.network + ">";
    };
    Address.prototype.toCashBuffer = function() {
      var version = Buffer.from([this.network[this.type]]);
      var buf = Buffer.concat([version, this.hashBuffer]);
      return buf;
    };
    Address.prototype.toLegacyAddress = function() {
      return Base58Check.encode(this.toBuffer());
    };
    Address.prototype.toCashAddress = function(stripPrefix) {
      function getTypeBits(type) {
        switch (type) {
          case "pubkeyhash":
            return 0;
          case "scripthash":
            return 8;
          default:
            throw new Error("Invalid type:" + type);
        }
      }
      function getHashSizeBits(hash) {
        switch (hash.length * 8) {
          case 160:
            return 0;
          case 192:
            return 1;
          case 224:
            return 2;
          case 256:
            return 3;
          case 320:
            return 4;
          case 384:
            return 5;
          case 448:
            return 6;
          case 512:
            return 7;
          default:
            throw new Error("Invalid hash size:" + hash.length);
        }
      }
      var eight0 = [0, 0, 0, 0, 0, 0, 0, 0];
      var prefixData = this.network.prefixArray.concat([0]);
      var versionByte = getTypeBits(this.type) + getHashSizeBits(this.hashBuffer);
      var arr = Array.prototype.slice.call(this.hashBuffer, 0);
      var payloadData = convertBits([versionByte].concat(arr), 8, 5);
      var checksumData = prefixData.concat(payloadData).concat(eight0);
      var payload = payloadData.concat(checksumToArray(polymod(checksumData)));
      if (stripPrefix === true) {
        return base32.encode(payload);
      } else {
        return this.network.prefix + ":" + base32.encode(payload);
      }
    };
    Address.prototype.toString = Address.prototype.toCashAddress;
    function getHashSize(versionByte) {
      switch (versionByte & 7) {
        case 0:
          return 160;
        case 1:
          return 192;
        case 2:
          return 224;
        case 3:
          return 256;
        case 4:
          return 320;
        case 5:
          return 384;
        case 6:
          return 448;
        case 7:
          return 512;
      }
    }
    function checksumToArray(checksum) {
      var result = [];
      for (var i = 0; i < 8; ++i) {
        result.push(checksum & 31);
        checksum /= 32;
      }
      return result.reverse();
    }
    var GENERATOR1 = [152, 121, 243, 174, 30];
    var GENERATOR2 = [4072443489, 3077413346, 1046459332, 783016616, 1329849456];
    function polymod(data) {
      var c0 = 0, c1 = 1, C = 0;
      for (var j = 0; j < data.length; j++) {
        C = c0 >>> 3;
        c0 &= 7;
        c0 <<= 5;
        c0 |= c1 >>> 27;
        c1 &= 134217727;
        c1 <<= 5;
        c1 ^= data[j];
        for (var i = 0; i < GENERATOR1.length; ++i) {
          if (C & 1 << i) {
            c0 ^= GENERATOR1[i];
            c1 ^= GENERATOR2[i];
          }
        }
      }
      c1 ^= 1;
      if (c1 < 0) {
        c1 ^= 1 << 31;
        c1 += (1 << 30) * 2;
      }
      return c0 * (1 << 30) * 4 + c1;
    }
    module.exports = Address;
    var Script = require_script2();
  }
});

// node_modules/bitcore-lib-cash/lib/privatekey.js
var require_privatekey = __commonJS({
  "node_modules/bitcore-lib-cash/lib/privatekey.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var Address = require_address();
    var Base58Check = require_base58check();
    var BN = require_bn2();
    var JSUtil = require_js();
    var Networks = require_networks();
    var Point = require_point();
    var PublicKey = require_publickey2();
    var Random = require_random();
    var $ = require_preconditions();
    function PrivateKey(data, network) {
      if (!(this instanceof PrivateKey)) {
        return new PrivateKey(data, network);
      }
      if (data instanceof PrivateKey) {
        return data;
      }
      var info = this._classifyArguments(data, network);
      if (!info.bn || info.bn.cmp(new BN(0)) === 0) {
        throw new TypeError("Number can not be equal to zero, undefined, null or false");
      }
      if (!info.bn.lt(Point.getN())) {
        throw new TypeError("Number must be less than N");
      }
      if (typeof info.network === "undefined") {
        throw new TypeError('Must specify the network ("livenet" or "testnet")');
      }
      JSUtil.defineImmutable(this, {
        bn: info.bn,
        compressed: info.compressed,
        network: info.network
      });
      Object.defineProperty(this, "publicKey", {
        configurable: false,
        enumerable: true,
        get: this.toPublicKey.bind(this)
      });
      return this;
    }
    PrivateKey.prototype._classifyArguments = function(data, network) {
      var info = {
        compressed: true,
        network: network ? Networks.get(network) : Networks.defaultNetwork
      };
      if (_.isUndefined(data) || _.isNull(data)) {
        info.bn = PrivateKey._getRandomBN();
      } else if (data instanceof BN) {
        info.bn = data;
      } else if (data instanceof Buffer || data instanceof Uint8Array) {
        info = PrivateKey._transformBuffer(data, network);
      } else if (data.bn && data.network) {
        info = PrivateKey._transformObject(data);
      } else if (!network && Networks.get(data)) {
        info.bn = PrivateKey._getRandomBN();
        info.network = Networks.get(data);
      } else if (typeof data === "string") {
        if (JSUtil.isHexa(data)) {
          info.bn = new BN(Buffer.from(data, "hex"));
        } else {
          info = PrivateKey._transformWIF(data, network);
        }
      } else {
        throw new TypeError("First argument is an unrecognized data type.");
      }
      return info;
    };
    PrivateKey._getRandomBN = function() {
      var condition;
      var bn;
      do {
        var privbuf = Random.getRandomBuffer(32);
        bn = BN.fromBuffer(privbuf);
        condition = bn.lt(Point.getN());
      } while (!condition);
      return bn;
    };
    PrivateKey._transformBuffer = function(buf, network) {
      var info = {};
      if (buf.length === 32) {
        return PrivateKey._transformBNBuffer(buf, network);
      }
      info.network = Networks.get(buf[0], "privatekey");
      if (!info.network) {
        throw new Error("Invalid network");
      }
      if (network && info.network !== Networks.get(network)) {
        throw new TypeError("Private key network mismatch");
      }
      if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {
        info.compressed = true;
      } else if (buf.length === 1 + 32) {
        info.compressed = false;
      } else {
        throw new Error("Length of buffer must be 33 (uncompressed) or 34 (compressed)");
      }
      info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));
      return info;
    };
    PrivateKey._transformBNBuffer = function(buf, network) {
      var info = {};
      info.network = Networks.get(network) || Networks.defaultNetwork;
      info.bn = BN.fromBuffer(buf);
      info.compressed = false;
      return info;
    };
    PrivateKey._transformWIF = function(str, network) {
      return PrivateKey._transformBuffer(Base58Check.decode(str), network);
    };
    PrivateKey.fromBuffer = function(arg, network) {
      return new PrivateKey(arg, network);
    };
    PrivateKey._transformObject = function(json) {
      var bn = new BN(json.bn, "hex");
      var network = Networks.get(json.network);
      return {
        bn,
        network,
        compressed: json.compressed
      };
    };
    PrivateKey.fromString = PrivateKey.fromWIF = function(str) {
      $.checkArgument(_.isString(str), "First argument is expected to be a string.");
      return new PrivateKey(str);
    };
    PrivateKey.fromObject = function(obj) {
      $.checkArgument(_.isObject(obj), "First argument is expected to be an object.");
      return new PrivateKey(obj);
    };
    PrivateKey.fromRandom = function(network) {
      var bn = PrivateKey._getRandomBN();
      return new PrivateKey(bn, network);
    };
    PrivateKey.getValidationError = function(data, network) {
      var error;
      try {
        new PrivateKey(data, network);
      } catch (e) {
        error = e;
      }
      return error;
    };
    PrivateKey.isValid = function(data, network) {
      if (!data) {
        return false;
      }
      return !PrivateKey.getValidationError(data, network);
    };
    PrivateKey.prototype.toString = function() {
      return this.toBuffer().toString("hex");
    };
    PrivateKey.prototype.toWIF = function() {
      var network = this.network;
      var compressed = this.compressed;
      var buf;
      if (compressed) {
        buf = Buffer.concat([
          Buffer.from([network.privatekey]),
          this.bn.toBuffer({ size: 32 }),
          Buffer.from([1])
        ]);
      } else {
        buf = Buffer.concat([
          Buffer.from([network.privatekey]),
          this.bn.toBuffer({ size: 32 })
        ]);
      }
      return Base58Check.encode(buf);
    };
    PrivateKey.prototype.toBigNumber = function() {
      return this.bn;
    };
    PrivateKey.prototype.toBuffer = function() {
      return this.bn.toBuffer({ size: 32 });
    };
    PrivateKey.prototype.toBufferNoPadding = function() {
      return this.bn.toBuffer();
    };
    PrivateKey.prototype.toPublicKey = function() {
      if (!this._pubkey) {
        this._pubkey = PublicKey.fromPrivateKey(this);
      }
      return this._pubkey;
    };
    PrivateKey.prototype.toAddress = function(network) {
      var pubkey = this.toPublicKey();
      return Address.fromPublicKey(pubkey, network || this.network);
    };
    PrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {
      return {
        bn: this.bn.toString("hex"),
        compressed: this.compressed,
        network: this.network.toString()
      };
    };
    PrivateKey.prototype.inspect = function() {
      var uncompressed = !this.compressed ? ", uncompressed" : "";
      return "<PrivateKey: " + this.toString() + ", network: " + this.network + uncompressed + ">";
    };
    module.exports = PrivateKey;
  }
});

// node_modules/bitcore-lib-cash/lib/publickey.js
var require_publickey2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/publickey.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var Point = require_point();
    var Hash = require_hash2();
    var JSUtil = require_js();
    var Network = require_networks();
    var _ = require_lodash();
    var $ = require_preconditions();
    function PublicKey(data, extra) {
      if (!(this instanceof PublicKey)) {
        return new PublicKey(data, extra);
      }
      $.checkArgument(data, "First argument is required, please include public key data.");
      if (data instanceof PublicKey) {
        return data;
      }
      extra = extra || {};
      var info = this._classifyArgs(data, extra);
      info.point.validate();
      JSUtil.defineImmutable(this, {
        point: info.point,
        compressed: info.compressed,
        network: info.network || Network.defaultNetwork
      });
      return this;
    }
    PublicKey.prototype._classifyArgs = function(data, extra) {
      var info = {
        compressed: _.isUndefined(extra.compressed) || extra.compressed
      };
      if (data instanceof Point) {
        info.point = data;
      } else if (data.x && data.y) {
        info = PublicKey._transformObject(data);
      } else if (typeof data === "string") {
        info = PublicKey._transformDER(Buffer.from(data, "hex"));
      } else if (PublicKey._isBuffer(data)) {
        info = PublicKey._transformDER(data);
      } else if (PublicKey._isPrivateKey(data)) {
        info = PublicKey._transformPrivateKey(data);
      } else {
        throw new TypeError("First argument is an unrecognized data format.");
      }
      if (!info.network) {
        info.network = _.isUndefined(extra.network) ? void 0 : Network.get(extra.network);
      }
      return info;
    };
    PublicKey._isPrivateKey = function(param) {
      var PrivateKey = require_privatekey();
      return param instanceof PrivateKey;
    };
    PublicKey._isBuffer = function(param) {
      return param instanceof Buffer || param instanceof Uint8Array;
    };
    PublicKey._transformPrivateKey = function(privkey) {
      $.checkArgument(PublicKey._isPrivateKey(privkey), "Must be an instance of PrivateKey");
      var info = {};
      info.point = Point.getG().mul(privkey.bn);
      info.compressed = privkey.compressed;
      info.network = privkey.network;
      return info;
    };
    PublicKey._transformDER = function(buf, strict) {
      $.checkArgument(PublicKey._isBuffer(buf), "Must be a hex buffer of DER encoded public key");
      var info = {};
      strict = _.isUndefined(strict) ? true : strict;
      var x;
      var y;
      var xbuf;
      var ybuf;
      if (buf[0] === 4 || !strict && (buf[0] === 6 || buf[0] === 7)) {
        xbuf = buf.slice(1, 33);
        ybuf = buf.slice(33, 65);
        if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {
          throw new TypeError("Length of x and y must be 32 bytes");
        }
        x = new BN(xbuf);
        y = new BN(ybuf);
        info.point = new Point(x, y);
        info.compressed = false;
      } else if (buf[0] === 3) {
        xbuf = buf.slice(1);
        x = new BN(xbuf);
        info = PublicKey._transformX(true, x);
        info.compressed = true;
      } else if (buf[0] === 2) {
        xbuf = buf.slice(1);
        x = new BN(xbuf);
        info = PublicKey._transformX(false, x);
        info.compressed = true;
      } else {
        throw new TypeError("Invalid DER format public key");
      }
      return info;
    };
    PublicKey._transformX = function(odd, x) {
      $.checkArgument(typeof odd === "boolean", "Must specify whether y is odd or not (true or false)");
      var info = {};
      info.point = Point.fromX(odd, x);
      return info;
    };
    PublicKey._transformObject = function(json) {
      var x = new BN(json.x, "hex");
      var y = new BN(json.y, "hex");
      var point = new Point(x, y);
      return new PublicKey(point, {
        compressed: json.compressed
      });
    };
    PublicKey.fromPrivateKey = function(privkey) {
      $.checkArgument(PublicKey._isPrivateKey(privkey), "Must be an instance of PrivateKey");
      var info = PublicKey._transformPrivateKey(privkey);
      return new PublicKey(info.point, {
        compressed: info.compressed,
        network: info.network
      });
    };
    PublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {
      $.checkArgument(PublicKey._isBuffer(buf), "Must be a hex buffer of DER encoded public key");
      var info = PublicKey._transformDER(buf, strict);
      return new PublicKey(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey.fromPoint = function(point, compressed) {
      $.checkArgument(point instanceof Point, "First argument must be an instance of Point.");
      return new PublicKey(point, {
        compressed
      });
    };
    PublicKey.fromString = function(str, encoding) {
      var buf = Buffer.from(str, encoding || "hex");
      var info = PublicKey._transformDER(buf);
      return new PublicKey(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey.fromX = function(odd, x) {
      var info = PublicKey._transformX(odd, x);
      return new PublicKey(info.point, {
        compressed: info.compressed
      });
    };
    PublicKey.getValidationError = function(data) {
      var error;
      try {
        new PublicKey(data);
      } catch (e) {
        error = e;
      }
      return error;
    };
    PublicKey.isValid = function(data) {
      return !PublicKey.getValidationError(data);
    };
    PublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {
      return {
        x: this.point.getX().toString("hex", 2),
        y: this.point.getY().toString("hex", 2),
        compressed: this.compressed
      };
    };
    PublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {
      var x = this.point.getX();
      var y = this.point.getY();
      var xbuf = x.toBuffer({
        size: 32
      });
      var ybuf = y.toBuffer({
        size: 32
      });
      var prefix;
      if (!this.compressed) {
        prefix = Buffer.from([4]);
        return Buffer.concat([prefix, xbuf, ybuf]);
      } else {
        var odd = ybuf[ybuf.length - 1] % 2;
        if (odd) {
          prefix = Buffer.from([3]);
        } else {
          prefix = Buffer.from([2]);
        }
        return Buffer.concat([prefix, xbuf]);
      }
    };
    PublicKey.prototype._getID = function _getID() {
      return Hash.sha256ripemd160(this.toBuffer());
    };
    PublicKey.prototype.toAddress = function(network, type) {
      var Address = require_address();
      return Address.fromPublicKey(this, network || this.network, type);
    };
    PublicKey.prototype.toString = function() {
      return this.toDER().toString("hex");
    };
    PublicKey.prototype.inspect = function() {
      return "<PublicKey: " + this.toString() + (this.compressed ? "" : ", uncompressed") + ">";
    };
    module.exports = PublicKey;
  }
});

// node_modules/bitcore-lib-cash/lib/crypto/ecdsa.js
var require_ecdsa = __commonJS({
  "node_modules/bitcore-lib-cash/lib/crypto/ecdsa.js"(exports, module) {
    "use strict";
    var BN = require_bn2();
    var Point = require_point();
    var Signature = require_signature3();
    var PublicKey = require_publickey2();
    var Random = require_random();
    var Hash = require_hash2();
    var BufferUtil = require_buffer3();
    var _ = require_lodash();
    var $ = require_preconditions();
    var ECDSA = function ECDSA2(obj) {
      if (!(this instanceof ECDSA2)) {
        return new ECDSA2(obj);
      }
      if (obj) {
        this.set(obj);
      }
    };
    ECDSA.prototype.set = function(obj) {
      this.hashbuf = obj.hashbuf || this.hashbuf;
      this.endian = obj.endian || this.endian;
      this.privkey = obj.privkey || this.privkey;
      this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);
      this.sig = obj.sig || this.sig;
      this.k = obj.k || this.k;
      this.verified = obj.verified || this.verified;
      return this;
    };
    ECDSA.prototype.privkey2pubkey = function() {
      this.pubkey = this.privkey.toPublicKey();
    };
    ECDSA.prototype.calci = function() {
      for (var i = 0; i < 4; i++) {
        this.sig.i = i;
        var Qprime;
        try {
          Qprime = this.toPublicKey();
        } catch (e) {
          console.error(e);
          continue;
        }
        if (Qprime.point.eq(this.pubkey.point)) {
          this.sig.compressed = this.pubkey.compressed;
          return this;
        }
      }
      this.sig.i = void 0;
      throw new Error("Unable to find valid recovery factor");
    };
    ECDSA.fromString = function(str) {
      var obj = JSON.parse(str);
      return new ECDSA(obj);
    };
    ECDSA.prototype.randomK = function() {
      var N = Point.getN();
      var k;
      do {
        k = BN.fromBuffer(Random.getRandomBuffer(32));
      } while (!(k.lt(N) && k.gt(BN.Zero)));
      this.k = k;
      return this;
    };
    ECDSA.prototype.deterministicK = function(badrs) {
      if (_.isUndefined(badrs)) {
        badrs = 0;
      }
      var v = Buffer.alloc(32);
      v.fill(1);
      var k = Buffer.alloc(32);
      k.fill(0);
      var x = this.privkey.bn.toBuffer({
        size: 32
      });
      var hashbuf = this.endian === "little" ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;
      k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0]), x, hashbuf]), k);
      v = Hash.sha256hmac(v, k);
      k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([1]), x, hashbuf]), k);
      v = Hash.sha256hmac(v, k);
      v = Hash.sha256hmac(v, k);
      var T = BN.fromBuffer(v);
      var N = Point.getN();
      for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {
        k = Hash.sha256hmac(Buffer.concat([v, Buffer.from([0])]), k);
        v = Hash.sha256hmac(v, k);
        v = Hash.sha256hmac(v, k);
        T = BN.fromBuffer(v);
      }
      this.k = T;
      return this;
    };
    ECDSA.prototype.toPublicKey = function() {
      var i = this.sig.i;
      $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error("i must be equal to 0, 1, 2, or 3"));
      var e = BN.fromBuffer(this.hashbuf);
      var r = this.sig.r;
      var s = this.sig.s;
      var isYOdd = i & 1;
      var isSecondKey = i >> 1;
      var n = Point.getN();
      var G = Point.getG();
      var x = isSecondKey ? r.add(n) : r;
      var R = Point.fromX(isYOdd, x);
      var nR = R.mul(n);
      if (!nR.isInfinity()) {
        throw new Error("nR is not a valid curve point");
      }
      var eNeg = e.neg().umod(n);
      var rInv = r.invm(n);
      var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);
      var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);
      return pubkey;
    };
    ECDSA.prototype.sigError = function() {
      if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {
        return "hashbuf must be a 32 byte buffer";
      }
      var r = this.sig.r;
      var s = this.sig.s;
      if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {
        return "r and s not in range";
      }
      var e = BN.fromBuffer(this.hashbuf, this.endian ? {
        endian: this.endian
      } : void 0);
      var n = Point.getN();
      var sinv = s.invm(n);
      var u1 = sinv.mul(e).umod(n);
      var u2 = sinv.mul(r).umod(n);
      var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);
      if (p.isInfinity()) {
        return "p is infinity";
      }
      if (p.getX().umod(n).cmp(r) !== 0) {
        return "Invalid signature";
      } else {
        return false;
      }
    };
    ECDSA.toLowS = function(s) {
      if (s.gt(BN.fromBuffer(Buffer.from("7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0", "hex")))) {
        s = Point.getN().sub(s);
      }
      return s;
    };
    ECDSA.prototype._findSignature = function(d, e) {
      var N = Point.getN();
      var G = Point.getG();
      var badrs = 0;
      var k, Q, r, s;
      do {
        if (!this.k || badrs > 0) {
          this.deterministicK(badrs);
        }
        badrs++;
        k = this.k;
        Q = G.mul(k);
        r = Q.x.umod(N);
        s = k.invm(N).mul(e.add(d.mul(r))).umod(N);
      } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);
      s = ECDSA.toLowS(s);
      return {
        s,
        r
      };
    };
    ECDSA.prototype.sign = function() {
      var hashbuf = this.hashbuf;
      var privkey = this.privkey;
      var d = privkey.bn;
      $.checkState(hashbuf && privkey && d, new Error("invalid parameters"));
      $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error("hashbuf must be a 32 byte buffer"));
      var e = BN.fromBuffer(hashbuf, this.endian ? {
        endian: this.endian
      } : void 0);
      var obj = this._findSignature(d, e);
      obj.compressed = this.pubkey.compressed;
      this.sig = new Signature(obj);
      return this;
    };
    ECDSA.prototype.signRandomK = function() {
      this.randomK();
      return this.sign();
    };
    ECDSA.prototype.toString = function() {
      var obj = {};
      if (this.hashbuf) {
        obj.hashbuf = this.hashbuf.toString("hex");
      }
      if (this.privkey) {
        obj.privkey = this.privkey.toString();
      }
      if (this.pubkey) {
        obj.pubkey = this.pubkey.toString();
      }
      if (this.sig) {
        obj.sig = this.sig.toString();
      }
      if (this.k) {
        obj.k = this.k.toString();
      }
      return JSON.stringify(obj);
    };
    ECDSA.prototype.verify = function() {
      if (!this.sigError()) {
        this.verified = true;
      } else {
        this.verified = false;
      }
      return this;
    };
    ECDSA.sign = function(hashbuf, privkey, endian) {
      return ECDSA().set({
        hashbuf,
        endian,
        privkey
      }).sign().sig;
    };
    ECDSA.verify = function(hashbuf, sig, pubkey, endian) {
      return ECDSA().set({
        hashbuf,
        endian,
        sig,
        pubkey
      }).verify().verified;
    };
    module.exports = ECDSA;
  }
});

// node_modules/bitcore-lib-cash/lib/encoding/varint.js
var require_varint = __commonJS({
  "node_modules/bitcore-lib-cash/lib/encoding/varint.js"(exports, module) {
    "use strict";
    var BufferWriter = require_bufferwriter();
    var BufferReader = require_bufferreader();
    var BN = require_bn2();
    var Varint = function Varint2(buf) {
      if (!(this instanceof Varint2))
        return new Varint2(buf);
      if (Buffer.isBuffer(buf)) {
        this.buf = buf;
      } else if (typeof buf === "number") {
        var num = buf;
        this.fromNumber(num);
      } else if (buf instanceof BN) {
        var bn = buf;
        this.fromBN(bn);
      } else if (buf) {
        var obj = buf;
        this.set(obj);
      }
    };
    Varint.prototype.set = function(obj) {
      this.buf = obj.buf || this.buf;
      return this;
    };
    Varint.prototype.fromString = function(str) {
      this.set({
        buf: Buffer.from(str, "hex")
      });
      return this;
    };
    Varint.prototype.toString = function() {
      return this.buf.toString("hex");
    };
    Varint.prototype.fromBuffer = function(buf) {
      this.buf = buf;
      return this;
    };
    Varint.prototype.fromBufferReader = function(br) {
      this.buf = br.readVarintBuf();
      return this;
    };
    Varint.prototype.fromBN = function(bn) {
      this.buf = BufferWriter().writeVarintBN(bn).concat();
      return this;
    };
    Varint.prototype.fromNumber = function(num) {
      this.buf = BufferWriter().writeVarintNum(num).concat();
      return this;
    };
    Varint.prototype.toBuffer = function() {
      return this.buf;
    };
    Varint.prototype.toBN = function() {
      return BufferReader(this.buf).readVarintBN();
    };
    Varint.prototype.toNumber = function() {
      return BufferReader(this.buf).readVarintNum();
    };
    module.exports = Varint;
  }
});

// node_modules/bitcore-lib-cash/lib/block/blockheader.js
var require_blockheader = __commonJS({
  "node_modules/bitcore-lib-cash/lib/block/blockheader.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var BN = require_bn2();
    var BufferUtil = require_buffer3();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash = require_hash2();
    var JSUtil = require_js();
    var $ = require_preconditions();
    var GENESIS_BITS = 486604799;
    var BlockHeader = function BlockHeader2(arg) {
      if (!(this instanceof BlockHeader2)) {
        return new BlockHeader2(arg);
      }
      var info = BlockHeader2._from(arg);
      this.version = info.version;
      this.prevHash = info.prevHash;
      this.merkleRoot = info.merkleRoot;
      this.time = info.time;
      this.timestamp = info.time;
      this.bits = info.bits;
      this.nonce = info.nonce;
      if (info.hash) {
        $.checkState(
          this.hash === info.hash,
          "Argument object hash property does not match block hash."
        );
      }
      return this;
    };
    BlockHeader._from = function _from(arg) {
      var info = {};
      if (BufferUtil.isBuffer(arg)) {
        info = BlockHeader._fromBufferReader(BufferReader(arg));
      } else if (_.isObject(arg)) {
        info = BlockHeader._fromObject(arg);
      } else {
        throw new TypeError("Unrecognized argument for BlockHeader");
      }
      return info;
    };
    BlockHeader._fromObject = function _fromObject(data) {
      $.checkArgument(data, "data is required");
      var prevHash = data.prevHash;
      var merkleRoot = data.merkleRoot;
      if (_.isString(data.prevHash)) {
        prevHash = BufferUtil.reverse(Buffer.from(data.prevHash, "hex"));
      }
      if (_.isString(data.merkleRoot)) {
        merkleRoot = BufferUtil.reverse(Buffer.from(data.merkleRoot, "hex"));
      }
      var info = {
        hash: data.hash,
        version: data.version,
        prevHash,
        merkleRoot,
        time: data.time,
        timestamp: data.time,
        bits: data.bits,
        nonce: data.nonce
      };
      return info;
    };
    BlockHeader.fromObject = function fromObject(obj) {
      var info = BlockHeader._fromObject(obj);
      return new BlockHeader(info);
    };
    BlockHeader.fromRawBlock = function fromRawBlock(data) {
      if (!BufferUtil.isBuffer(data)) {
        data = Buffer.from(data, "binary");
      }
      var br = BufferReader(data);
      br.pos = BlockHeader.Constants.START_OF_HEADER;
      var info = BlockHeader._fromBufferReader(br);
      return new BlockHeader(info);
    };
    BlockHeader.fromBuffer = function fromBuffer(buf) {
      var info = BlockHeader._fromBufferReader(BufferReader(buf));
      return new BlockHeader(info);
    };
    BlockHeader.fromString = function fromString(str) {
      var buf = Buffer.from(str, "hex");
      return BlockHeader.fromBuffer(buf);
    };
    BlockHeader._fromBufferReader = function _fromBufferReader(br) {
      var info = {};
      info.version = br.readInt32LE();
      info.prevHash = br.read(32);
      info.merkleRoot = br.read(32);
      info.time = br.readUInt32LE();
      info.bits = br.readUInt32LE();
      info.nonce = br.readUInt32LE();
      return info;
    };
    BlockHeader.fromBufferReader = function fromBufferReader(br) {
      var info = BlockHeader._fromBufferReader(br);
      return new BlockHeader(info);
    };
    BlockHeader.prototype.toObject = BlockHeader.prototype.toJSON = function toObject() {
      return {
        hash: this.hash,
        version: this.version,
        prevHash: BufferUtil.reverse(this.prevHash).toString("hex"),
        merkleRoot: BufferUtil.reverse(this.merkleRoot).toString("hex"),
        time: this.time,
        bits: this.bits,
        nonce: this.nonce
      };
    };
    BlockHeader.prototype.toBuffer = function toBuffer() {
      return this.toBufferWriter().concat();
    };
    BlockHeader.prototype.toString = function toString() {
      return this.toBuffer().toString("hex");
    };
    BlockHeader.prototype.toBufferWriter = function toBufferWriter(bw) {
      if (!bw) {
        bw = new BufferWriter();
      }
      bw.writeInt32LE(this.version);
      bw.write(this.prevHash);
      bw.write(this.merkleRoot);
      bw.writeUInt32LE(this.time);
      bw.writeUInt32LE(this.bits);
      bw.writeUInt32LE(this.nonce);
      return bw;
    };
    BlockHeader.prototype.getTargetDifficulty = function getTargetDifficulty(bits) {
      bits = bits || this.bits;
      var target = new BN(bits & 16777215);
      var mov = 8 * ((bits >>> 24) - 3);
      while (mov-- > 0) {
        target = target.mul(new BN(2));
      }
      return target;
    };
    BlockHeader.prototype.getDifficulty = function getDifficulty() {
      var difficulty1TargetBN = this.getTargetDifficulty(GENESIS_BITS).mul(new BN(Math.pow(10, 8)));
      var currentTargetBN = this.getTargetDifficulty();
      var difficultyString = difficulty1TargetBN.div(currentTargetBN).toString(10);
      var decimalPos = difficultyString.length - 8;
      difficultyString = difficultyString.slice(0, decimalPos) + "." + difficultyString.slice(decimalPos);
      return parseFloat(difficultyString);
    };
    BlockHeader.prototype._getHash = function hash() {
      var buf = this.toBuffer();
      return Hash.sha256sha256(buf);
    };
    var idProperty = {
      configurable: false,
      enumerable: true,
      /**
       * @returns {string} - The big endian hash buffer of the header
       */
      get: function() {
        if (!this._id) {
          this._id = BufferReader(this._getHash()).readReverse().toString("hex");
        }
        return this._id;
      },
      set: _.noop
    };
    Object.defineProperty(BlockHeader.prototype, "id", idProperty);
    Object.defineProperty(BlockHeader.prototype, "hash", idProperty);
    BlockHeader.prototype.validTimestamp = function validTimestamp() {
      var currentTime = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
      if (this.time > currentTime + BlockHeader.Constants.MAX_TIME_OFFSET) {
        return false;
      }
      return true;
    };
    BlockHeader.prototype.validProofOfWork = function validProofOfWork() {
      var pow = new BN(this.id, "hex");
      var target = this.getTargetDifficulty();
      if (pow.cmp(target) > 0) {
        return false;
      }
      return true;
    };
    BlockHeader.prototype.inspect = function inspect() {
      return "<BlockHeader " + this.id + ">";
    };
    BlockHeader.Constants = {
      START_OF_HEADER: 8,
      // Start buffer position in raw block data
      MAX_TIME_OFFSET: 2 * 60 * 60,
      // The max a timestamp can be in the future
      LARGEST_HASH: new BN("10000000000000000000000000000000000000000000000000000000000000000", "hex")
    };
    module.exports = BlockHeader;
  }
});

// node_modules/bitcore-lib-cash/lib/block/block.js
var require_block = __commonJS({
  "node_modules/bitcore-lib-cash/lib/block/block.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var BlockHeader = require_blockheader();
    var BN = require_bn2();
    var BufferUtil = require_buffer3();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash = require_hash2();
    var Transaction = require_transaction2();
    var $ = require_preconditions();
    function Block(arg) {
      if (!(this instanceof Block)) {
        return new Block(arg);
      }
      _.extend(this, Block._from(arg));
      return this;
    }
    Block.MAX_BLOCK_SIZE = 1e6;
    Block._from = function _from(arg) {
      var info = {};
      if (BufferUtil.isBuffer(arg)) {
        info = Block._fromBufferReader(BufferReader(arg));
      } else if (_.isObject(arg)) {
        info = Block._fromObject(arg);
      } else {
        throw new TypeError("Unrecognized argument for Block");
      }
      return info;
    };
    Block._fromObject = function _fromObject(data) {
      var transactions = [];
      data.transactions.forEach(function(tx) {
        if (tx instanceof Transaction) {
          transactions.push(tx);
        } else {
          transactions.push(Transaction().fromObject(tx));
        }
      });
      var info = {
        header: BlockHeader.fromObject(data.header),
        transactions
      };
      return info;
    };
    Block.fromObject = function fromObject(obj) {
      var info = Block._fromObject(obj);
      return new Block(info);
    };
    Block._fromBufferReader = function _fromBufferReader(br) {
      var info = {};
      $.checkState(!br.finished(), "No block data received");
      info.header = BlockHeader.fromBufferReader(br);
      var transactions = br.readVarintNum();
      info.transactions = [];
      for (var i = 0; i < transactions; i++) {
        info.transactions.push(Transaction().fromBufferReader(br));
      }
      return info;
    };
    Block.fromBufferReader = function fromBufferReader(br) {
      $.checkArgument(br, "br is required");
      var info = Block._fromBufferReader(br);
      return new Block(info);
    };
    Block.fromBuffer = function fromBuffer(buf) {
      return Block.fromBufferReader(new BufferReader(buf));
    };
    Block.fromString = function fromString(str) {
      var buf = Buffer.from(str, "hex");
      return Block.fromBuffer(buf);
    };
    Block.fromRawBlock = function fromRawBlock(data) {
      if (!BufferUtil.isBuffer(data)) {
        data = Buffer.from(data, "binary");
      }
      var br = BufferReader(data);
      br.pos = Block.Values.START_OF_BLOCK;
      var info = Block._fromBufferReader(br);
      return new Block(info);
    };
    Block.prototype.toObject = Block.prototype.toJSON = function toObject() {
      var transactions = [];
      this.transactions.forEach(function(tx) {
        transactions.push(tx.toObject());
      });
      return {
        header: this.header.toObject(),
        transactions
      };
    };
    Block.prototype.toBuffer = function toBuffer() {
      return this.toBufferWriter().concat();
    };
    Block.prototype.toString = function toString() {
      return this.toBuffer().toString("hex");
    };
    Block.prototype.toBufferWriter = function toBufferWriter(bw) {
      if (!bw) {
        bw = new BufferWriter();
      }
      bw.write(this.header.toBuffer());
      bw.writeVarintNum(this.transactions.length);
      for (var i = 0; i < this.transactions.length; i++) {
        this.transactions[i].toBufferWriter(bw);
      }
      return bw;
    };
    Block.prototype.getTransactionHashes = function getTransactionHashes() {
      var hashes = [];
      if (this.transactions.length === 0) {
        return [Block.Values.NULL_HASH];
      }
      for (var t = 0; t < this.transactions.length; t++) {
        hashes.push(this.transactions[t]._getHash());
      }
      return hashes;
    };
    Block.prototype.getMerkleTree = function getMerkleTree() {
      var tree = this.getTransactionHashes();
      var j = 0;
      for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {
        for (var i = 0; i < size; i += 2) {
          var i2 = Math.min(i + 1, size - 1);
          var buf = Buffer.concat([tree[j + i], tree[j + i2]]);
          tree.push(Hash.sha256sha256(buf));
        }
        j += size;
      }
      return tree;
    };
    Block.prototype.getMerkleRoot = function getMerkleRoot() {
      var tree = this.getMerkleTree();
      return tree[tree.length - 1];
    };
    Block.prototype.validMerkleRoot = function validMerkleRoot() {
      var h = new BN(this.header.merkleRoot.toString("hex"), "hex");
      var c = new BN(this.getMerkleRoot().toString("hex"), "hex");
      if (h.cmp(c) !== 0) {
        return false;
      }
      return true;
    };
    Block.prototype._getHash = function() {
      return this.header._getHash();
    };
    var idProperty = {
      configurable: false,
      enumerable: true,
      /**
       * @returns {string} - The big endian hash buffer of the header
       */
      get: function() {
        if (!this._id) {
          this._id = this.header.id;
        }
        return this._id;
      },
      set: _.noop
    };
    Object.defineProperty(Block.prototype, "id", idProperty);
    Object.defineProperty(Block.prototype, "hash", idProperty);
    Block.prototype.inspect = function inspect() {
      return "<Block " + this.id + ">";
    };
    Block.Values = {
      START_OF_BLOCK: 8,
      // Start of block in raw block data
      NULL_HASH: Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex")
    };
    module.exports = Block;
  }
});

// node_modules/bitcore-lib-cash/lib/block/merkleblock.js
var require_merkleblock = __commonJS({
  "node_modules/bitcore-lib-cash/lib/block/merkleblock.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var BlockHeader = require_blockheader();
    var BufferUtil = require_buffer3();
    var BufferReader = require_bufferreader();
    var BufferWriter = require_bufferwriter();
    var Hash = require_hash2();
    var JSUtil = require_js();
    var Transaction = require_transaction2();
    var errors = require_errors();
    var $ = require_preconditions();
    function MerkleBlock(arg) {
      if (!(this instanceof MerkleBlock)) {
        return new MerkleBlock(arg);
      }
      var info = {};
      if (BufferUtil.isBuffer(arg)) {
        info = MerkleBlock._fromBufferReader(BufferReader(arg));
      } else if (_.isObject(arg)) {
        var header;
        if (arg.header instanceof BlockHeader) {
          header = arg.header;
        } else {
          header = BlockHeader.fromObject(arg.header);
        }
        info = {
          /**
           * @name MerkleBlock#header
           * @type {BlockHeader}
           */
          header,
          /**
           * @name MerkleBlock#numTransactions
           * @type {Number}
           */
          numTransactions: arg.numTransactions,
          /**
           * @name MerkleBlock#hashes
           * @type {String[]}
           */
          hashes: arg.hashes,
          /**
           * @name MerkleBlock#flags
           * @type {Number[]}
           */
          flags: arg.flags
        };
      } else {
        throw new TypeError("Unrecognized argument for MerkleBlock");
      }
      _.extend(this, info);
      this._flagBitsUsed = 0;
      this._hashesUsed = 0;
      return this;
    }
    MerkleBlock.fromBuffer = function fromBuffer(buf) {
      return MerkleBlock.fromBufferReader(BufferReader(buf));
    };
    MerkleBlock.fromBufferReader = function fromBufferReader(br) {
      return new MerkleBlock(MerkleBlock._fromBufferReader(br));
    };
    MerkleBlock.prototype.toBuffer = function toBuffer() {
      return this.toBufferWriter().concat();
    };
    MerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {
      if (!bw) {
        bw = new BufferWriter();
      }
      bw.write(this.header.toBuffer());
      bw.writeUInt32LE(this.numTransactions);
      bw.writeVarintNum(this.hashes.length);
      for (var i = 0; i < this.hashes.length; i++) {
        bw.write(Buffer.from(this.hashes[i], "hex"));
      }
      bw.writeVarintNum(this.flags.length);
      for (i = 0; i < this.flags.length; i++) {
        bw.writeUInt8(this.flags[i]);
      }
      return bw;
    };
    MerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {
      return {
        header: this.header.toObject(),
        numTransactions: this.numTransactions,
        hashes: this.hashes,
        flags: this.flags
      };
    };
    MerkleBlock.prototype.validMerkleTree = function validMerkleTree() {
      $.checkState(_.isArray(this.flags), "MerkleBlock flags is not an array");
      $.checkState(_.isArray(this.hashes), "MerkleBlock hashes is not an array");
      if (this.hashes.length > this.numTransactions) {
        return false;
      }
      if (this.flags.length * 8 < this.hashes.length) {
        return false;
      }
      var height = this._calcTreeHeight();
      var opts = { hashesUsed: 0, flagBitsUsed: 0 };
      var root = this._traverseMerkleTree(height, 0, opts);
      if (opts.hashesUsed !== this.hashes.length) {
        return false;
      }
      return BufferUtil.equals(root, this.header.merkleRoot);
    };
    MerkleBlock.prototype.filterdTxsHash = function filterdTxsHash() {
      $.checkState(_.isArray(this.flags), "MerkleBlock flags is not an array");
      $.checkState(_.isArray(this.hashes), "MerkleBlock hashes is not an array");
      if (this.hashes.length > this.numTransactions) {
        throw new errors.MerkleBlock.InvalidMerkleTree();
      }
      if (this.flags.length * 8 < this.hashes.length) {
        throw new errors.MerkleBlock.InvalidMerkleTree();
      }
      if (this.hashes.length === 1) {
        return [];
      }
      ;
      var height = this._calcTreeHeight();
      var opts = { hashesUsed: 0, flagBitsUsed: 0 };
      var txs = this._traverseMerkleTree(height, 0, opts, true);
      if (opts.hashesUsed !== this.hashes.length) {
        throw new errors.MerkleBlock.InvalidMerkleTree();
      }
      return txs;
    };
    MerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts, checkForTxs) {
      opts = opts || {};
      opts.txs = opts.txs || [];
      opts.flagBitsUsed = opts.flagBitsUsed || 0;
      opts.hashesUsed = opts.hashesUsed || 0;
      var checkForTxs = checkForTxs || false;
      if (opts.flagBitsUsed > this.flags.length * 8) {
        return null;
      }
      var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7) & 1;
      if (depth === 0 || !isParentOfMatch) {
        if (opts.hashesUsed >= this.hashes.length) {
          return null;
        }
        var hash = this.hashes[opts.hashesUsed++];
        if (depth === 0 && isParentOfMatch) {
          opts.txs.push(hash);
        }
        return Buffer.from(hash, "hex");
      } else {
        var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);
        var right = left;
        if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {
          right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);
        }
        if (checkForTxs) {
          return opts.txs;
        } else {
          return Hash.sha256sha256(new Buffer.concat([left, right]));
        }
        ;
      }
    };
    MerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {
      return this.numTransactions + (1 << height) - 1 >> height;
    };
    MerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {
      var height = 0;
      while (this._calcTreeWidth(height) > 1) {
        height++;
      }
      return height;
    };
    MerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {
      $.checkArgument(!_.isUndefined(tx), "tx cannot be undefined");
      $.checkArgument(
        tx instanceof Transaction || typeof tx === "string",
        'Invalid tx given, tx must be a "string" or "Transaction"'
      );
      var hash = tx;
      if (tx instanceof Transaction) {
        hash = BufferUtil.reverse(Buffer.from(tx.id, "hex")).toString("hex");
      }
      var txs = [];
      var height = this._calcTreeHeight();
      this._traverseMerkleTree(height, 0, { txs });
      return txs.indexOf(hash) !== -1;
    };
    MerkleBlock._fromBufferReader = function _fromBufferReader(br) {
      $.checkState(!br.finished(), "No merkleblock data received");
      var info = {};
      info.header = BlockHeader.fromBufferReader(br);
      info.numTransactions = br.readUInt32LE();
      var numHashes = br.readVarintNum();
      info.hashes = [];
      for (var i = 0; i < numHashes; i++) {
        info.hashes.push(br.read(32).toString("hex"));
      }
      var numFlags = br.readVarintNum();
      info.flags = [];
      for (i = 0; i < numFlags; i++) {
        info.flags.push(br.readUInt8());
      }
      return info;
    };
    MerkleBlock.fromObject = function fromObject(obj) {
      return new MerkleBlock(obj);
    };
    module.exports = MerkleBlock;
  }
});

// node_modules/bitcore-lib-cash/lib/block/index.js
var require_block2 = __commonJS({
  "node_modules/bitcore-lib-cash/lib/block/index.js"(exports, module) {
    module.exports = require_block();
    module.exports.BlockHeader = require_blockheader();
    module.exports.MerkleBlock = require_merkleblock();
  }
});

// node_modules/bitcore-lib-cash/lib/hdpublickey.js
var require_hdpublickey = __commonJS({
  "node_modules/bitcore-lib-cash/lib/hdpublickey.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var $ = require_preconditions();
    var BN = require_bn2();
    var Base58 = require_base58();
    var Base58Check = require_base58check();
    var Hash = require_hash2();
    var HDPrivateKey = require_hdprivatekey();
    var Network = require_networks();
    var Point = require_point();
    var PublicKey = require_publickey2();
    var bitcoreErrors = require_errors();
    var errors = bitcoreErrors;
    var hdErrors = bitcoreErrors.HDPublicKey;
    var assert = require_assert();
    var JSUtil = require_js();
    var BufferUtil = require_buffer3();
    function HDPublicKey(arg) {
      if (arg instanceof HDPublicKey) {
        return arg;
      }
      if (!(this instanceof HDPublicKey)) {
        return new HDPublicKey(arg);
      }
      if (arg) {
        if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
          var error = HDPublicKey.getSerializedError(arg);
          if (!error) {
            return this._buildFromSerialized(arg);
          } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {
            return this._buildFromSerialized(arg.toString());
          } else {
            if (error instanceof hdErrors.ArgumentIsPrivateExtended) {
              return new HDPrivateKey(arg).hdPublicKey;
            }
            throw error;
          }
        } else {
          if (_.isObject(arg)) {
            if (arg instanceof HDPrivateKey) {
              return this._buildFromPrivate(arg);
            } else {
              return this._buildFromObject(arg);
            }
          } else {
            throw new hdErrors.UnrecognizedArgument(arg);
          }
        }
      } else {
        throw new hdErrors.MustSupplyArgument();
      }
    }
    HDPublicKey.isValidPath = function(arg) {
      if (_.isString(arg)) {
        var indexes = HDPrivateKey._getDerivationIndexes(arg);
        return indexes !== null && _.every(indexes, HDPublicKey.isValidPath);
      }
      if (_.isNumber(arg)) {
        return arg >= 0 && arg < HDPublicKey.Hardened;
      }
      return false;
    };
    HDPublicKey.prototype.derive = function(arg, hardened) {
      return this.deriveChild(arg, hardened);
    };
    HDPublicKey.prototype.deriveChild = function(arg, hardened) {
      if (_.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened);
      } else if (_.isString(arg)) {
        return this._deriveFromString(arg);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPublicKey.prototype._deriveWithNumber = function(index, hardened) {
      if (index >= HDPublicKey.Hardened || hardened) {
        throw new hdErrors.InvalidIndexCantDeriveHardened();
      }
      if (index < 0) {
        throw new hdErrors.InvalidPath(index);
      }
      var indexBuffer = BufferUtil.integerAsBuffer(index);
      var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
      var hash = Hash.sha512hmac(data, this._buffers.chainCode);
      var leftPart = BN.fromBuffer(hash.slice(0, 32), { size: 32 });
      var chainCode = hash.slice(32, 64);
      var publicKey;
      try {
        publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));
      } catch (e) {
        return this._deriveWithNumber(index + 1);
      }
      var derived = new HDPublicKey({
        network: this.network,
        depth: this.depth + 1,
        parentFingerPrint: this.fingerPrint,
        childIndex: index,
        chainCode,
        publicKey
      });
      return derived;
    };
    HDPublicKey.prototype._deriveFromString = function(path) {
      if (_.includes(path, "'")) {
        throw new hdErrors.InvalidIndexCantDeriveHardened();
      } else if (!HDPublicKey.isValidPath(path)) {
        throw new hdErrors.InvalidPath(path);
      }
      var indexes = HDPrivateKey._getDerivationIndexes(path);
      var derived = indexes.reduce(function(prev, index) {
        return prev._deriveWithNumber(index);
      }, this);
      return derived;
    };
    HDPublicKey.isValidSerialized = function(data, network) {
      return _.isNull(HDPublicKey.getSerializedError(data, network));
    };
    HDPublicKey.getSerializedError = function(data, network) {
      if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
        return new hdErrors.UnrecognizedArgument("expected buffer or string");
      }
      if (!Base58.validCharacters(data)) {
        return new errors.InvalidB58Char("(unknown)", data);
      }
      try {
        data = Base58Check.decode(data);
      } catch (e) {
        return new errors.InvalidB58Checksum(data);
      }
      if (data.length !== HDPublicKey.DataSize) {
        return new hdErrors.InvalidLength(data);
      }
      if (!_.isUndefined(network)) {
        var error = HDPublicKey._validateNetwork(data, network);
        if (error) {
          return error;
        }
      }
      var version = BufferUtil.integerFromBuffer(data.slice(0, 4));
      if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {
        return new hdErrors.ArgumentIsPrivateExtended();
      }
      return null;
    };
    HDPublicKey._validateNetwork = function(data, networkArg) {
      var network = Network.get(networkArg);
      if (!network) {
        return new errors.InvalidNetworkArgument(networkArg);
      }
      var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);
      if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {
        return new errors.InvalidNetwork(version);
      }
      return null;
    };
    HDPublicKey.prototype._buildFromPrivate = function(arg) {
      var args = _.clone(arg._buffers);
      var point = Point.getG().mul(BN.fromBuffer(args.privateKey));
      args.publicKey = Point.pointToCompressed(point);
      args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);
      args.privateKey = void 0;
      args.checksum = void 0;
      args.xprivkey = void 0;
      return this._buildFromBuffers(args);
    };
    HDPublicKey.prototype._buildFromObject = function(arg) {
      var buffers = {
        version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,
        depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
        parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
        childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
        chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, "hex") : arg.chainCode,
        publicKey: _.isString(arg.publicKey) ? Buffer.from(arg.publicKey, "hex") : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),
        checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum
      };
      return this._buildFromBuffers(buffers);
    };
    HDPublicKey.prototype._buildFromSerialized = function(arg) {
      var decoded = Base58Check.decode(arg);
      var buffers = {
        version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),
        depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),
        parentFingerPrint: decoded.slice(
          HDPublicKey.ParentFingerPrintStart,
          HDPublicKey.ParentFingerPrintEnd
        ),
        childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),
        chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),
        publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),
        checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),
        xpubkey: arg
      };
      return this._buildFromBuffers(buffers);
    };
    HDPublicKey.prototype._buildFromBuffers = function(arg) {
      HDPublicKey._validateBufferArguments(arg);
      JSUtil.defineImmutable(this, {
        _buffers: arg
      });
      var sequence = [
        arg.version,
        arg.depth,
        arg.parentFingerPrint,
        arg.childIndex,
        arg.chainCode,
        arg.publicKey
      ];
      var concat = BufferUtil.concat(sequence);
      var checksum = Base58Check.checksum(concat);
      if (!arg.checksum || !arg.checksum.length) {
        arg.checksum = checksum;
      } else {
        if (arg.checksum.toString("hex") !== checksum.toString("hex")) {
          throw new errors.InvalidB58Checksum(concat, checksum);
        }
      }
      var network = Network.get(BufferUtil.integerFromBuffer(arg.version));
      var xpubkey;
      xpubkey = Base58Check.encode(BufferUtil.concat(sequence));
      arg.xpubkey = Buffer.from(xpubkey);
      var publicKey = new PublicKey(arg.publicKey, { network });
      var size = HDPublicKey.ParentFingerPrintSize;
      var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);
      JSUtil.defineImmutable(this, {
        xpubkey,
        network,
        depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
        publicKey,
        fingerPrint
      });
      return this;
    };
    HDPublicKey._validateBufferArguments = function(arg) {
      var checkBuffer = function(name, size) {
        var buff = arg[name];
        assert(BufferUtil.isBuffer(buff), name + " argument is not a buffer, it's " + typeof buff);
        assert(
          buff.length === size,
          name + " has not the expected size: found " + buff.length + ", expected " + size
        );
      };
      checkBuffer("version", HDPublicKey.VersionSize);
      checkBuffer("depth", HDPublicKey.DepthSize);
      checkBuffer("parentFingerPrint", HDPublicKey.ParentFingerPrintSize);
      checkBuffer("childIndex", HDPublicKey.ChildIndexSize);
      checkBuffer("chainCode", HDPublicKey.ChainCodeSize);
      checkBuffer("publicKey", HDPublicKey.PublicKeySize);
      if (arg.checksum && arg.checksum.length) {
        checkBuffer("checksum", HDPublicKey.CheckSumSize);
      }
    };
    HDPublicKey.fromString = function(arg) {
      $.checkArgument(_.isString(arg), "No valid string was provided");
      return new HDPublicKey(arg);
    };
    HDPublicKey.fromObject = function(arg) {
      $.checkArgument(_.isObject(arg), "No valid argument was provided");
      return new HDPublicKey(arg);
    };
    HDPublicKey.prototype.toString = function() {
      return this.xpubkey;
    };
    HDPublicKey.prototype.inspect = function() {
      return "<HDPublicKey: " + this.xpubkey + ">";
    };
    HDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {
      return {
        network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,
        depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
        fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
        parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
        childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
        chainCode: Buffer.from(this._buffers.chainCode, "hex"),
        publicKey: this.publicKey.toString(),
        checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
        xpubkey: this.xpubkey
      };
    };
    HDPublicKey.fromBuffer = function(arg) {
      return new HDPublicKey(arg);
    };
    HDPublicKey.prototype.toBuffer = function() {
      return BufferUtil.copy(this._buffers.xpubkey);
    };
    HDPublicKey.Hardened = 2147483648;
    HDPublicKey.RootElementAlias = ["m", "M"];
    HDPublicKey.VersionSize = 4;
    HDPublicKey.DepthSize = 1;
    HDPublicKey.ParentFingerPrintSize = 4;
    HDPublicKey.ChildIndexSize = 4;
    HDPublicKey.ChainCodeSize = 32;
    HDPublicKey.PublicKeySize = 33;
    HDPublicKey.CheckSumSize = 4;
    HDPublicKey.DataSize = 78;
    HDPublicKey.SerializedByteSize = 82;
    HDPublicKey.VersionStart = 0;
    HDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;
    HDPublicKey.DepthStart = HDPublicKey.VersionEnd;
    HDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;
    HDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;
    HDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;
    HDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;
    HDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;
    HDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;
    HDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;
    HDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;
    HDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;
    HDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;
    HDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;
    assert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);
    assert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);
    module.exports = HDPublicKey;
  }
});

// node_modules/bitcore-lib-cash/lib/hdprivatekey.js
var require_hdprivatekey = __commonJS({
  "node_modules/bitcore-lib-cash/lib/hdprivatekey.js"(exports, module) {
    "use strict";
    var assert = require_assert();
    var buffer = require_buffer();
    var _ = require_lodash();
    var $ = require_preconditions();
    var BN = require_bn2();
    var Base58 = require_base58();
    var Base58Check = require_base58check();
    var Hash = require_hash2();
    var Network = require_networks();
    var Point = require_point();
    var PrivateKey = require_privatekey();
    var Random = require_random();
    var errors = require_errors();
    var hdErrors = errors.HDPrivateKey;
    var BufferUtil = require_buffer3();
    var JSUtil = require_js();
    var MINIMUM_ENTROPY_BITS = 128;
    var BITS_TO_BYTES = 1 / 8;
    var MAXIMUM_ENTROPY_BITS = 512;
    function HDPrivateKey(arg) {
      if (arg instanceof HDPrivateKey) {
        return arg;
      }
      if (!(this instanceof HDPrivateKey)) {
        return new HDPrivateKey(arg);
      }
      if (!arg) {
        return this._generateRandomly();
      }
      if (Network.get(arg)) {
        return this._generateRandomly(arg);
      } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {
        if (HDPrivateKey.isValidSerialized(arg)) {
          this._buildFromSerialized(arg);
        } else if (JSUtil.isValidJSON(arg)) {
          this._buildFromJSON(arg);
        } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {
          this._buildFromSerialized(arg.toString());
        } else {
          throw HDPrivateKey.getSerializedError(arg);
        }
      } else if (_.isObject(arg)) {
        this._buildFromObject(arg);
      } else {
        throw new hdErrors.UnrecognizedArgument(arg);
      }
    }
    HDPrivateKey.isValidPath = function(arg, hardened) {
      if (_.isString(arg)) {
        var indexes = HDPrivateKey._getDerivationIndexes(arg);
        return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);
      }
      if (_.isNumber(arg)) {
        if (arg < HDPrivateKey.Hardened && hardened === true) {
          arg += HDPrivateKey.Hardened;
        }
        return arg >= 0 && arg < HDPrivateKey.MaxIndex;
      }
      return false;
    };
    HDPrivateKey._getDerivationIndexes = function(path) {
      var steps = path.split("/");
      if (_.includes(HDPrivateKey.RootElementAlias, path)) {
        return [];
      }
      if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {
        return null;
      }
      var indexes = steps.slice(1).map(function(step) {
        var isHardened = step.slice(-1) === "'";
        if (isHardened) {
          step = step.slice(0, -1);
        }
        if (!step || step[0] === "-") {
          return NaN;
        }
        var index = +step;
        if (isHardened) {
          index += HDPrivateKey.Hardened;
        }
        return index;
      });
      return _.some(indexes, isNaN) ? null : indexes;
    };
    HDPrivateKey.prototype.derive = function(arg, hardened) {
      return this.deriveNonCompliantChild(arg, hardened);
    };
    HDPrivateKey.prototype.deriveChild = function(arg, hardened) {
      if (_.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened);
      } else if (_.isString(arg)) {
        return this._deriveFromString(arg);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {
      if (_.isNumber(arg)) {
        return this._deriveWithNumber(arg, hardened, true);
      } else if (_.isString(arg)) {
        return this._deriveFromString(arg, true);
      } else {
        throw new hdErrors.InvalidDerivationArgument(arg);
      }
    };
    HDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {
      if (!HDPrivateKey.isValidPath(index, hardened)) {
        throw new hdErrors.InvalidPath(index);
      }
      hardened = index >= HDPrivateKey.Hardened ? true : hardened;
      if (index < HDPrivateKey.Hardened && hardened === true) {
        index += HDPrivateKey.Hardened;
      }
      var indexBuffer = BufferUtil.integerAsBuffer(index);
      var data;
      if (hardened && nonCompliant) {
        var nonZeroPadded = this.privateKey.bn.toBuffer();
        data = BufferUtil.concat([Buffer.from([0]), nonZeroPadded, indexBuffer]);
      } else if (hardened) {
        var privateKeyBuffer = this.privateKey.bn.toBuffer({ size: 32 });
        assert(privateKeyBuffer.length === 32, "length of private key buffer is expected to be 32 bytes");
        data = BufferUtil.concat([Buffer.from([0]), privateKeyBuffer, indexBuffer]);
      } else {
        data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);
      }
      var hash = Hash.sha512hmac(data, this._buffers.chainCode);
      var leftPart = BN.fromBuffer(hash.slice(0, 32), {
        size: 32
      });
      var chainCode = hash.slice(32, 64);
      var privateKey = leftPart.add(this.privateKey.toBigNumber()).umod(Point.getN()).toBuffer({
        size: 32
      });
      if (!PrivateKey.isValid(privateKey)) {
        return this._deriveWithNumber(index + 1, null, nonCompliant);
      }
      var derived = new HDPrivateKey({
        network: this.network,
        depth: this.depth + 1,
        parentFingerPrint: this.fingerPrint,
        childIndex: index,
        chainCode,
        privateKey
      });
      return derived;
    };
    HDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {
      if (!HDPrivateKey.isValidPath(path)) {
        throw new hdErrors.InvalidPath(path);
      }
      var indexes = HDPrivateKey._getDerivationIndexes(path);
      var derived = indexes.reduce(function(prev, index) {
        return prev._deriveWithNumber(index, null, nonCompliant);
      }, this);
      return derived;
    };
    HDPrivateKey.isValidSerialized = function(data, network) {
      return !HDPrivateKey.getSerializedError(data, network);
    };
    HDPrivateKey.getSerializedError = function(data, network) {
      if (!(_.isString(data) || BufferUtil.isBuffer(data))) {
        return new hdErrors.UnrecognizedArgument("Expected string or buffer");
      }
      if (!Base58.validCharacters(data)) {
        return new errors.InvalidB58Char("(unknown)", data);
      }
      try {
        data = Base58Check.decode(data);
      } catch (e) {
        return new errors.InvalidB58Checksum(data);
      }
      if (data.length !== HDPrivateKey.DataLength) {
        return new hdErrors.InvalidLength(data);
      }
      if (!_.isUndefined(network)) {
        var error = HDPrivateKey._validateNetwork(data, network);
        if (error) {
          return error;
        }
      }
      return null;
    };
    HDPrivateKey._validateNetwork = function(data, networkArg) {
      var network = Network.get(networkArg);
      if (!network) {
        return new errors.InvalidNetworkArgument(networkArg);
      }
      var version = data.slice(0, 4);
      if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {
        return new errors.InvalidNetwork(version);
      }
      return null;
    };
    HDPrivateKey.fromString = function(arg) {
      $.checkArgument(_.isString(arg), "No valid string was provided");
      return new HDPrivateKey(arg);
    };
    HDPrivateKey.fromObject = function(arg) {
      $.checkArgument(_.isObject(arg), "No valid argument was provided");
      return new HDPrivateKey(arg);
    };
    HDPrivateKey.prototype._buildFromJSON = function(arg) {
      return this._buildFromObject(JSON.parse(arg));
    };
    HDPrivateKey.prototype._buildFromObject = function(arg) {
      var buffers = {
        version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,
        depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,
        parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,
        childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,
        chainCode: _.isString(arg.chainCode) ? Buffer.from(arg.chainCode, "hex") : arg.chainCode,
        privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? Buffer.from(arg.privateKey, "hex") : arg.privateKey,
        checksum: arg.checksum ? arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum) : void 0
      };
      return this._buildFromBuffers(buffers);
    };
    HDPrivateKey.prototype._buildFromSerialized = function(arg) {
      var decoded = Base58Check.decode(arg);
      var buffers = {
        version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),
        depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),
        parentFingerPrint: decoded.slice(
          HDPrivateKey.ParentFingerPrintStart,
          HDPrivateKey.ParentFingerPrintEnd
        ),
        childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),
        chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),
        privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),
        checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),
        xprivkey: arg
      };
      return this._buildFromBuffers(buffers);
    };
    HDPrivateKey.prototype._generateRandomly = function(network) {
      return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);
    };
    HDPrivateKey.fromSeed = function(hexa, network) {
      if (JSUtil.isHexaString(hexa)) {
        hexa = Buffer.from(hexa, "hex");
      }
      if (!Buffer.isBuffer(hexa)) {
        throw new hdErrors.InvalidEntropyArgument(hexa);
      }
      if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
        throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);
      }
      if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {
        throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);
      }
      var hash = Hash.sha512hmac(hexa, Buffer.from("Bitcoin seed"));
      return new HDPrivateKey({
        network: Network.get(network) || Network.defaultNetwork,
        depth: 0,
        parentFingerPrint: 0,
        childIndex: 0,
        privateKey: hash.slice(0, 32),
        chainCode: hash.slice(32, 64)
      });
    };
    HDPrivateKey.prototype._calcHDPublicKey = function() {
      if (!this._hdPublicKey) {
        var HDPublicKey = require_hdpublickey();
        this._hdPublicKey = new HDPublicKey(this);
      }
    };
    HDPrivateKey.prototype._buildFromBuffers = function(arg) {
      HDPrivateKey._validateBufferArguments(arg);
      JSUtil.defineImmutable(this, {
        _buffers: arg
      });
      var sequence = [
        arg.version,
        arg.depth,
        arg.parentFingerPrint,
        arg.childIndex,
        arg.chainCode,
        BufferUtil.emptyBuffer(1),
        arg.privateKey
      ];
      var concat = buffer.Buffer.concat(sequence);
      if (!arg.checksum || !arg.checksum.length) {
        arg.checksum = Base58Check.checksum(concat);
      } else {
        if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {
          throw new errors.InvalidB58Checksum(concat);
        }
      }
      var network = Network.get(BufferUtil.integerFromBuffer(arg.version));
      var xprivkey;
      xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));
      arg.xprivkey = Buffer.from(xprivkey);
      var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);
      var publicKey = privateKey.toPublicKey();
      var size = HDPrivateKey.ParentFingerPrintSize;
      var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);
      JSUtil.defineImmutable(this, {
        xprivkey,
        network,
        depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),
        privateKey,
        publicKey,
        fingerPrint
      });
      this._hdPublicKey = null;
      Object.defineProperty(this, "hdPublicKey", {
        configurable: false,
        enumerable: true,
        get: function() {
          this._calcHDPublicKey();
          return this._hdPublicKey;
        }
      });
      Object.defineProperty(this, "xpubkey", {
        configurable: false,
        enumerable: true,
        get: function() {
          this._calcHDPublicKey();
          return this._hdPublicKey.xpubkey;
        }
      });
      return this;
    };
    HDPrivateKey._validateBufferArguments = function(arg) {
      var checkBuffer = function(name, size) {
        var buff = arg[name];
        assert(BufferUtil.isBuffer(buff), name + " argument is not a buffer");
        assert(
          buff.length === size,
          name + " has not the expected size: found " + buff.length + ", expected " + size
        );
      };
      checkBuffer("version", HDPrivateKey.VersionSize);
      checkBuffer("depth", HDPrivateKey.DepthSize);
      checkBuffer("parentFingerPrint", HDPrivateKey.ParentFingerPrintSize);
      checkBuffer("childIndex", HDPrivateKey.ChildIndexSize);
      checkBuffer("chainCode", HDPrivateKey.ChainCodeSize);
      checkBuffer("privateKey", HDPrivateKey.PrivateKeySize);
      if (arg.checksum && arg.checksum.length) {
        checkBuffer("checksum", HDPrivateKey.CheckSumSize);
      }
    };
    HDPrivateKey.prototype.toString = function() {
      return this.xprivkey;
    };
    HDPrivateKey.prototype.inspect = function() {
      return "<HDPrivateKey: " + this.xprivkey + ">";
    };
    HDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {
      return {
        network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), "xprivkey").name,
        depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),
        fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),
        parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),
        childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),
        chainCode: this._buffers.chainCode.toString("hex"),
        privateKey: this.privateKey.toBuffer().toString("hex"),
        checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),
        xprivkey: this.xprivkey
      };
    };
    HDPrivateKey.fromBuffer = function(arg) {
      return new HDPrivateKey(arg.toString());
    };
    HDPrivateKey.prototype.toBuffer = function() {
      return BufferUtil.copy(this._buffers.xprivkey);
    };
    HDPrivateKey.DefaultDepth = 0;
    HDPrivateKey.DefaultFingerprint = 0;
    HDPrivateKey.DefaultChildIndex = 0;
    HDPrivateKey.Hardened = 2147483648;
    HDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;
    HDPrivateKey.RootElementAlias = ["m", "M", "m'", "M'"];
    HDPrivateKey.VersionSize = 4;
    HDPrivateKey.DepthSize = 1;
    HDPrivateKey.ParentFingerPrintSize = 4;
    HDPrivateKey.ChildIndexSize = 4;
    HDPrivateKey.ChainCodeSize = 32;
    HDPrivateKey.PrivateKeySize = 32;
    HDPrivateKey.CheckSumSize = 4;
    HDPrivateKey.DataLength = 78;
    HDPrivateKey.SerializedByteSize = 82;
    HDPrivateKey.VersionStart = 0;
    HDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;
    HDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;
    HDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;
    HDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;
    HDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;
    HDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;
    HDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;
    HDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;
    HDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;
    HDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;
    HDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;
    HDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;
    HDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;
    assert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);
    module.exports = HDPrivateKey;
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bitcore-lib-cash/lib/uri.js
var require_uri = __commonJS({
  "node_modules/bitcore-lib-cash/lib/uri.js"(exports, module) {
    "use strict";
    var _ = require_lodash();
    var URL = require_url();
    var Address = require_address();
    var Networks = require_networks();
    var Unit = require_unit();
    var URI = function(data, knownParams) {
      if (!(this instanceof URI)) {
        return new URI(data, knownParams);
      }
      this.extras = {};
      this.knownParams = knownParams || [];
      this.address = this.network = this.amount = this.message = null;
      if (typeof data === "string") {
        var params = URI.parse(data);
        if (params.amount) {
          params.amount = this._parseAmount(params.amount);
        }
        this._fromObject(params);
      } else if (typeof data === "object") {
        this._fromObject(data);
      } else {
        throw new TypeError("Unrecognized data format.");
      }
    };
    URI.fromString = function fromString(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return new URI(str);
    };
    URI.fromObject = function fromObject(json) {
      return new URI(json);
    };
    URI.isValid = function(arg, knownParams) {
      try {
        new URI(arg, knownParams);
      } catch (err) {
        return false;
      }
      return true;
    };
    URI.parse = function(uri) {
      var info = URL.parse(uri, true);
      if (Networks.get(info.protocol.replace(":", ""), "prefix")) {
        var group = /[^:]*:\/?\/?([^?]*)/.exec(uri);
        info.query.address = group && group[1] || void 0;
        return info.query;
      } else {
        throw new TypeError("Invalid bitcoin URI");
      }
    };
    URI.Members = ["address", "amount", "message", "label", "r"];
    URI.prototype._fromObject = function(obj) {
      if (!Address.isValid(obj.address)) {
        throw new TypeError("Invalid bitcoin address");
      }
      this.address = new Address(obj.address);
      this.network = this.address.network;
      this.amount = obj.amount;
      for (var key in obj) {
        if (key === "address" || key === "amount") {
          continue;
        }
        if (/^req-/.exec(key) && this.knownParams.indexOf(key) === -1) {
          throw Error("Unknown required argument " + key);
        }
        var destination = URI.Members.indexOf(key) > -1 ? this : this.extras;
        destination[key] = obj[key];
      }
    };
    URI.prototype._parseAmount = function(amount) {
      amount = Number(amount);
      if (isNaN(amount)) {
        throw new TypeError("Invalid amount");
      }
      return Unit.fromBTC(amount).toSatoshis();
    };
    URI.prototype.toObject = URI.prototype.toJSON = function toObject() {
      var json = {};
      for (var i = 0; i < URI.Members.length; i++) {
        var m = URI.Members[i];
        if (this.hasOwnProperty(m) && typeof this[m] !== "undefined") {
          json[m] = this[m].toString();
        }
      }
      _.extend(json, this.extras);
      return json;
    };
    URI.prototype.toString = function() {
      var query = {};
      if (this.amount) {
        query.amount = Unit.fromSatoshis(this.amount).toBTC();
      }
      if (this.message) {
        query.message = this.message;
      }
      if (this.label) {
        query.label = this.label;
      }
      if (this.r) {
        query.r = this.r;
      }
      _.extend(query, this.extras);
      return URL.format({
        protocol: Networks.get(this.network, "name").prefix + ":",
        host: this.address.toString(true),
        query
      });
    };
    URI.prototype.inspect = function() {
      return "<URI: " + this.toString() + ">";
    };
    module.exports = URI;
  }
});

// node_modules/bitcore-lib-cash/index.js
var require_bitcore_lib_cash = __commonJS({
  "node_modules/bitcore-lib-cash/index.js"(exports, module) {
    var bitcore = module.exports;
    bitcore.version = "v" + require_package().version;
    bitcore.versionGuard = function(version) {
      if (version !== void 0) {
        var message = "More than one instance of bitcore-lib-cash found. Please make sure to require bitcore-lib and check that submodules do not also include their own bitcore-lib dependency.";
        throw new Error(message);
      }
    };
    bitcore.versionGuard(global._bitcoreCash);
    global._bitcoreCash = bitcore.version;
    bitcore.crypto = {};
    bitcore.crypto.BN = require_bn2();
    bitcore.crypto.ECDSA = require_ecdsa();
    bitcore.crypto.Schnorr = require_schnorr();
    bitcore.crypto.Hash = require_hash2();
    bitcore.crypto.Random = require_random();
    bitcore.crypto.Point = require_point();
    bitcore.crypto.Signature = require_signature3();
    bitcore.encoding = {};
    bitcore.encoding.Base58 = require_base58();
    bitcore.encoding.Base58Check = require_base58check();
    bitcore.encoding.BufferReader = require_bufferreader();
    bitcore.encoding.BufferWriter = require_bufferwriter();
    bitcore.encoding.Varint = require_varint();
    bitcore.util = {};
    bitcore.util.buffer = require_buffer3();
    bitcore.util.js = require_js();
    bitcore.util.preconditions = require_preconditions();
    bitcore.util.base32 = require_base32();
    bitcore.util.convertBits = require_convertBits();
    bitcore.errors = require_errors();
    bitcore.Address = require_address();
    bitcore.Block = require_block2();
    bitcore.MerkleBlock = require_merkleblock();
    bitcore.BlockHeader = require_blockheader();
    bitcore.HDPrivateKey = require_hdprivatekey();
    bitcore.HDPublicKey = require_hdpublickey();
    bitcore.Networks = require_networks();
    bitcore.Opcode = require_opcode();
    bitcore.PrivateKey = require_privatekey();
    bitcore.PublicKey = require_publickey2();
    bitcore.Script = require_script2();
    bitcore.Transaction = require_transaction2();
    bitcore.URI = require_uri();
    bitcore.Unit = require_unit();
    bitcore.deps = {};
    bitcore.deps.bnjs = require_bn();
    bitcore.deps.bs58 = require_bs58();
    bitcore.deps.Buffer = Buffer;
    bitcore.deps.elliptic = require_elliptic();
    bitcore.deps._ = require_lodash();
    bitcore.Transaction.sighash = require_sighash();
  }
});
export default require_bitcore_lib_cash();
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

bitcore-lib-cash/lib/address.js:
  (***
   * @license
   * https://github.com/bitcoincashjs/cashaddr
   * Copyright (c) 2017 Emilio Almansi
   * Distributed under the MIT software license, see the accompanying
   * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
   *)
*/
//# sourceMappingURL=bitcore-lib-cash.js.map
